2018-07-16 14:44:18 - // include directory, this will be replaced by the kernel
2018-07-16 14:44:18 - #I "/home/nbuser/IfSharp/bin"
2018-07-16 14:44:18 - // load base dlls
2018-07-16 14:44:18 - #r "IfSharp.Kernel.dll"
2018-07-16 14:44:18 - #r "NetMQ.dll"
2018-07-16 14:44:18 - // open the global functions and methods
2018-07-16 14:44:18 - open IfSharp.Kernel
2018-07-16 14:44:18 - open IfSharp.Kernel.Globals
2018-07-16 14:44:35 - F# Interactive for F# 4.1
2018-07-16 14:44:35 - Freely distributed under the Apache 2.0 Open Source License
2018-07-16 14:44:35 - For help type #help;;
2018-07-16 14:44:35 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-07-16 14:44:35 -   seq []
2018-07-16 14:44:35 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-07-16 14:44:35 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-07-16 14:44:35 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-07-16 14:44:44 - Unknown content type on shell. msg_type is `comm_info_request`
2018-07-16 14:45:38 - let wc = new System.Net.WebClient()
2018-07-16 14:45:38 - wc.DownloadFile(
2018-07-16 14:45:38 -     "https://download.microsoft.com/download/D/C/4/DC44E915-26FE-48AB-BD7C-AC1D92B23230/Infer.NET%202.7.1803.1901.zip", 
2018-07-16 14:45:38 -     "/home/nbuser/IfSharp/bin/packages/infer.zip")
2018-07-16 14:45:50 - open System.Diagnostics
2018-07-16 14:45:50 - let ps = 
2018-07-16 14:45:50 -     ProcessStartInfo(
2018-07-16 14:45:50 -         FileName="unzip", 
2018-07-16 14:45:50 -         Arguments="/home/nbuser/IfSharp/bin/packages/infer.zip -d /home/nbuser/IfSharp/bin/packages/infer",
2018-07-16 14:45:50 -         RedirectStandardOutput=true,UseShellExecute=false)
2018-07-16 14:45:50 - let p = Process.Start(ps)
2018-07-16 14:45:50 - p.StandardOutput.ReadToEnd()
2018-07-16 14:45:53 - #r "/home/nbuser/IfSharp/bin/packages/infer/Bin/Infer.FSharp.dll"
2018-07-16 14:46:14 - //#load "Paket.fsx"
2018-07-16 14:46:14 - //Paket.Package ["Infer.NET"]
2018-07-16 14:47:36 - open System
2018-07-16 14:47:36 - open MicrosoftResearch.Infer
2018-07-16 14:47:36 - open MicrosoftResearch.Infer.FSharp
2018-07-16 14:47:40 - [<ReflectedDefinition>]
2018-07-16 14:47:40 - let mystery (): bool*bool =
2018-07-16 14:47:40 -   let aliceDunnit = random (Bernoulli 0.30)
2018-07-16 14:47:40 -   let withGun = if aliceDunnit then random (Bernoulli 0.03) else random (Bernoulli 0.80)
2018-07-16 14:47:40 -   aliceDunnit, withGun
2018-07-16 14:47:40 - The value or constructor 'random' is not defined. Maybe you want one of the following:
2018-07-16 14:47:40 -    Random
2018-07-16 14:47:40 - The value or constructor 'random' is not defined. Maybe you want one of the following:
2018-07-16 14:47:40 -    Random
2018-07-16 14:47:40 - The value or constructor 'random' is not defined. Maybe you want one of the following:
2018-07-16 14:47:40 -    Random
2018-07-16 14:53:30 - open System.Diagnostics
2018-07-16 14:53:30 - let ps = 
2018-07-16 14:53:30 -     ProcessStartInfo(
2018-07-16 14:53:30 -         FileName="unzip", 
2018-07-16 14:53:30 -         Arguments="/home/nbuser/IfSharp/bin/packages/infer.zip -d /home/nbuser/IfSharp/bin/packages/infer",
2018-07-16 14:53:30 -         RedirectStandardOutput=true,UseShellExecute=false)
2018-07-16 14:53:30 - let p = Process.Start(ps)
2018-07-16 14:53:30 - p.StandardOutput.ReadToEnd()
2018-07-17 15:06:35 - // include directory, this will be replaced by the kernel
2018-07-17 15:06:35 - #I "/home/nbuser/IfSharp/bin"
2018-07-17 15:06:35 - // load base dlls
2018-07-17 15:06:35 - #r "IfSharp.Kernel.dll"
2018-07-17 15:06:35 - #r "NetMQ.dll"
2018-07-17 15:06:35 - // open the global functions and methods
2018-07-17 15:06:35 - open IfSharp.Kernel
2018-07-17 15:06:35 - open IfSharp.Kernel.Globals
2018-07-17 15:06:58 - F# Interactive for F# 4.1
2018-07-17 15:06:58 - Freely distributed under the Apache 2.0 Open Source License
2018-07-17 15:06:58 - For help type #help;;
2018-07-17 15:06:58 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-07-17 15:06:58 -   seq []
2018-07-17 15:06:58 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-07-17 15:06:58 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-07-17 15:06:58 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-07-17 15:07:06 - Unknown content type on shell. msg_type is `comm_info_request`
2018-10-15 20:30:11 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-15 20:30:11 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-15 20:30:11 - For help type #help;;
2018-10-15 20:30:11 - > val it :
2018-10-15 20:30:11 -   ResizeArray<System.Type *
2018-10-15 20:30:11 -               (obj ->
2018-10-15 20:30:11 -                  seq<string *
2018-10-15 20:30:11 -                      string> *
2018-10-15 20:30:11 -                  string)>
2018-10-15 20:30:11 - = seq []
2018-10-15 20:30:11 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-15 20:30:11 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-15 20:30:11 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-15 20:50:35 - // cloudy
2018-10-15 20:50:35 - let cloudy:Variable<bool> = Variable.Bernoulli(0.5);
2018-10-15 20:50:36 - The type 'Variable' is not defined.
2018-10-15 20:50:36 - The value, namespace, type or module 'Variable' is not defined.
2018-10-15 20:50:55 - #load "Paket.fsx"
2018-10-15 20:50:56 - Paket.Package
2018-10-15 20:50:56 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-15 20:50:56 -       "Microsoft.ML.Probabilistic"
2018-10-15 20:50:56 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-15 20:50:56 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-15 20:50:56 -   ]
2018-10-15 20:51:11 - // #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-15 20:51:11 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-15 20:51:11 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-15 20:51:23 - open Microsoft.ML.Probabilistic  
2018-10-15 20:51:23 - open Microsoft.ML.Probabilistic.Models  
2018-10-15 20:51:23 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-15 20:51:23 - open Microsoft.ML.Probabilistic.Factors  
2018-10-15 20:51:23 - open Microsoft.ML.Probabilistic.FSharp
2018-10-15 20:51:24 - The namespace 'Models' is not defined.
2018-10-15 20:51:24 - The namespace 'FSharp' is not defined.
2018-10-15 20:51:24 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-15 20:51:39 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-15 20:51:43 - The namespace 'Models' is not defined.
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableDirichletArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableDirichletArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableDirichletArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableDirichletArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableWishartArrayOfArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableWishartArrayOfArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableDirichletArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 -    VariableDirichletArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2DOfArray
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2DOfArray
2018-10-15 20:51:43 -    VariableGaussianArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableBetaArrayOfArray
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableBetaArrayOfArray
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableBetaArrayOfArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableBetaArrayOfArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableBetaArrayOfArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableBetaArrayOfArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 -    VariableWishartArray2D
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGaussianArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableBetaArray
2018-10-15 20:51:43 -    VariableGammaArray
2018-10-15 20:51:43 -    VariableBetaArray2D
2018-10-15 20:51:43 -    VariableWishartArray
2018-10-15 20:51:43 -    VariableGammaArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariableDiscreteArray2DOfArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariableDiscreteArray2DOfArray
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray2DOfArray
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray2DOfArray
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray2DOfArray
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray2DOfArray
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray2DOfArray
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray2DOfArray
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray2DOfArray
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableDiscreteArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableDiscreteArray2DOfArray
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariablePoissonArray
2018-10-15 20:51:43 -    VariablePoissonArray2D
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableBernoulliArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableBernoulliArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableBernoulliArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableBernoulliArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableBernoulliArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableBernoulliArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableBernoulliArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableBernoulliArray2D
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableBernoulliArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableBernoulliArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableBernoulliArray2D
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableBernoulliArray
2018-10-15 20:51:43 -    VariableBernoulliArray2D
2018-10-15 20:51:43 - The type 'Range' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    Rand
2018-10-15 20:51:43 - The type 'Range' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    Rand
2018-10-15 20:51:43 - The value, namespace, type or module 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-15 20:51:43 - The type 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The type 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The value, namespace, type or module 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-15 20:51:43 - The type 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The type 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The type 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The value, namespace, type or module 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The type 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-15 20:51:43 - The type 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The type 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The type 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The value, namespace, type or module 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The value, namespace, type or module 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The type 'Range' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    Rand
2018-10-15 20:51:43 - The type 'Range' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    Rand
2018-10-15 20:51:43 - The type 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The value, namespace, type or module 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The type 'Range' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    Rand
2018-10-15 20:51:43 - The type 'Range' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    Rand
2018-10-15 20:51:43 - The type 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-15 20:51:43 - The type 'VariableArray2D' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 - The type 'Range' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    Rand
2018-10-15 20:51:43 - The type 'Range' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    Rand
2018-10-15 20:51:43 - The type 'Range' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    Rand
2018-10-15 20:51:43 - The type 'Range' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    Rand
2018-10-15 20:51:43 - The type 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The type 'Range' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    Rand
2018-10-15 20:51:43 - The type 'Range' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    Rand
2018-10-15 20:51:43 - The type 'Range' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    Rand
2018-10-15 20:51:43 - The type 'Range' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    Rand
2018-10-15 20:51:43 - The type 'Variable' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-15 20:51:43 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-15 20:51:43 - The type 'InferenceEngine' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    InferRuntimeException
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-15 20:51:43 - The type 'InferenceEngine' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    InferRuntimeException
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-15 20:51:43 - The type 'InferenceEngine' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    InferRuntimeException
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-15 20:51:43 - The type 'InferenceEngine' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    InferRuntimeException
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-15 20:51:43 - The type 'InferenceEngine' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    InferRuntimeException
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-15 20:51:43 - The type 'InferenceEngine' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    InferRuntimeException
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-15 20:51:43 - The type 'InferenceEngine' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    InferRuntimeException
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-15 20:51:43 - The type 'InferenceEngine' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    InferRuntimeException
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-15 20:51:43 - The type 'InferenceEngine' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    InferRuntimeException
2018-10-15 20:51:43 - The type 'VariableArray' is not defined. Maybe you want one of the following:
2018-10-15 20:51:43 -    VariableMaxOp
2018-10-15 20:51:43 -    VariableGibbsOp
2018-10-15 20:51:43 -    VariableOp
2018-10-15 20:51:43 -    VariableVmpOp
2018-10-15 20:51:43 -    VariablePointOp
2018-10-15 20:51:43 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-15 20:51:44 - open Microsoft.ML.Probabilistic  
2018-10-15 20:51:44 - open Microsoft.ML.Probabilistic.Models  
2018-10-15 20:51:44 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-15 20:51:44 - open Microsoft.ML.Probabilistic.Factors  
2018-10-15 20:51:44 - open Microsoft.ML.Probabilistic.FSharp
2018-10-15 20:51:44 - The namespace 'Models' is not defined.
2018-10-15 20:51:44 - The namespace 'FSharp' is not defined.
2018-10-15 20:52:19 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-15 20:52:34 - open Microsoft.ML.Probabilistic  
2018-10-15 20:52:34 - open Microsoft.ML.Probabilistic.Models  
2018-10-15 20:52:34 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-15 20:52:34 - open Microsoft.ML.Probabilistic.Factors  
2018-10-15 20:52:34 - open Microsoft.ML.Probabilistic.FSharp
2018-10-15 20:52:34 - The namespace 'Models' is not defined.
2018-10-15 20:52:34 - The namespace 'FSharp' is not defined.
2018-10-15 20:52:48 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-15 20:52:54 - open Microsoft.ML.Probabilistic  
2018-10-15 20:52:54 - open Microsoft.ML.Probabilistic.Models  
2018-10-15 20:52:54 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-15 20:52:54 - open Microsoft.ML.Probabilistic.Factors  
2018-10-15 20:52:54 - open Microsoft.ML.Probabilistic.FSharp
2018-10-15 20:52:55 - The namespace 'Models' is not defined.
2018-10-15 20:52:55 - The namespace 'FSharp' is not defined.
2018-10-15 20:53:00 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-15 20:53:00 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-15 20:53:01 - #r "Microsoft.ML.Probabilistic.dll"
2018-10-15 20:53:01 - #r "Microsoft.ML.Probabilistic.Compiler.dll"
2018-10-15 20:53:04 - open System
2018-10-15 20:53:05 - open Microsoft.ML.Probabilistic  
2018-10-15 20:53:05 - open Microsoft.ML.Probabilistic.Models  
2018-10-15 20:53:05 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-15 20:53:05 - open Microsoft.ML.Probabilistic.Factors  
2018-10-15 20:53:05 - open Microsoft.ML.Probabilistic.FSharp
2018-10-15 20:53:05 - The namespace 'FSharp' is not defined.
2018-10-15 20:53:23 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-15 20:53:35 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-15 20:53:36 - open Microsoft.ML.Probabilistic.FSharp
2018-10-15 20:53:37 - // cloudy
2018-10-15 20:53:37 - let cloudy:Variable<bool> = Variable.Bernoulli(0.5)
2018-10-15 20:53:37 - The type 'Variable' is not defined.
2018-10-15 20:53:37 - The value, constructor, namespace or type 'Bernoulli' is not defined.
2018-10-15 20:54:48 - // cloudy
2018-10-15 20:54:48 - let cloudy= Variable.Bernoulli(0.5)
2018-10-15 20:54:48 - The value, constructor, namespace or type 'Bernoulli' is not defined.
2018-10-15 20:54:54 - // cloudy
2018-10-15 20:54:54 - let cloudy = Variable.Bernoulli(0.5)
2018-10-15 20:54:55 - The value, constructor, namespace or type 'Bernoulli' is not defined.
2018-10-16 14:20:30 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-16 14:20:30 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-16 14:20:30 - For help type #help;;
2018-10-16 14:20:30 - > val it :
2018-10-16 14:20:30 -   ResizeArray<System.Type *
2018-10-16 14:20:30 -               (obj ->
2018-10-16 14:20:30 -                  seq<string *
2018-10-16 14:20:30 -                      string> *
2018-10-16 14:20:30 -                  string)>
2018-10-16 14:20:30 - = seq []
2018-10-16 14:20:30 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-16 14:20:30 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-16 14:20:30 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-16 17:32:21 - #load "Paket.fsx"
2018-10-16 17:32:24 - Paket.Package
2018-10-16 17:32:24 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-16 17:32:24 -       "Microsoft.ML.Probabilistic"
2018-10-16 17:32:24 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-16 17:32:24 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-16 17:32:24 -   ]
2018-10-16 17:32:48 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-16 17:32:52 - open Microsoft.ML.Probabilistic  
2018-10-16 17:32:52 - open Microsoft.ML.Probabilistic.Models  
2018-10-16 17:32:54 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-16 17:33:05 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-16 17:33:06 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-16 17:33:06 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-16 17:33:06 - #r "Microsoft.ML.Probabilistic.dll"
2018-10-16 17:33:06 - #r "Microsoft.ML.Probabilistic.Compiler.dll"
2018-10-16 17:33:18 - open System
2018-10-16 17:33:18 - open Microsoft.ML.Probabilistic  
2018-10-16 17:33:18 - open Microsoft.ML.Probabilistic.Models  
2018-10-16 17:33:18 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-16 17:33:18 - open Microsoft.ML.Probabilistic.Factors  
2018-10-16 17:33:18 - open Microsoft.ML.Probabilistic.FSharp
2018-10-16 17:33:33 - let aliceDunnit:Variable<bool> = Variable.Bernoulli(0.30).Named("aliceDunnit")
2018-10-16 17:34:37 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-16 17:34:37 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-16 17:34:37 - For help type #help;;
2018-10-16 17:34:37 - > val it :
2018-10-16 17:34:37 -   ResizeArray<System.Type *
2018-10-16 17:34:37 -               (obj ->
2018-10-16 17:34:37 -                  seq<string *
2018-10-16 17:34:37 -                      string> *
2018-10-16 17:34:37 -                  string)>
2018-10-16 17:34:37 - = seq []
2018-10-16 17:34:37 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-16 17:34:37 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-16 17:34:37 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-16 19:47:39 - let aliceDunnit:Variable<bool> = Variable.Bernoulli(0.30).Named("aliceDunnit")
2018-10-16 21:55:34 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-16 21:55:34 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-16 21:55:34 - For help type #help;;
2018-10-16 21:55:34 - > val it :
2018-10-16 21:55:34 -   ResizeArray<System.Type *
2018-10-16 21:55:34 -               (obj ->
2018-10-16 21:55:34 -                  seq<string *
2018-10-16 21:55:34 -                      string> *
2018-10-16 21:55:34 -                  string)>
2018-10-16 21:55:34 - = seq []
2018-10-16 21:55:34 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-16 21:55:34 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-16 21:55:34 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-17 18:15:48 - #load "Paket.fsx"
2018-10-17 18:15:51 - Expression evaluation failed: Insufficient memory to continue the execution of the program.
2018-10-17 18:15:51 - OutOfMemoryExceptionInsufficient memory to continue the execution of the program.
2018-10-17 18:15:51 -   at (wrapper alloc) System.Object.AllocVector(intptr,intptr)
2018-10-17 18:15:51 -   at Microsoft.FSharp.Collections.ArrayModule.ZeroCreate[T] (System.Int32 count) [0x00049] in <5a7d678a904cf4daa74503838a677d5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+Shim.File.ReadBinaryChunk.Static (System.String fileName, System.Int32 start, System.Int32 len) [0x00016] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader+WeakByteFile.Microsoft-FSharp-Compiler-AbstractIL-ILBinaryReader-BinaryFile-GetView () [0x0008c] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader.seekReadCustomAttributeRow (Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader+ILMetadataReader ctxt, System.Int32 idx) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader+customAttrsReader@2538-1.Invoke (System.Int32 idx) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader.seekReadIndexedRows$cont@945[a,b,c] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] rowReader, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] rowConverter, System.Int32 numRows, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] keyFunc, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] keyComparer, Microsoft.FSharp.Core.Unit unitVar) [0x0001c] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader.seekReadIndexedRows[a,b,c] (System.Int32 numRows, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] rowReader, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] keyFunc, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] keyComparer, System.Boolean binaryChop, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] rowConverter) [0x00004] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader+customAttrsReader@2535.Invoke (System.Int32 idx) [0x0004b] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.IL+ILAttributesStored.GetCustomAttrs (System.Int32 metadataIndex) [0x00022] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.IL+ILTypeDef.get_CustomAttrs () [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Tastops.TryBindTyconRefAttribute[a] (Microsoft.FSharp.Compiler.TcGlobals+TcGlobals g, Microsoft.FSharp.Compiler.Range+range m, Microsoft.FSharp.Compiler.TcGlobals+BuiltinAttribInfo _arg1, Microsoft.FSharp.Compiler.Tast+EntityRef tcref, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f1, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f2, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f3) [0x0008e] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Tastops.TyconRefHasAttribute (Microsoft.FSharp.Compiler.TcGlobals+TcGlobals g, Microsoft.FSharp.Compiler.Range+range m, Microsoft.FSharp.Compiler.TcGlobals+BuiltinAttribInfo attribSpec, Microsoft.FSharp.Compiler.Tast+EntityRef tcref) [0x00013] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.NameResolution.GetCSharpStyleIndexedExtensionMembersForTyconRef (Microsoft.FSharp.Compiler.Import+ImportMap amap, Microsoft.FSharp.Compiler.Range+range m, Microsoft.FSharp.Compiler.Tast+EntityRef tcrefOfStaticClass) [0x00025] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.NameResolution.AddPartsOfTyconRefToNameEnv (Microsoft.FSharp.Compiler.NameResolution+BulkAdd bulkAddMode, System.Boolean ownDefinition, Microsoft.FSharp.Compiler.TcGlobals+TcGlobals g, Microsoft.FSharp.Compiler.Import+ImportMap amap, Microsoft.FSharp.Compiler.Range+range m, Microsoft.FSharp.Compiler.NameResolution+NameResolutionEnv nenv, Microsoft.FSharp.Compiler.Tast+EntityRef tcref) [0x0004e] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.NameResolution+env@702-6.Invoke (Microsoft.FSharp.Compiler.NameResolution+NameResolutionEnv nenv, Microsoft.FSharp.Compiler.Tast+EntityRef tcref) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Collections.ListModule.Fold[T,TState] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] folder, TState state, Microsoft.FSharp.Collections.FSharpList`1[T] list) [0x0002a] in <5a7d678a904cf4daa74503838a677d5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.NameResolution.AddTyconRefsToNameEnv (Microsoft.FSharp.Compiler.NameResolution+BulkAdd bulkAddMode, System.Boolean ownDefinition, Microsoft.FSharp.Compiler.TcGlobals+TcGlobals g, Microsoft.FSharp.Compiler.Import+ImportMap amap, Microsoft.FSharp.Compiler.Range+range m, System.Boolean root, Microsoft.FSharp.Compiler.NameResolution+NameResolutionEnv nenv, Microsoft.FSharp.Collections.FSharpList`1[T] tcrefs) [0x0001b] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.NameResolution.AddModuleOrNamespaceContentsToNameEnv (Microsoft.FSharp.Compiler.TcGlobals+TcGlobals g, Microsoft.FSharp.Compiler.Import+ImportMap amap, Microsoft.FSharp.Compiler.AccessibilityLogic+AccessorDomain ad, Microsoft.FSharp.Compiler.Range+range m, System.Boolean root, Microsoft.FSharp.Compiler.NameResolution+NameResolutionEnv nenv, Microsoft.FSharp.Compiler.Tast+EntityRef modref) [0x00102] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.NameResolution+AddModulesAndNamespacesContentsToNameEnv@820.Invoke (Microsoft.FSharp.Compiler.Tast+EntityRef modref, Microsoft.FSharp.Compiler.NameResolution+NameResolutionEnv acc) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Collections.ListModule.foldArraySubRight[T,a] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, T[] arr, System.Int32 start, System.Int32 fin, a acc) [0x0000b] in <5a7d678a904cf4daa74503838a677d5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Collections.ListModule.FoldBack[T,TState] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] folder, Microsoft.FSharp.Collections.FSharpList`1[T] list, TState state) [0x000b8] in <5a7d678a904cf4daa74503838a677d5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.TypeChecker.OpenModulesOrNamespaces (Microsoft.FSharp.Compiler.NameResolution+TcResultsSink tcSink, Microsoft.FSharp.Compiler.TcGlobals+TcGlobals g, Microsoft.FSharp.Compiler.Import+ImportMap amap, Microsoft.FSharp.Compiler.Range+range scopem, System.Boolean root, Microsoft.FSharp.Compiler.TypeChecker+TcEnv env, Microsoft.FSharp.Collections.FSharpList`1[T] mvvs, Microsoft.FSharp.Compiler.NameResolution+OpenDeclaration openDeclaration) [0x00012] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.TypeChecker.TcOpenDecl (Microsoft.FSharp.Compiler.NameResolution+TcResultsSink tcSink, Microsoft.FSharp.Compiler.TcGlobals+TcGlobals g, Microsoft.FSharp.Compiler.Import+ImportMap amap, Microsoft.FSharp.Compiler.Range+range m, Microsoft.FSharp.Compiler.Range+range scopem, Microsoft.FSharp.Compiler.TypeChecker+TcEnv env, Microsoft.FSharp.Collections.FSharpList`1[T] longId) [0x000b5] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.TypeChecker+TcModuleOrNamespaceElementNonMutRec@16607-1.Invoke (Microsoft.FSharp.Core.Unit unitVar) [0x00202] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule+catch@859-1[a].Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x0003f] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d8] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.TypeChecker+TcModuleOrNamespaceElementNonMutRec@16606-19.Invoke (System.Exception _arg3) [0x00011] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule+bind@850-1[b,a].Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule+bind@850-1[b,a].Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule+bind@850-1[b,a].Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule+catch@859-1[a].Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x0003f] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d8] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.TypeChecker+TcModuleOrNamespaceElementNonMutRec@16606-19.Invoke (System.Exception _arg3) [0x00011] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule+bind@850-1[b,a].Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule+bind@850-1[b,a].Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule+bind@850-1[b,a].Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule+catch@859-1[a].Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x0003f] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d8] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.TypeChecker+TcModuleOrNamespaceElementNonMutRec@16606-19.Invoke (System.Exception _arg3) [0x00011] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule+bind@850-1[b,a].Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule+bind@850-1[b,a].Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule+bind@850-1[b,a].Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule+bind@850-1[b,a].Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule+catch@859-1[a].Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x0003f] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d8] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.CompileOps+TypeCheckOneInputEventually@5411-8.Invoke (System.Exception _arg4) [0x0000b] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule.forceWhile[a] (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] check, Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+Eventually`1[T] e) [0x00021] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+EventuallyModule.force[a] (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+Eventually`1[T] e) [0x00006] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.CompileOps.TypeCheckOneInput (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] checkForErrors, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.CompileOps+TcImports tcImports, Microsoft.FSharp.Compiler.TcGlobals+TcGlobals tcGlobals, Microsoft.FSharp.Core.FSharpOption`1[T] prefixPathOpt, Microsoft.FSharp.Compiler.CompileOps+TcState tcState, Microsoft.FSharp.Compiler.Ast+ParsedInput inp) [0x0002f] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.CompileOps+TypeCheckClosedInputSet@5553.Invoke (Microsoft.FSharp.Compiler.CompileOps+TcState tcState, Microsoft.FSharp.Compiler.Ast+ParsedInput inp) [0x00000] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Primitives.Basics.List.mapFold[TState,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, TState acc, Microsoft.FSharp.Collections.FSharpList`1[T] xs) [0x00021] in <5a7d678a904cf4daa74503838a677d5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Collections.ListModule.MapFold[T,TState,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, TState state, Microsoft.FSharp.Collections.FSharpList`1[T] list) [0x00000] in <5a7d678a904cf4daa74503838a677d5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.CompileOps.TypeCheckClosedInputSet (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] checkForErrors, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.CompileOps+TcImports tcImports, Microsoft.FSharp.Compiler.TcGlobals+TcGlobals tcGlobals, Microsoft.FSharp.Core.FSharpOption`1[T] prefixPathOpt, Microsoft.FSharp.Compiler.CompileOps+TcState tcState, Microsoft.FSharp.Collections.FSharpList`1[T] inputs) [0x0000d] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell.f@1-108 (Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompiler this, Microsoft.FSharp.Collections.FSharpList`1[T] prefixPath, Microsoft.FSharp.Collections.FSharpList`1[T] inputs, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcState tcState, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Core.Unit _arg1) [0x0001e] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompiler.ProcessInputs (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate, Microsoft.FSharp.Collections.FSharpList`1[T] inputs, System.Boolean showTypes, System.Boolean isIncrementalFragment, System.Boolean isInteractiveItExpr, Microsoft.FSharp.Collections.FSharpList`1[T] prefixPath) [0x0003e] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompiler.EvalParsedSourceFiles (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate, Microsoft.FSharp.Collections.FSharpList`1[T] inputs) [0x0001d] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompiler.EvalSourceFiles (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate, Microsoft.FSharp.Compiler.Range+range m, Microsoft.FSharp.Collections.FSharpList`1[T] sourceFiles, Microsoft.FSharp.Compiler.Lexhelp+LexResourceManager lexResourceManager, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger) [0x00142] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+clo@1898-298.Invoke (Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x0004b] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00018] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x0003f] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d8] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.StopProcessingRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000b4] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00033] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.ExecInteraction (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate, Microsoft.FSharp.Compiler.Ast+ParsedFsiInteraction action, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger) [0x0000f] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.execParsedInteractions (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate, Microsoft.FSharp.Core.FSharpOption`1[T] action, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpOption`1[T] lastResult) [0x00293] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+clo@2077-301.Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x00002] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.mainThreadProcessAction[a,b] (a ctok, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action, b istate) [0x00048] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x0003f] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d8] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.StopProcessingRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000b4] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.mainThreadProcessAction[a,b] (a ctok, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action, b istate) [0x00102] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.mainThreadProcessParsedInteractions (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpOption`1[T] action, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x0000a] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+EvalInteraction@2220.Invoke (Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x00012] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00018] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x0003f] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d8] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.StopProcessingRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000b4] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00033] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.EvalInteraction (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, System.String sourceText, System.String scriptFileName, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger) [0x00045] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiEvaluationSession.EvalInteractionNonThrowing (System.String code) [0x00020] in <5abc127aa80f33aea74503837a12bc5a>:0 
2018-10-17 18:15:51 -   at IfSharp.Kernel.IfSharpKernel.executeRequest (IfSharp.Kernel.KernelMessage msg, IfSharp.Kernel.ExecuteRequest content) [0x000b8] in <5bb1bccc1b085d3da7450383ccbcb15b>:0 
2018-10-17 18:15:52 - Paket.Package
2018-10-17 18:15:52 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-17 18:15:52 -       "Microsoft.ML.Probabilistic"
2018-10-17 18:15:52 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-17 18:15:52 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-17 18:15:52 -       "NETStandard.Library" 
2018-10-17 18:15:52 -   ]
2018-10-17 18:18:05 - shutdown request
2018-10-17 18:18:30 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-17 18:18:30 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-17 18:18:30 - For help type #help;;
2018-10-17 18:18:30 - > val it :
2018-10-17 18:18:30 -   ResizeArray<System.Type *
2018-10-17 18:18:30 -               (obj ->
2018-10-17 18:18:30 -                  seq<string *
2018-10-17 18:18:30 -                      string> *
2018-10-17 18:18:30 -                  string)>
2018-10-17 18:18:30 - = seq []
2018-10-17 18:18:30 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-17 18:18:30 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-17 18:18:30 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-17 18:18:31 - #load "Paket.fsx"
2018-10-17 18:18:38 - Paket.Package
2018-10-17 18:18:38 -   [   "Microsoft.ML.Probabilistic"
2018-10-17 18:18:38 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-17 18:18:38 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-17 18:18:38 -       "NETStandard.Library" 
2018-10-17 18:18:38 -   ]
2018-10-17 18:22:00 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-17 18:22:07 - open Microsoft.ML.Probabilistic  
2018-10-17 18:22:07 - open Microsoft.ML.Probabilistic.Models  
2018-10-17 18:22:09 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-17 18:22:59 - open System
2018-10-17 18:22:59 - open System.IO
2018-10-17 18:23:00 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-17 18:23:00 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-17 18:23:00 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-17 18:23:00 - #r "Microsoft.ML.Probabilistic"
2018-10-17 18:23:00 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-17 18:23:00 - #r "netstandard"
2018-10-17 18:23:01 - open Microsoft.ML.Probabilistic
2018-10-17 18:23:01 - open Microsoft.ML.Probabilistic.Algorithms
2018-10-17 18:23:01 - open Microsoft.ML.Probabilistic.Distributions // VectorGaussian, Gamma
2018-10-17 18:23:01 - open Microsoft.ML.Probabilistic.Factors
2018-10-17 18:23:01 - open Microsoft.ML.Probabilistic.Math          // Vector
2018-10-17 18:23:01 - open Microsoft.ML.Probabilistic.Models        // Variable, VariableArray, Range
2018-10-17 18:29:51 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-17 18:29:57 - open Microsoft.ML.Probabilistic.FSharp
2018-10-17 19:08:51 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-17 19:08:51 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-17 19:08:51 - For help type #help;;
2018-10-17 19:08:51 - > val it :
2018-10-17 19:08:51 -   ResizeArray<System.Type *
2018-10-17 19:08:51 -               (obj ->
2018-10-17 19:08:51 -                  seq<string *
2018-10-17 19:08:51 -                      string> *
2018-10-17 19:08:51 -                  string)>
2018-10-17 19:08:51 - = seq []
2018-10-17 19:08:51 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-17 19:08:51 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-17 19:08:51 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-17 19:10:36 - open System.IO
2018-10-17 19:11:21 - ### Old C# code
2018-10-17 19:11:26 - Unexpected symbol # in directive. Expected identifier or other token.
2018-10-17 19:11:26 - Identifiers followed by '#' are reserved for future use
2018-10-17 19:11:26 - parse error
2018-10-18 19:01:01 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-18 19:01:01 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-18 19:01:01 - For help type #help;;
2018-10-18 19:01:01 - > val it :
2018-10-18 19:01:01 -   ResizeArray<System.Type *
2018-10-18 19:01:01 -               (obj ->
2018-10-18 19:01:01 -                  seq<string *
2018-10-18 19:01:01 -                      string> *
2018-10-18 19:01:01 -                  string)>
2018-10-18 19:01:01 - = seq []
2018-10-18 19:01:01 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-18 19:01:01 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-18 19:01:01 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-18 19:01:17 - Reporting 0 opened comms
2018-10-18 19:40:16 - #load "Paket.fsx"
2018-10-18 19:41:06 - Paket.Package
2018-10-18 19:41:06 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-18 19:41:06 -       "Microsoft.ML.Probabilistic"
2018-10-18 19:41:06 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-18 19:41:06 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-18 19:41:06 -       "NETStandard.Library"
2018-10-18 19:41:06 -   ]
2018-10-18 19:43:23 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-18 19:43:32 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-18 19:44:49 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-18 19:44:49 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-18 19:44:49 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-18 19:44:50 - #r "Microsoft.ML.Probabilistic"
2018-10-18 19:44:50 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-18 19:44:50 - #r "netstandard"
2018-10-18 19:44:52 - open System
2018-10-18 19:44:54 - open Microsoft.ML.Probabilistic  
2018-10-18 19:44:54 - open Microsoft.ML.Probabilistic.Models  
2018-10-18 19:44:54 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-18 19:44:54 - open Microsoft.ML.Probabilistic.Factors  
2018-10-18 19:44:56 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-18 19:45:03 - open Microsoft.ML.Probabilistic.FSharp
2018-10-18 19:45:03 - open Microsoft.ML.Probabilistic  
2018-10-18 19:45:03 - open Microsoft.ML.Probabilistic.Models  
2018-10-18 19:45:03 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-18 19:45:03 - open Microsoft.ML.Probabilistic.Factors  
2018-10-18 19:45:03 - open Microsoft.ML.Probabilistic.Math
2018-10-18 19:50:11 - let Cloudy = VariableArray<int>
2018-10-18 19:50:12 - This type has no accessible object constructors
2018-10-18 19:51:55 - let Cloudy = VariableArray<int>()
2018-10-18 19:51:56 - This type has no accessible object constructors
2018-10-18 19:52:43 - let Cloudy = VariableArray<int>().Named("Cloudy")
2018-10-18 19:52:43 - This type has no accessible object constructors
2018-10-18 20:02:53 - let C = Range(2).Named("C");
2018-10-18 20:02:53 - let S = new Range(2).Named("S");
2018-10-18 20:02:53 - let R = new Range(2).Named("R");
2018-10-18 20:02:53 - let W = new Range(2).Named("W");
2018-10-18 20:02:55 - Unexpected symbol '.' in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-18 20:02:55 - Unexpected symbol '.' in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-18 20:02:55 - Unexpected symbol '.' in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-18 20:03:20 - let C = Range(2).Named("C")
2018-10-18 20:03:20 - let S = Range(2).Named("S")
2018-10-18 20:03:20 - let R = new Range(2).Named("R")
2018-10-18 20:03:20 - let W = new Range(2).Named("W")
2018-10-18 20:03:20 - Unexpected symbol '.' in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-18 20:03:20 - Unexpected symbol '.' in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-18 20:03:27 - let C = Range(2).Named("C")
2018-10-18 20:03:27 - let S = Range(2).Named("S")
2018-10-18 20:03:27 - let R = Range(2).Named("R")
2018-10-18 20:03:27 - let W = Range(2).Named("W")
2018-10-18 20:05:34 - let NumberOfExamples = Variable.New<int>().Named("NofE");
2018-10-18 20:05:34 - let N = Range(NumberOfExamples).Named("N");
2018-10-18 20:05:52 - Although all the variables in this example have just 2 states (true/false),
2018-10-18 20:05:52 - the example is formulated in a way that shows how to extend to multiple states
2018-10-18 20:05:53 - Unexpected keyword 'in' in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2018-10-18 20:05:53 - parse error
2018-10-18 20:06:29 - let ProbCloudyPrior = Variable.New<Dirichlet>().Named("ProbCloudyPrior")
2018-10-18 20:06:29 - let ProbCloudy = Variable<Vector>.Random(ProbCloudyPrior).Named("ProbCloudy")
2018-10-18 20:06:29 - ProbCloudy.SetValueRange(C)
2018-10-18 20:06:32 - A unique overload for method 'Random' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Random<'T,'TDist when 'TDist :> IDistribution<'T>>(dist: Variable<'TDist>) : Variable<'T>, Variable.Random<'TDist when 'TDist :> IDistribution<Vector>>(dist: Variable<'TDist>) : Variable<Vector>
2018-10-18 20:06:32 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-18 20:06:48 - let ProbCloudyPrior = Variable.New<Dirichlet>().Named("ProbCloudyPrior")
2018-10-18 20:06:59 - let ProbCloudy = Variable<Vector>.Random(ProbCloudyPrior).Named("ProbCloudy")
2018-10-18 20:07:01 - A unique overload for method 'Random' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Random<'T,'TDist when 'TDist :> IDistribution<'T>>(dist: Variable<'TDist>) : Variable<'T>, Variable.Random<'TDist when 'TDist :> IDistribution<Vector>>(dist: Variable<'TDist>) : Variable<Vector>
2018-10-18 20:07:30 - let ProbCloudy:Variable<Vector> = Variable<Vector>.Random(ProbCloudyPrior).Named("ProbCloudy")
2018-10-18 20:07:31 - A unique overload for method 'Random' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Random<'T,'TDist when 'TDist :> IDistribution<'T>>(dist: Variable<'TDist>) : Variable<'T>, Variable.Random<'TDist when 'TDist :> IDistribution<Vector>>(dist: Variable<'TDist>) : Variable<Vector>
2018-10-18 20:08:05 - let ProbCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("ProbCloudyPrior")
2018-10-18 20:08:12 - let ProbCloudy:Variable<Vector> = Variable<Vector>.Random(ProbCloudyPrior).Named("ProbCloudy")
2018-10-18 20:08:13 - A unique overload for method 'Random' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Random<'T,'TDist when 'TDist :> IDistribution<'T>>(dist: Variable<'TDist>) : Variable<'T>, Variable.Random<'TDist when 'TDist :> IDistribution<Vector>>(dist: Variable<'TDist>) : Variable<Vector>
2018-10-18 20:10:00 - ProbCloudy.SetValueRange(C)
2018-10-18 20:10:02 - The value, namespace, type or module 'ProbCloudy' is not defined. Maybe you want one of the following:
2018-10-18 20:10:02 -    ProbCloudyPrior
2018-10-18 20:10:38 - let CPTSprinklerPrior = Variable.Array<Dirichlet>(C).Named("CPTSprinklerPrior")
2018-10-18 20:10:38 - let CPTSprinkler = Variable.Array<Vector>(C).Named("CPTSprinkler")
2018-10-18 20:10:53 - let CPTSprinkler[C] = Variable<Vector>.Random(CPTSprinklerPrior[C])
2018-10-18 20:10:53 - CPTSprinkler.SetValueRange(S)
2018-10-18 20:10:54 - This value is not a function and cannot be applied.
2018-10-18 20:10:54 - A unique overload for method 'Random' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Random<'T,'TDist when 'TDist :> IDistribution<'T>>(dist: Variable<'TDist>) : Variable<'T>, Variable.Random<'T>(dist: IDistribution<'T>) : Variable<'T>, Variable.Random<'TDist when 'TDist :> IDistribution<Vector>>(dist: Variable<'TDist>) : Variable<Vector>
2018-10-18 20:10:54 - Incomplete pattern matches on this expression. For example, the value '[_;_]' may indicate a case not covered by the pattern(s).
2018-10-18 20:10:54 - The field, constructor or member 'SetValueRange' is not defined.
2018-10-18 20:12:38 - CPTSprinkler.[C] <- Variable<Vector>.Random(CPTSprinklerPrior.[C])
2018-10-18 20:12:38 - CPTSprinkler.SetValueRange(S)
2018-10-18 20:12:39 - A unique overload for method 'Random' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Random<'T,'TDist when 'TDist :> IDistribution<'T>>(dist: Variable<'TDist>) : Variable<'T>, Variable.Random<'TDist when 'TDist :> IDistribution<Vector>>(dist: Variable<'TDist>) : Variable<Vector>
2018-10-18 20:13:05 - let ProbCloudyPrior = Variable.New<Dirichlet>().Named("ProbCloudyPrior")
2018-10-18 20:13:52 - [C;S;R;W]
2018-10-18 20:13:59 - let C = Range(2).Named("C")
2018-10-18 20:13:59 - let S = Range(2).Named("S")
2018-10-18 20:13:59 - let R = Range(2).Named("R")
2018-10-18 20:13:59 - let W = Range(2).Named("W")
2018-10-18 20:14:00 - [C;S;R;W]
2018-10-18 20:20:45 - let ProbCloudy = Variable<Vector>.Random<float>(ProbCloudyPrior).Named("ProbCloudy")
2018-10-18 20:20:46 - No overloads match for method 'Random'. The available overloads are shown below.
2018-10-18 20:20:46 - Possible overload: 'Variable.Random<'TDist when 'TDist :> IDistribution<Vector>>(dist: Variable<'TDist>) : Variable<Vector>'. The type 'float' is not compatible with the type 'IDistribution<Vector>'.
2018-10-18 20:20:46 - Possible overload: 'Variable.Random<'T>(dist: IDistribution<'T>) : Variable<'T>'. Type constraint mismatch. The type 
2018-10-18 20:20:46 -     'Variable<Dirichlet>'    
2018-10-18 20:20:46 - is not compatible with type
2018-10-18 20:20:46 -     'IDistribution<'a>'    
2018-10-18 20:20:46 - .
2018-10-18 20:21:34 - let ProbCloudy = Variable<Vector>.Random<Dirichlet>(ProbCloudyPrior).Named("ProbCloudy")
2018-10-18 20:21:47 - ProbCloudy.SetValueRange(C)
2018-10-18 20:22:26 - let ProbCloudyPrior = Variable.New<Dirichlet>().Named("ProbCloudyPrior")
2018-10-18 20:22:26 - let ProbCloudy = Variable<Vector>.Random<Dirichlet>(ProbCloudyPrior).Named("ProbCloudy")
2018-10-18 20:22:26 - ProbCloudy.SetValueRange(C)
2018-10-18 20:22:37 - let CPTSprinklerPrior = Variable.Array<Dirichlet>(C).Named("CPTSprinklerPrior")
2018-10-18 20:22:37 - let CPTSprinkler = Variable.Array<Vector>(C).Named("CPTSprinkler")
2018-10-18 20:23:07 - [CPTSprinklerPrior;CPTSprinkler]
2018-10-18 20:23:08 - All elements of a list constructor expression must have the same type. This expression was expected to have type 'Dirichlet', but here has type 'Vector'.
2018-10-18 20:23:31 - CPTSprinklerPrior,CPTSprinkler
2018-10-18 20:24:06 - CPTSprinklerPrior.GetType()
2018-10-18 20:24:10 - CPTSprinkler.GetType()
2018-10-18 20:25:00 - CPTSprinkler.[C] <- Variable<Vector>.Random(CPTSprinklerPrior.[C])
2018-10-18 20:25:00 - CPTSprinkler.SetValueRange(S)
2018-10-18 20:25:01 - A unique overload for method 'Random' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Random<'T,'TDist when 'TDist :> IDistribution<'T>>(dist: Variable<'TDist>) : Variable<'T>, Variable.Random<'TDist when 'TDist :> IDistribution<Vector>>(dist: Variable<'TDist>) : Variable<Vector>
2018-10-18 20:31:10 - CPTSprinklerPrior.[C]
2018-10-18 20:35:27 - let CPTWetGrassPrior = Variable.Array(Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-18 20:35:27 - let CPTWetGrass = Variable.Array(Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-18 20:35:28 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(array: VariableArray<'T>, r: Range) : VariableArray<VariableArray<'T>,'T [] []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(array: VariableArray<'TItem,'TArray>, r: Range) : VariableArray<VariableArray<'TItem,'TArray>,'TArray []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(itemPrototype: 'TItem, r: Range) : VariableArray<'TItem,'TArray>
2018-10-18 20:35:28 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(array: VariableArray<'T>, r: Range) : VariableArray<VariableArray<'T>,'T [] []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(array: VariableArray<'TItem,'TArray>, r: Range) : VariableArray<VariableArray<'TItem,'TArray>,'TArray []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(itemPrototype: 'TItem, r: Range) : VariableArray<'TItem,'TArray>
2018-10-18 20:36:34 - let CPTRainPrior = Variable.Array<Dirichlet>(C).Named("CPTRainPrior")
2018-10-18 20:36:34 - let CPTRain = Variable.Array<Vector>(C).Named("CPTRain")
2018-10-18 20:37:29 - let CPTRain.[C] = Variable<Vector>.Random<Dirichlet>(CPTRainPrior.[C])  // ????
2018-10-18 20:37:30 - Unexpected symbol '[' in binding. Expected identifier, '(', '(*)' or other token.
2018-10-18 20:37:30 - A unique overload for method 'Item' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: VariableArray.get_Item(index: Variable<int>) : Variable<Dirichlet>, VariableArray.get_Item(index: int) : Variable<Dirichlet>, VariableArray.get_Item(range: Range) : Variable<Dirichlet>
2018-10-18 20:37:30 - A unique overload for method 'Random' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Random<'T>(dist: IDistribution<'T>) : Variable<'T>, Variable.Random<'TDist when 'TDist :> IDistribution<Vector>>(dist: Variable<'TDist>) : Variable<Vector>
2018-10-18 20:37:30 - Incomplete pattern matches on this expression. For example, the value '[_;_]' may indicate a case not covered by the pattern(s).
2018-10-18 20:37:44 - let CPTRain_C = Variable<Vector>.Random<Dirichlet>(CPTRainPrior.[C])  // ????
2018-10-18 20:38:33 - let CPTRainPrior = Variable.Array<Dirichlet>(C).Named("CPTRainPrior")
2018-10-18 20:38:33 - let CPTRain = ref(Variable.Array<Vector>(C).Named("CPTRain"))
2018-10-18 20:38:54 - let CPTRain.[C] := Variable<Vector>.Random<Dirichlet>(CPTRainPrior.[C])  // ????
2018-10-18 20:38:55 - Unexpected symbol '[' in binding. Expected identifier, '(', '(*)' or other token.
2018-10-18 20:38:55 - Unexpected symbol ':=' in binding. Expected '=' or other token.
2018-10-18 20:39:12 - CPTRain.[C] <- Variable<Vector>.Random<Dirichlet>(CPTRainPrior.[C])  // ????
2018-10-18 20:39:12 - The field, constructor or member 'Item' is not defined.
2018-10-18 20:39:54 - let CPTRain.[C] = Variable<Vector>.Random<Dirichlet>(CPTRainPrior.[C])  // ????
2018-10-18 20:39:55 - Unexpected symbol '[' in binding. Expected identifier, '(', '(*)' or other token.
2018-10-18 20:39:55 - A unique overload for method 'Item' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: VariableArray.get_Item(index: Variable<int>) : Variable<Dirichlet>, VariableArray.get_Item(index: int) : Variable<Dirichlet>, VariableArray.get_Item(range: Range) : Variable<Dirichlet>
2018-10-18 20:39:55 - A unique overload for method 'Random' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Random<'T>(dist: IDistribution<'T>) : Variable<'T>, Variable.Random<'TDist when 'TDist :> IDistribution<Vector>>(dist: Variable<'TDist>) : Variable<Vector>
2018-10-18 20:39:55 - Incomplete pattern matches on this expression. For example, the value '[_;_]' may indicate a case not covered by the pattern(s).
2018-10-18 20:40:02 - let CPTRain_C = Variable<Vector>.Random<Dirichlet>(CPTRainPrior.[C])  // ????
2018-10-18 21:14:17 - let ProbCloudyPrior = Variable.New<Dirichlet>().Named("ProbCloudyPrior")
2018-10-18 21:14:17 - let ProbCloudy = Variable<Vector>.Random<Dirichlet>(ProbCloudyPrior).Named("ProbCloudy")
2018-10-18 21:14:17 - ProbCloudy.SetValueRange(C)
2018-10-18 21:14:56 - CPTSprinklerPrior.[C]
2018-10-18 21:28:19 - CPTRainPrior.GetType ()
2018-10-18 21:31:09 - ProbCloudyPrior.GetType ()
2018-10-18 21:31:37 - ProbCloudy.GetType ()
2018-10-18 21:32:52 - CPTSprinklerPrior.GetType ()
2018-10-18 21:33:06 - CPTSprinkler.GetType ()
2018-10-19 17:59:42 - Reporting 0 opened comms
2018-10-19 18:00:14 - #load "Paket.fsx"
2018-10-19 18:00:42 - Paket.Package
2018-10-19 18:00:42 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-19 18:00:42 -       "Microsoft.ML.Probabilistic"
2018-10-19 18:00:42 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-19 18:00:42 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-19 18:00:42 -       "NETStandard.Library"
2018-10-19 18:00:42 -   ]
2018-10-19 18:01:46 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-19 18:01:52 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-19 18:02:37 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-19 18:02:37 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-19 18:02:37 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-19 18:02:37 - #r "Microsoft.ML.Probabilistic"
2018-10-19 18:02:37 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-19 18:02:37 - #r "netstandard"
2018-10-19 18:02:38 - open Microsoft.ML.Probabilistic  
2018-10-19 18:02:38 - open Microsoft.ML.Probabilistic.Models  
2018-10-19 18:02:38 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-19 18:02:38 - open Microsoft.ML.Probabilistic.Factors  
2018-10-19 18:02:38 - open Microsoft.ML.Probabilistic.Math
2018-10-19 18:02:39 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-19 18:02:44 - open Microsoft.ML.Probabilistic.FSharp
2018-10-19 18:02:55 - let Cloudy = VariableArray<int>().Named("Cloudy")
2018-10-19 18:02:56 - This type has no accessible object constructors
2018-10-19 18:05:54 - let engine =  InferenceEngine ()
2018-10-19 18:06:11 - let NumberOfExamples = Variable.New<int>().Named("NofE")
2018-10-19 18:06:11 - let N = Range(NumberOfExamples).Named("N")
2018-10-19 18:06:12 - let C = Range(2).Named("C")
2018-10-19 18:06:12 - let S = Range(2).Named("S")
2018-10-19 18:06:12 - let R = Range(2).Named("R")
2018-10-19 18:06:12 - let W = Range(2).Named("W")
2018-10-19 18:23:10 - [C;S;R;W]
2018-10-19 18:23:15 - let ProbCloudyPrior = Variable.New<Dirichlet>().Named("ProbCloudyPrior")
2018-10-19 18:23:15 - let ProbCloudy = Variable<Vector>.Random<Dirichlet>(ProbCloudyPrior).Named("ProbCloudy")
2018-10-19 18:23:15 - ProbCloudy.SetValueRange(C)
2018-10-19 18:23:25 - ProbCloudy.GetType ()
2018-10-19 18:40:18 - // C#:  CPTSprinkler[C] = Variable<Vector>.Random(CPTSprinklerPrior[C]) //????
2018-10-19 18:40:18 - CPTSprinkler.[C] <- Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior.[C])
2018-10-19 18:40:19 - Expression evaluation failed: VariableArray<Dirichlet> CPTSprinklerPrior cannot be indexed by C. Perhaps you omitted C as an argument to the constructor?
2018-10-19 18:40:19 - Parameter name: index
2018-10-19 18:40:19 - ArgumentExceptionVariableArray<Dirichlet> CPTSprinklerPrior cannot be indexed by C. Perhaps you omitted C as an argument to the constructor?
2018-10-19 18:40:19 - Parameter name: index
2018-10-19 18:40:19 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 18:40:19 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 18:40:19 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 18:40:19 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 18:40:19 -   at <StartupCode$FSI_0097>.$FSI_0097.main@ () [0x00014] in <f974be6cbf924aeca7488007b9b7c8b9>:0 
2018-10-19 18:40:19 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-19 18:40:19 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-19 19:10:09 - // C#:  CPTSprinkler[C] = Variable<Vector>.Random(CPTSprinklerPrior[C]) //????
2018-10-19 19:10:09 - CPTSprinkler.SetTo(Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior.[C]))
2018-10-19 19:10:10 - No overloads match for method 'SetTo'. The available overloads are shown below.
2018-10-19 19:10:10 - Possible overload: 'VariableArray.SetTo(that: VariableArray<Vector>) : unit'. Type constraint mismatch. The type 
2018-10-19 19:10:10 -     'Variable<Vector>'    
2018-10-19 19:10:10 - is not compatible with type
2018-10-19 19:10:10 -     'VariableArray<Vector>'    
2018-10-19 19:10:10 - .
2018-10-19 19:10:10 - Possible overload: 'VariableArray.SetTo(that: VariableArray<Variable<Vector>,Vector []>) : unit'. Type constraint mismatch. The type 
2018-10-19 19:10:10 -     'Variable<Vector>'    
2018-10-19 19:10:10 - is not compatible with type
2018-10-19 19:10:10 -     'VariableArray<Variable<Vector>,Vector []>'    
2018-10-19 19:10:10 - .
2018-10-19 19:10:10 - Possible overload: 'VariableArrayBase.SetTo(that: VariableArrayBase<Variable<Vector>,Vector []>) : unit'. Type constraint mismatch. The type 
2018-10-19 19:10:10 -     'Variable<Vector>'    
2018-10-19 19:10:10 - is not compatible with type
2018-10-19 19:10:10 -     'VariableArrayBase<Variable<Vector>,Vector []>'    
2018-10-19 19:10:10 - .
2018-10-19 19:10:10 - Possible overload: 'Variable.SetTo(variable: Variable<Vector []>) : unit'. Type constraint mismatch. The type 
2018-10-19 19:10:10 -     'Variable<Vector>'    
2018-10-19 19:10:10 - is not compatible with type
2018-10-19 19:10:10 -     'Variable<Vector []>'    
2018-10-19 19:10:10 - .
2018-10-19 19:14:15 - // C#:  CPTSprinkler[C] = Variable<Vector>.Random(CPTSprinklerPrior[C]) //????
2018-10-19 19:14:15 - let CPTSprinkler_C = Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior.[C])
2018-10-19 19:14:15 - Expression evaluation failed: VariableArray<Dirichlet> CPTSprinklerPrior cannot be indexed by C. Perhaps you omitted C as an argument to the constructor?
2018-10-19 19:14:15 - Parameter name: index
2018-10-19 19:14:15 - ArgumentExceptionVariableArray<Dirichlet> CPTSprinklerPrior cannot be indexed by C. Perhaps you omitted C as an argument to the constructor?
2018-10-19 19:14:15 - Parameter name: index
2018-10-19 19:14:15 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 19:14:15 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 19:14:15 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 19:14:15 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 19:14:15 -   at <StartupCode$FSI_0099>.$FSI_0099.main@ () [0x0000a] in <f974be6cbf924aeca7488007b9b7c8b9>:0 
2018-10-19 19:14:15 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-19 19:14:15 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-19 19:14:36 - [C;S;R;W]
2018-10-19 19:14:45 - // C#:  CPTSprinkler[C] = Variable<Vector>.Random(CPTSprinklerPrior[C]) //????
2018-10-19 19:14:45 - let CPTSprinkler_C = Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior[C])
2018-10-19 19:14:45 - This value is not a function and cannot be applied.
2018-10-19 19:14:45 - A unique overload for method 'Random' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Random<'T>(dist: IDistribution<'T>) : Variable<'T>, Variable.Random<'TDist when 'TDist :> IDistribution<Vector>>(dist: Variable<'TDist>) : Variable<Vector>
2018-10-19 19:15:03 - // C#:  CPTSprinkler[C] = Variable<Vector>.Random(CPTSprinklerPrior[C]) //????
2018-10-19 19:15:03 - let CPTSprinkler_C = Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior.[C])
2018-10-19 19:15:03 - Expression evaluation failed: VariableArray<Dirichlet> CPTSprinklerPrior cannot be indexed by C. Perhaps you omitted C as an argument to the constructor?
2018-10-19 19:15:03 - Parameter name: index
2018-10-19 19:15:03 - ArgumentExceptionVariableArray<Dirichlet> CPTSprinklerPrior cannot be indexed by C. Perhaps you omitted C as an argument to the constructor?
2018-10-19 19:15:03 - Parameter name: index
2018-10-19 19:15:03 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 19:15:03 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 19:15:03 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 19:15:03 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 19:15:03 -   at <StartupCode$FSI_0103>.$FSI_0103.main@ () [0x0000a] in <f974be6cbf924aeca7488007b9b7c8b9>:0 
2018-10-19 19:15:03 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-19 19:15:03 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-19 19:15:27 - let CPTSprinklerPrior = Variable.Array<Dirichlet>(C).Named("CPTSprinklerPrior")
2018-10-19 19:15:27 - let CPTSprinkler = Variable.Array<Vector>(C).Named("CPTSprinkler")
2018-10-19 19:16:11 - // C#:  CPTSprinkler[C] = Variable<Vector>.Random(CPTSprinklerPrior[C]) //????
2018-10-19 19:16:11 - let CPTSprinkler_C = Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior.[C])
2018-10-19 19:16:38 - CPTSprinkler_C.GetType()
2018-10-19 19:17:14 - // C#:  CPTSprinkler[C] = Variable<Vector>.Random(CPTSprinklerPrior[C]) //????
2018-10-19 19:17:14 - let CPTSprinklerPrior_C = Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior.[C])
2018-10-19 19:20:05 - CPTSprinkler.SetTo(CPTSprinklerPrior_C)
2018-10-19 19:20:06 - No overloads match for method 'SetTo'. The available overloads are shown below.
2018-10-19 19:20:06 - Possible overload: 'VariableArray.SetTo(that: VariableArray<Vector>) : unit'. Type constraint mismatch. The type 
2018-10-19 19:20:06 -     'Variable<Vector>'    
2018-10-19 19:20:06 - is not compatible with type
2018-10-19 19:20:06 -     'VariableArray<Vector>'    
2018-10-19 19:20:06 - .
2018-10-19 19:20:06 - Possible overload: 'VariableArray.SetTo(that: VariableArray<Variable<Vector>,Vector []>) : unit'. Type constraint mismatch. The type 
2018-10-19 19:20:06 -     'Variable<Vector>'    
2018-10-19 19:20:06 - is not compatible with type
2018-10-19 19:20:06 -     'VariableArray<Variable<Vector>,Vector []>'    
2018-10-19 19:20:06 - .
2018-10-19 19:20:06 - Possible overload: 'VariableArrayBase.SetTo(that: VariableArrayBase<Variable<Vector>,Vector []>) : unit'. Type constraint mismatch. The type 
2018-10-19 19:20:06 -     'Variable<Vector>'    
2018-10-19 19:20:06 - is not compatible with type
2018-10-19 19:20:06 -     'VariableArrayBase<Variable<Vector>,Vector []>'    
2018-10-19 19:20:06 - .
2018-10-19 19:20:06 - Possible overload: 'Variable.SetTo(variable: Variable<Vector []>) : unit'. Type constraint mismatch. The type 
2018-10-19 19:20:06 -     'Variable<Vector>'    
2018-10-19 19:20:06 - is not compatible with type
2018-10-19 19:20:06 -     'Variable<Vector []>'    
2018-10-19 19:20:06 - .
2018-10-19 19:22:52 - CPTSprinkler.SetTo(CPTSprinklerPrior_C.ForEach(C))
2018-10-19 19:22:52 - No overloads match for method 'SetTo'. The available overloads are shown below.
2018-10-19 19:22:52 - Possible overload: 'VariableArray.SetTo(that: VariableArray<Vector>) : unit'. Type constraint mismatch. The type 
2018-10-19 19:22:52 -     'Variable<Vector>'    
2018-10-19 19:22:52 - is not compatible with type
2018-10-19 19:22:52 -     'VariableArray<Vector>'    
2018-10-19 19:22:52 - .
2018-10-19 19:22:52 - Possible overload: 'VariableArray.SetTo(that: VariableArray<Variable<Vector>,Vector []>) : unit'. Type constraint mismatch. The type 
2018-10-19 19:22:52 -     'Variable<Vector>'    
2018-10-19 19:22:52 - is not compatible with type
2018-10-19 19:22:52 -     'VariableArray<Variable<Vector>,Vector []>'    
2018-10-19 19:22:52 - .
2018-10-19 19:22:52 - Possible overload: 'VariableArrayBase.SetTo(that: VariableArrayBase<Variable<Vector>,Vector []>) : unit'. Type constraint mismatch. The type 
2018-10-19 19:22:52 -     'Variable<Vector>'    
2018-10-19 19:22:52 - is not compatible with type
2018-10-19 19:22:52 -     'VariableArrayBase<Variable<Vector>,Vector []>'    
2018-10-19 19:22:52 - .
2018-10-19 19:22:52 - Possible overload: 'Variable.SetTo(variable: Variable<Vector []>) : unit'. Type constraint mismatch. The type 
2018-10-19 19:22:52 -     'Variable<Vector>'    
2018-10-19 19:22:52 - is not compatible with type
2018-10-19 19:22:52 -     'Variable<Vector []>'    
2018-10-19 19:22:52 - .
2018-10-19 19:23:47 - CPTSprinklerPrior_C.ForEach(C)
2018-10-19 19:23:47 - Expression evaluation failed: ForEach is not needed on range 'C' since the expression is already indexed by this range
2018-10-19 19:23:47 - ArgumentExceptionForEach is not needed on range 'C' since the expression is already indexed by this range
2018-10-19 19:23:47 -   at Microsoft.ML.Probabilistic.Models.Variable`1[T].ForEach (Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0004b] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 19:23:47 -   at Microsoft.ML.Probabilistic.Models.Variable`1[T].ForEach (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 19:23:47 -   at <StartupCode$FSI_0111>.$FSI_0111.main@ () [0x0000a] in <f974be6cbf924aeca7488007b9b7c8b9>:0 
2018-10-19 19:23:47 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-19 19:23:47 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-19 19:24:09 - CPTSprinklerPrior_C.[C]
2018-10-19 19:24:10 - The field, constructor or member 'Item' is not defined.
2018-10-19 19:24:56 - CPTSprinklerPrior_C.GetExpression()
2018-10-19 19:26:23 - CPTSprinkler.Definition()
2018-10-19 19:26:23 - This value is not a function and cannot be applied.
2018-10-19 19:26:40 - CPTSprinkler.Definition
2018-10-19 19:34:42 - CPTSprinkler.[C].SetTo(CPTSprinklerPrior_C)
2018-10-19 19:35:11 - CPTSprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior.[C]))
2018-10-19 19:35:11 - Expression evaluation failed: Cannot define a variable more than once
2018-10-19 19:35:11 - InvalidOperationExceptionCannot define a variable more than once
2018-10-19 19:35:11 -   at Microsoft.ML.Probabilistic.Models.Variable.SetDefinition (Microsoft.ML.Probabilistic.Models.MethodInvoke methodInvoke) [0x00022] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 19:35:11 -   at Microsoft.ML.Probabilistic.Models.Variable`1[T].SetTo (Microsoft.ML.Probabilistic.Models.MethodInvoke methodInvoke) [0x00019] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 19:35:11 -   at Microsoft.ML.Probabilistic.Models.Variable`1[T].SetTo (Microsoft.ML.Probabilistic.Models.Variable`1[T] variable) [0x00055] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 19:35:11 -   at <StartupCode$FSI_0120>.$FSI_0120.main@ () [0x00023] in <f974be6cbf924aeca7488007b9b7c8b9>:0 
2018-10-19 19:35:11 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-19 19:35:11 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-19 19:35:19 - let CPTSprinklerPrior = Variable.Array<Dirichlet>(C).Named("CPTSprinklerPrior")
2018-10-19 19:35:19 - let CPTSprinkler = Variable.Array<Vector>(C).Named("CPTSprinkler")
2018-10-19 19:35:27 - CPTSprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior.[C]))
2018-10-19 19:36:57 - let CPTRainPrior = Variable.Array<Dirichlet>(C).Named("CPTRainPrior")
2018-10-19 19:36:57 - let CPTRain = ref(Variable.Array<Vector>(C).Named("CPTRain"))
2018-10-19 19:37:04 - CPTRain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTRainPrior.[C]))
2018-10-19 19:37:04 - The field, constructor or member 'Item' is not defined.
2018-10-19 19:37:54 - let CPTRainPrior = Variable.Array<Dirichlet>(C).Named("CPTRainPrior")
2018-10-19 19:37:54 - let CPTRain = Variable.Array<Vector>(C).Named("CPTRain")
2018-10-19 19:37:55 - CPTRain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTRainPrior.[C]))
2018-10-19 19:39:37 - let CPTWetGrassPrior:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> = Variable.Array(Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-19 19:39:37 - let CPTWetGrass:VariableArray<VariableArray<Vector>, Vector[][]> = Variable.Array(Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-19 19:39:37 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(array: VariableArray<'T>, r: Range) : VariableArray<VariableArray<'T>,'T [] []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(array: VariableArray<'TItem,'TArray>, r: Range) : VariableArray<VariableArray<'TItem,'TArray>,'TArray []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(itemPrototype: 'TItem, r: Range) : VariableArray<'TItem,'TArray>
2018-10-19 19:39:37 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(array: VariableArray<'T>, r: Range) : VariableArray<VariableArray<'T>,'T [] []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(array: VariableArray<'TItem,'TArray>, r: Range) : VariableArray<VariableArray<'TItem,'TArray>,'TArray []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(itemPrototype: 'TItem, r: Range) : VariableArray<'TItem,'TArray>
2018-10-19 19:41:38 - let CPTWetGrassPrior:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> = Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-19 19:41:38 - let CPTWetGrass:VariableArray<VariableArray<Vector>, Vector[][]> = Variable.Array<VariableArray<Vector>, Vector[][]>(Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-19 19:42:59 - CPTWetGrass.[S][R].SetTo(Variable<Vector>.Random<Dirichlet>(CPTWetGrassPrior.[S][R]))
2018-10-19 19:42:59 - CPTWetGrass.SetValueRange(W);
2018-10-19 19:42:59 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-19 19:42:59 - This value is not a function and cannot be applied.
2018-10-19 19:43:36 - CPTWetGrass.[S].[R].SetTo(Variable<Vector>.Random<Dirichlet>(CPTWetGrassPrior.[S].[R]))
2018-10-19 19:43:36 - CPTWetGrass.SetValueRange(W)
2018-10-19 19:45:30 - let Cloudy = Variable.Array<int>(N).Named("Cloudy");
2018-10-19 19:45:30 - Cloudy.[N].SetTo(Variable.Discrete(ProbCloudy).ForEach(N))
2018-10-19 20:40:42 - //using the Foreach Block  
2018-10-19 20:40:42 - let pixel = new Range(10)  
2018-10-19 20:40:42 - let bools = Variable.Array<bool>(pixel)
2018-10-19 20:40:42 - Variable.ForeachBlock pixel ( fun pixel ->  
2018-10-19 20:40:42 -                 bools.[pixel] <- Variable.Bernoulli(0.7) ||| Variable.Bernoulli(0.4)())
2018-10-19 20:40:43 - This value is not a function and cannot be applied.
2018-10-19 20:42:11 - //using the Foreach Block  
2018-10-19 20:42:11 - let pixel = new Range(10)  
2018-10-19 20:42:11 - let bools = Variable.Array<bool>(pixel)
2018-10-19 20:42:11 - Variable.ForeachBlock pixel ( fun pixel -> bools.[pixel] <- Variable.Bernoulli(0.7) ||| Variable.Bernoulli(0.4)())
2018-10-19 20:42:11 - This value is not a function and cannot be applied.
2018-10-19 20:42:46 - //using the Foreach Block  
2018-10-19 20:42:46 - let pixel = new Range(10)  
2018-10-19 20:42:46 - let bools = Variable.Array<bool>(pixel);
2018-10-19 20:42:46 - Variable.ForeachBlock pixel ( fun pixel -> bools.[pixel] <- Variable.Bernoulli(0.7) ||| Variable.Bernoulli(0.4)())
2018-10-19 20:42:47 - This value is not a function and cannot be applied.
2018-10-19 20:43:07 - //using the Foreach Block  
2018-10-19 20:43:07 - let pixel = new Range(10)  
2018-10-19 20:43:07 - let bools = Variable.Array<bool>(pixel);
2018-10-19 20:43:07 - Variable.ForeachBlock pixel ( fun pixel -> bools.[pixel] <- Variable.Bernoulli(0.7) ||| Variable.Bernoulli(0.4))
2018-10-19 20:44:02 - //using the Switch Block  
2018-10-19 20:44:02 - let mixtureSize = 2  
2018-10-19 20:44:02 - let k2 = new Range(mixtureSize)  
2018-10-19 20:44:02 - let c = Variable.Discrete(k2, [|0.5;0.5|])  
2018-10-19 20:44:02 - let means2 = Variable.Observed( [|1.0;2.0|], k2)
2018-10-19 20:44:02 - let x = Variable.New<double>();  
2018-10-19 20:44:02 - Variable.SwitchBlock c (fun _ -> 
2018-10-19 20:44:02 -     let _ = x.SetTo(Variable.GaussianFromMeanAndVariance(means2.[c], 1.0))  
2018-10-19 20:44:02 -     ()  
2018-10-19 20:44:02 - )
2018-10-19 20:45:12 - //using the SwitchExpr Block  
2018-10-19 20:45:12 - let means = Variable.ArrayInit k (fun k ->  
2018-10-19 20:45:12 -                 Variable.VectorGaussianFromMeanAndPrecision(  
2018-10-19 20:45:12 -                     new Vector(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-10-19 20:45:12 - let precs = Variable.ArrayInit k (fun k ->  
2018-10-19 20:45:12 -                 Variable.WishartFromShapeAndScale(1.0,  
2018-10-19 20:45:12 -                     PositiveDefiniteMatrix.Identity(2)))  
2018-10-19 20:45:12 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-10-19 20:45:12 - let n = new Range(100)
2018-10-19 20:45:12 - let z = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-19 20:45:12 - let data = Variable.ArrayInit n (fun i ->  
2018-10-19 20:45:12 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-19 20:45:12 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-19 20:45:13 - The value or constructor 'k' is not defined. Maybe you want one of the following:
2018-10-19 20:45:13 -    k2
2018-10-19 20:45:13 -    Ok
2018-10-19 20:45:13 -    C
2018-10-19 20:45:13 -    N
2018-10-19 20:45:13 -    R
2018-10-19 20:45:13 - Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{ new ... with ... }' instead.
2018-10-19 20:45:13 - Method or object constructor 'Vector' not found
2018-10-19 20:45:13 - The value or constructor 'k' is not defined. Maybe you want one of the following:
2018-10-19 20:45:13 -    k2
2018-10-19 20:45:13 -    Ok
2018-10-19 20:45:13 -    C
2018-10-19 20:45:13 -    N
2018-10-19 20:45:13 -    R
2018-10-19 20:45:13 - The value or constructor 'k' is not defined. Maybe you want one of the following:
2018-10-19 20:45:13 -    k2
2018-10-19 20:45:13 -    Ok
2018-10-19 20:45:13 -    C
2018-10-19 20:45:13 -    N
2018-10-19 20:45:13 -    R
2018-10-19 20:46:55 - //using the SwitchExpr Block  
2018-10-19 20:46:55 - let k =  Range(2) 
2018-10-19 20:46:55 - let means = Variable.ArrayInit k (fun k ->  
2018-10-19 20:46:55 -                 Variable.VectorGaussianFromMeanAndPrecision(  
2018-10-19 20:46:55 -                     new Vector(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-10-19 20:46:55 - let precs = Variable.ArrayInit k (fun k ->  
2018-10-19 20:46:55 -                 Variable.WishartFromShapeAndScale(1.0,  
2018-10-19 20:46:55 -                     PositiveDefiniteMatrix.Identity(2)))  
2018-10-19 20:46:55 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-10-19 20:46:55 - let n = new Range(100)
2018-10-19 20:46:55 - let z = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-19 20:46:55 - let data = Variable.ArrayInit n (fun i ->  
2018-10-19 20:46:55 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-19 20:46:55 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-19 20:46:55 - Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{ new ... with ... }' instead.
2018-10-19 20:46:55 - Method or object constructor 'Vector' not found
2018-10-19 20:47:18 - //using the SwitchExpr Block  
2018-10-19 20:47:18 - let k =  new Range(2) 
2018-10-19 20:47:18 - let means = Variable.ArrayInit k (fun k ->  
2018-10-19 20:47:18 -                 Variable.VectorGaussianFromMeanAndPrecision(  
2018-10-19 20:47:18 -                     new Vector(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-10-19 20:47:18 - let precs = Variable.ArrayInit k (fun k ->  
2018-10-19 20:47:18 -                 Variable.WishartFromShapeAndScale(1.0,  
2018-10-19 20:47:18 -                     PositiveDefiniteMatrix.Identity(2)))  
2018-10-19 20:47:18 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-10-19 20:47:18 - let n = new Range(100)
2018-10-19 20:47:18 - let z = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-19 20:47:18 - let data = Variable.ArrayInit n (fun i ->  
2018-10-19 20:47:18 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-19 20:47:18 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-19 20:47:19 - Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{ new ... with ... }' instead.
2018-10-19 20:47:19 - Method or object constructor 'Vector' not found
2018-10-19 20:48:18 - //using the SwitchExpr Block  
2018-10-19 20:48:18 - let k =  new Range(2) 
2018-10-19 20:48:18 - let means = Variable.ArrayInit k (fun k ->  
2018-10-19 20:48:18 -                 Variable.VectorGaussianFromMeanAndPrecision(new Vector(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-10-19 20:48:19 - Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{ new ... with ... }' instead.
2018-10-19 20:48:19 - Method or object constructor 'Vector' not found
2018-10-19 20:48:19 - let precs = Variable.ArrayInit k (fun k ->  
2018-10-19 20:48:19 -                 Variable.WishartFromShapeAndScale(1.0,  
2018-10-19 20:48:19 -                     PositiveDefiniteMatrix.Identity(2)))  
2018-10-19 20:48:19 - The value or constructor 'k' is not defined. Maybe you want one of the following:
2018-10-19 20:48:19 -    k2
2018-10-19 20:48:19 -    Ok
2018-10-19 20:48:19 -    C
2018-10-19 20:48:19 -    N
2018-10-19 20:48:19 -    R
2018-10-19 20:48:20 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-10-19 20:48:20 - let n = new Range(100)
2018-10-19 20:48:20 - let z = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-19 20:48:20 - let data = Variable.ArrayInit n (fun i ->  
2018-10-19 20:48:20 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-19 20:48:20 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-19 20:48:20 - The value or constructor 'k' is not defined. Maybe you want one of the following:
2018-10-19 20:48:20 -    k2
2018-10-19 20:48:20 -    Ok
2018-10-19 20:48:20 -    C
2018-10-19 20:48:20 -    N
2018-10-19 20:48:20 -    R
2018-10-19 20:48:20 - The value or constructor 'means' is not defined. Maybe you want one of the following:
2018-10-19 20:48:20 -    means2
2018-10-19 20:48:20 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-19 20:48:20 - The value or constructor 'precs' is not defined. Maybe you want one of the following:
2018-10-19 20:48:20 -    Res
2018-10-19 20:48:20 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-19 20:48:20 - A unique overload for method 'VectorGaussianFromMeanAndPrecision' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.VectorGaussianFromMeanAndPrecision(mean: Variable<Vector>, precision: Variable<PositiveDefiniteMatrix>) : Variable<Vector>, Variable.VectorGaussianFromMeanAndPrecision(mean: Vector, precision: PositiveDefiniteMatrix) : Variable<Vector>
2018-10-19 20:53:41 - //using the SwitchExpr Block  
2018-10-19 20:53:41 - let k =  new Range(2) 
2018-10-19 20:53:41 - let means = Variable.ArrayInit k (fun k ->  
2018-10-19 20:53:41 -                 Variable.VectorGaussianFromMeanAndPrecision( Vector.Constant(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-10-19 20:54:07 - let precs = Variable.ArrayInit k (fun k ->  
2018-10-19 20:54:07 -                 Variable.WishartFromShapeAndScale(1.0,  
2018-10-19 20:54:07 -                     PositiveDefiniteMatrix.Identity(2)))  
2018-10-19 20:54:15 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-10-19 20:54:15 - let n = new Range(100)
2018-10-19 20:54:15 - let z = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-19 20:54:15 - let data = Variable.ArrayInit n (fun i ->  
2018-10-19 20:54:15 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-19 20:54:15 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-19 20:54:25 - data
2018-10-19 20:55:47 - // Data from a clinical trial  
2018-10-19 20:55:47 - let controlGroup = Variable.Observed<bool>([|false; false; true; false; false|])  
2018-10-19 20:55:47 - let treatedGroup = Variable.Observed<bool>([|true; false; true; true; true |])  
2018-10-19 20:55:47 - let i = controlGroup.Range  
2018-10-19 20:55:47 - let j = treatedGroup.Range  
2018-10-19 20:55:47 - // Prior on being an effective treatment  
2018-10-19 20:55:47 - let isEffective = Variable.Bernoulli(0.5).Named("isEffective");  
2018-10-19 20:55:47 - let probIfTreated = ref (Variable.New<float>())  
2018-10-19 20:55:47 - let probIfControl = ref (Variable.New<float>())
2018-10-19 20:55:47 - // If Block function  
2018-10-19 20:55:47 - let f1 (vb1: Variable<bool>) =  
2018-10-19 20:55:47 -     probIfControl := Variable.Beta(1.0, 1.0).Named("probIfControl")  
2018-10-19 20:55:47 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->
2018-10-19 20:55:47 -         Variable.Bernoulli(!probIfControl)) 
2018-10-19 20:55:47 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->
2018-10-19 20:55:47 -         Variable.Bernoulli(!probIfTreated))  
2018-10-19 20:55:47 -         ()  
2018-10-19 20:55:47 - // IfNot Block function  
2018-10-19 20:55:47 - let f2 (vb2: Variable<bool>) =  
2018-10-19 20:55:47 -     let probAll = Variable.Beta(1.0, 1.0).Named("probAll")  
2018-10-19 20:55:47 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->Variable.Bernoulli(probAll))  
2018-10-19 20:55:47 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->Variable.Bernoulli(probAll))  
2018-10-19 20:55:47 -     ()  
2018-10-19 20:55:47 - // Call IfBlock  
2018-10-19 20:55:47 - let _ = Variable.IfBlock isEffective f1 f2
2018-10-19 20:55:48 - Unexpected symbol '(' in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-19 20:55:48 - Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.
2018-10-19 20:55:48 - Incomplete structured construct at or before this point in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-19 20:56:07 - // Data from a clinical trial  
2018-10-19 20:56:07 - let controlGroup = Variable.Observed<bool>([|false; false; true; false; false|])  
2018-10-19 20:56:07 - let treatedGroup = Variable.Observed<bool>([|true; false; true; true; true |])  
2018-10-19 20:56:07 - let i = controlGroup.Range  
2018-10-19 20:56:07 - let j = treatedGroup.Range  
2018-10-19 20:56:07 - // Prior on being an effective treatment  
2018-10-19 20:56:07 - let isEffective = Variable.Bernoulli(0.5).Named("isEffective");  
2018-10-19 20:56:07 - let probIfTreated = ref (Variable.New<float>())  
2018-10-19 20:56:07 - let probIfControl = ref (Variable.New<float>())
2018-10-19 20:56:08 - // If Block function  
2018-10-19 20:56:08 - let f1 (vb1: Variable<bool>) =  
2018-10-19 20:56:08 -     probIfControl := Variable.Beta(1.0, 1.0).Named("probIfControl")  
2018-10-19 20:56:08 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->
2018-10-19 20:56:08 -         Variable.Bernoulli(!probIfControl)) 
2018-10-19 20:56:08 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->
2018-10-19 20:56:08 -         Variable.Bernoulli(!probIfTreated))  
2018-10-19 20:56:08 -         ()  
2018-10-19 20:56:08 - // IfNot Block function  
2018-10-19 20:56:08 - let f2 (vb2: Variable<bool>) =  
2018-10-19 20:56:08 -     let probAll = Variable.Beta(1.0, 1.0).Named("probAll")  
2018-10-19 20:56:08 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->Variable.Bernoulli(probAll))  
2018-10-19 20:56:08 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->Variable.Bernoulli(probAll))  
2018-10-19 20:56:08 -     ()  
2018-10-19 20:56:08 - Unexpected symbol '(' in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-19 20:56:08 - Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.
2018-10-19 20:56:08 - Incomplete structured construct at or before this point in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-19 20:56:08 - // Call IfBlock  
2018-10-19 20:56:08 - let _ = Variable.IfBlock isEffective f1 f2
2018-10-19 20:56:09 - The value or constructor 'f1' is not defined.
2018-10-19 20:56:09 - The value or constructor 'f2' is not defined. Maybe you want one of the following:
2018-10-19 20:56:09 -    k2
2018-10-19 20:56:24 - // If Block function  
2018-10-19 20:56:24 - let f1 (vb1: Variable<bool>) =  
2018-10-19 20:56:24 -     probIfControl := Variable.Beta(1.0, 1.0).Named("probIfControl")  
2018-10-19 20:56:24 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->
2018-10-19 20:56:24 -         Variable.Bernoulli(!probIfControl)) 
2018-10-19 20:56:24 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->
2018-10-19 20:56:24 -         Variable.Bernoulli(!probIfTreated))  
2018-10-19 20:56:24 -         ()  
2018-10-19 20:56:25 - Unexpected symbol '(' in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-19 20:56:25 - Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.
2018-10-19 20:56:25 - Incomplete structured construct at or before this point in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-19 20:56:25 - // IfNot Block function  
2018-10-19 20:56:25 - let f2 (vb2: Variable<bool>) =  
2018-10-19 20:56:25 -     let probAll = Variable.Beta(1.0, 1.0).Named("probAll")  
2018-10-19 20:56:25 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->Variable.Bernoulli(probAll))  
2018-10-19 20:56:25 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->Variable.Bernoulli(probAll))  
2018-10-19 20:56:25 -     ()  
2018-10-19 20:56:49 - // If Block function  
2018-10-19 20:56:49 - let f1 (vb1: Variable<bool>) =  
2018-10-19 20:56:49 -     probIfControl := Variable.Beta(1.0, 1.0).Named("probIfControl")  
2018-10-19 20:56:49 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->
2018-10-19 20:56:49 -         Variable.Bernoulli(!probIfControl)) 
2018-10-19 20:56:49 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->
2018-10-19 20:56:49 -         Variable.Bernoulli(!probIfTreated))  
2018-10-19 20:56:49 -     ()  
2018-10-19 20:56:50 - // IfNot Block function  
2018-10-19 20:56:50 - let f2 (vb2: Variable<bool>) =  
2018-10-19 20:56:50 -     let probAll = Variable.Beta(1.0, 1.0).Named("probAll")  
2018-10-19 20:56:50 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->Variable.Bernoulli(probAll))  
2018-10-19 20:56:50 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->Variable.Bernoulli(probAll))  
2018-10-19 20:56:50 -     ()  
2018-10-19 20:56:55 - // Call IfBlock  
2018-10-19 20:56:55 - let _ = Variable.IfBlock isEffective f1 f2
2018-10-19 21:13:33 - //using the Foreach Block  
2018-10-19 21:13:33 - let pixel = Range(10)  
2018-10-19 21:13:33 - let bools = Variable.Array<bool>(pixel)
2018-10-19 21:13:33 - Variable.ForeachBlock pixel ( fun pixel -> bools.[pixel] <- Variable.Bernoulli(0.7) ||| Variable.Bernoulli(0.4))
2018-10-19 21:13:47 - //using the Switch Block  
2018-10-19 21:13:47 - let mixtureSize = 2  
2018-10-19 21:13:47 - let k2 = Range(mixtureSize)  
2018-10-19 21:13:47 - let c = Variable.Discrete(k2, [|0.5;0.5|])  
2018-10-19 21:13:47 - let means2 = Variable.Observed( [|1.0;2.0|], k2)
2018-10-19 21:13:47 - let x = Variable.New<double>();  
2018-10-19 21:13:47 - Variable.SwitchBlock c (fun _ -> 
2018-10-19 21:13:47 -     let _ = x.SetTo(Variable.GaussianFromMeanAndVariance(means2.[c], 1.0))  
2018-10-19 21:13:47 -     ()  
2018-10-19 21:13:47 - )
2018-10-19 21:13:48 - //using the SwitchExpr Block  
2018-10-19 21:13:48 - let k =  Range(2) 
2018-10-19 21:13:48 - let means = Variable.ArrayInit k (fun k ->  
2018-10-19 21:13:48 -                 Variable.VectorGaussianFromMeanAndPrecision( Vector.Constant(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-10-19 21:14:07 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-10-19 21:14:07 - let n = Range(100)
2018-10-19 21:14:07 - let z = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-19 21:14:07 - let data = Variable.ArrayInit n (fun i ->  
2018-10-19 21:14:07 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-19 21:14:07 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-19 21:14:08 - Expression evaluation failed: VariableArray<PositiveDefiniteMatrix> vPositiveDefiniteMatrix[]0 cannot be indexed by vint[]3[index23].
2018-10-19 21:14:08 - Parameter name: index
2018-10-19 21:14:08 - ArgumentExceptionVariableArray<PositiveDefiniteMatrix> vPositiveDefiniteMatrix[]0 cannot be indexed by vint[]3[index23].
2018-10-19 21:14:08 - Parameter name: index
2018-10-19 21:14:08 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 21:14:08 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 21:14:08 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 21:14:08 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Variable`1[T] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 21:14:08 -   at FSI_0168+data@6-3.Invoke (Microsoft.ML.Probabilistic.Models.Variable`1[T] zi) [0x00013] in <f974be6cbf924aeca7488007b9b7c8b9>:0 
2018-10-19 21:14:08 -   at FSI_0085.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x0000d] in <f974be6cbf924aeca7488007b9b7c8b9>:0 
2018-10-19 21:14:08 -   at FSI_0168+data@5-2.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x00013] in <f974be6cbf924aeca7488007b9b7c8b9>:0 
2018-10-19 21:14:08 -   at FSI_0085.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <f974be6cbf924aeca7488007b9b7c8b9>:0 
2018-10-19 21:14:08 -   at <StartupCode$FSI_0168>.$FSI_0168.main@ () [0x0006e] in <f974be6cbf924aeca7488007b9b7c8b9>:0 
2018-10-19 21:14:08 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-19 21:14:08 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-19 21:14:24 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-10-19 21:14:24 - let n = new Range(100)
2018-10-19 21:14:24 - let z = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-19 21:14:24 - let data = Variable.ArrayInit n (fun i ->  
2018-10-19 21:14:24 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-19 21:14:24 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-19 21:14:25 - Expression evaluation failed: Range 'index22' is already open in a ForEach or Switch block
2018-10-19 21:14:25 - InvalidOperationExceptionRange 'index22' is already open in a ForEach or Switch block
2018-10-19 21:14:25 -   at Microsoft.ML.Probabilistic.Models.ForEachBlock.CheckRangeCanBeOpened (Microsoft.ML.Probabilistic.Models.Range range) [0x00079] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 21:14:25 -   at Microsoft.ML.Probabilistic.Models.SwitchBlock.OpenBlock () [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 21:14:25 -   at Microsoft.ML.Probabilistic.Models.SwitchBlock..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] conditionVariable, Microsoft.ML.Probabilistic.Models.Range range) [0x00010] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 21:14:25 -   at Microsoft.ML.Probabilistic.Models.Variable.Switch (Microsoft.ML.Probabilistic.Models.Variable`1[T] i) [0x00007] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-19 21:14:25 -   at FSI_0085.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x00000] in <f974be6cbf924aeca7488007b9b7c8b9>:0 
2018-10-19 21:14:25 -   at FSI_0169+data@5-4.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x00013] in <f974be6cbf924aeca7488007b9b7c8b9>:0 
2018-10-19 21:14:25 -   at FSI_0085.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <f974be6cbf924aeca7488007b9b7c8b9>:0 
2018-10-19 21:14:25 -   at <StartupCode$FSI_0169>.$FSI_0169.main@ () [0x0006e] in <f974be6cbf924aeca7488007b9b7c8b9>:0 
2018-10-19 21:14:25 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-19 21:14:25 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-19 21:14:32 - //using the SwitchExpr Block  
2018-10-19 21:14:32 - let k =  Range(2) 
2018-10-19 21:14:32 - let means = Variable.ArrayInit k (fun k ->  
2018-10-19 21:14:32 -                 Variable.VectorGaussianFromMeanAndPrecision( Vector.Constant(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-10-19 21:14:33 - let precs = Variable.ArrayInit k (fun k ->  
2018-10-19 21:14:33 -                 Variable.WishartFromShapeAndScale(1.0,  
2018-10-19 21:14:33 -                     PositiveDefiniteMatrix.Identity(2)))  
2018-10-19 21:14:34 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-10-19 21:14:34 - let n = new Range(100)
2018-10-19 21:14:34 - let z = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-19 21:14:34 - let data = Variable.ArrayInit n (fun i ->  
2018-10-19 21:14:34 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-19 21:14:34 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-19 21:14:49 - //using the SwitchExpr Block  
2018-10-19 21:14:49 - let k =  Range(2) 
2018-10-19 21:14:49 - let means = Variable.ArrayInit k (fun k ->  
2018-10-19 21:14:49 -                 Variable.VectorGaussianFromMeanAndPrecision( Vector.Constant(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-10-19 21:14:50 - let precs = Variable.ArrayInit k (fun k ->  
2018-10-19 21:14:50 -                 Variable.WishartFromShapeAndScale(1.0,  
2018-10-19 21:14:50 -                     PositiveDefiniteMatrix.Identity(2)))  
2018-10-19 21:14:50 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-10-19 21:14:50 - let n = Range(100)
2018-10-19 21:14:50 - let z = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-19 21:14:50 - let data = Variable.ArrayInit n (fun i ->  
2018-10-19 21:14:50 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-19 21:14:50 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-19 21:55:18 - type TWGP= VariableArray<Dirichlet>, Dirichlet[][]
2018-10-19 21:55:18 - type TWG = VariableArray<Vector>, Vector[][]
2018-10-19 21:55:18 - let CPTWetGrassPrior= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-19 21:55:18 - let CPTWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-19 21:55:18 - Unexpected symbol ',' in member definition
2018-10-19 21:55:18 - Unexpected end of input in type definition
2018-10-19 21:55:18 - Type abbreviations cannot have augmentations
2018-10-19 21:55:18 - This declaration element is not permitted in an augmentation
2018-10-19 21:57:16 - let CPTWetGrassPrior= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-19 21:57:16 - let CPTWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-19 22:01:46 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-19 22:01:46 -     let r = parent.Range
2018-10-19 22:01:46 -     let child = Variable.Array<int>(r)
2018-10-19 22:01:46 -     Variable.ForeachBlock r ( fun r -> child.[r] <- Variable.Discrete(cpt[parent[n]]))
2018-10-19 22:01:46 -     child
2018-10-19 22:01:46 - (* 
2018-10-19 22:01:46 - using (Variable.ForEach(r))
2018-10-19 22:01:46 - using (Variable.Switch(parent[r]))
2018-10-19 22:01:46 - {
2018-10-19 22:01:46 -     child[n] = Variable.Discrete(cpt[parent[n]]);
2018-10-19 22:01:46 - }
2018-10-19 22:01:46 - return child;*)
2018-10-19 22:01:46 - This value is not a function and cannot be applied.
2018-10-19 22:01:46 - A unique overload for method 'Discrete' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Discrete([<ParamArray>] probs: float []) : Variable<int>, Variable.Discrete([<ParamArray>] probs: float []) : Variable<int>, Variable.Discrete(probs: Variable<Vector>) : Variable<int>, Variable.Discrete(v: Vector) : Variable<int>, Variable.Discrete(valueRange: Range, [<ParamArray>] probs: float []) : Variable<int>
2018-10-19 22:02:39 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-19 22:02:39 -     let r = parent.Range
2018-10-19 22:02:39 -     let child = Variable.Array<int>(r)
2018-10-19 22:02:39 -     Variable.ForeachBlock r ( fun r -> child.[r] <- Variable.Discrete<Vector>(cpt[parent[n]]))
2018-10-19 22:02:39 -     child
2018-10-19 22:02:39 - (* 
2018-10-19 22:02:39 - using (Variable.ForEach(r))
2018-10-19 22:02:39 - using (Variable.Switch(parent[r]))
2018-10-19 22:02:39 - {
2018-10-19 22:02:39 -     child[n] = Variable.Discrete(cpt[parent[n]]);
2018-10-19 22:02:39 - }
2018-10-19 22:02:39 - return child;*)
2018-10-19 22:02:39 - This value is not a function and cannot be applied.
2018-10-19 22:02:39 - Incorrect generic instantiation. No accessible member named 'Discrete' takes 1 generic arguments.
2018-10-19 22:10:33 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-19 22:10:33 -     let r = parent.Range
2018-10-19 22:10:33 -     let child = Variable.Array<int>(r)
2018-10-19 22:10:33 -     //Variable.ForeachBlock r ( fun r -> child.[r] <- Variable.Discrete<Vector>(cpt[parent[n]]))
2018-10-19 22:10:33 -     Variable.SwitchBlock r (fun _ -> 
2018-10-19 22:10:33 -         child.SetTo(Variable.Discrete<Vector>(cpt[parent[n]]))  
2018-10-19 22:10:33 -         ())
2018-10-19 22:10:33 -     child
2018-10-19 22:10:33 - (* 
2018-10-19 22:10:33 - using (Variable.ForEach(r))
2018-10-19 22:10:33 - using (Variable.Switch(parent[r]))
2018-10-19 22:10:33 - {
2018-10-19 22:10:33 -     child[n] = Variable.Discrete(cpt[parent[n]]);
2018-10-19 22:10:33 - }
2018-10-19 22:10:33 - return child;*)
2018-10-19 22:10:34 - The type 'Range' is not compatible with the type 'Variable<int>'
2018-10-19 22:10:34 - This value is not a function and cannot be applied.
2018-10-19 22:10:34 - Incorrect generic instantiation. No accessible member named 'Discrete' takes 1 generic arguments.
2018-10-19 22:11:48 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-19 22:11:48 -     let r = Range(2) // parent.Range
2018-10-19 22:11:48 -     let child = Variable.Array<int>(r)
2018-10-19 22:11:48 -     //Variable.ForeachBlock r ( fun r -> child.[r] <- Variable.Discrete<Vector>(cpt[parent[n]]))
2018-10-19 22:11:48 -     Variable.SwitchBlock r (fun _ -> 
2018-10-19 22:11:48 -         child.SetTo(Variable.Discrete<Vector>(cpt[parent[n]]))  
2018-10-19 22:11:48 -         ())
2018-10-19 22:11:48 -     child
2018-10-19 22:11:48 - (* 
2018-10-19 22:11:48 - using (Variable.ForEach(r))
2018-10-19 22:11:48 - using (Variable.Switch(parent[r]))
2018-10-19 22:11:48 - {
2018-10-19 22:11:48 -     child[n] = Variable.Discrete(cpt[parent[n]]);
2018-10-19 22:11:48 - }
2018-10-19 22:11:48 - return child;*)
2018-10-19 22:11:49 - The type 'Range' is not compatible with the type 'Variable<int>'
2018-10-19 22:11:49 - This value is not a function and cannot be applied.
2018-10-19 22:11:49 - Incorrect generic instantiation. No accessible member named 'Discrete' takes 1 generic arguments.
2018-10-19 22:15:44 - let r = Range(2) // parent.Range
2018-10-19 22:15:44 - let child = Variable.Array<int>(r)
2018-10-19 22:15:44 - //Variable.ForeachBlock r ( fun r -> child.[r] <- Variable.Discrete<Vector>(cpt[parent[n]]))
2018-10-19 22:21:34 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-19 22:21:34 -     let r = Range(2) // parent.Range
2018-10-19 22:21:34 -     let child = Variable.Array<int>(r)
2018-10-19 22:21:34 -     //Variable.ForeachBlock r ( fun r -> child.[r] <- Variable.Discrete<Vector>(cpt[parent[n]]))
2018-10-19 22:21:34 -     Variable.SwitchBlock r (fun _ -> 
2018-10-19 22:21:34 -         child.SetTo(Variable.Discrete(cpt[parent[n]]))  
2018-10-19 22:21:34 -         ())
2018-10-19 22:21:34 -     child
2018-10-19 22:21:34 - (* 
2018-10-19 22:21:34 - using (Variable.ForEach(r))
2018-10-19 22:21:34 - using (Variable.Switch(parent[r]))
2018-10-19 22:21:34 - {
2018-10-19 22:21:34 -     child[n] = Variable.Discrete(cpt[parent[n]]);
2018-10-19 22:21:34 - }
2018-10-19 22:21:34 - return child;*)
2018-10-19 22:21:34 - The type 'Range' is not compatible with the type 'Variable<int>'
2018-10-19 22:21:34 - This value is not a function and cannot be applied.
2018-10-19 22:21:34 - A unique overload for method 'Discrete' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Discrete([<ParamArray>] probs: float []) : Variable<int>, Variable.Discrete([<ParamArray>] probs: float []) : Variable<int>, Variable.Discrete(probs: Variable<Vector>) : Variable<int>, Variable.Discrete(v: Vector) : Variable<int>, Variable.Discrete(valueRange: Range, [<ParamArray>] probs: float []) : Variable<int>
2018-10-19 22:21:53 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-19 22:21:53 -     let r = Range(2) // parent.Range
2018-10-19 22:21:53 -     let child = Variable.Array<int>(r)
2018-10-19 22:21:53 -     //Variable.ForeachBlock r ( fun r -> child.[r] <- Variable.Discrete<Vector>(cpt[parent[n]]))
2018-10-19 22:21:53 -     Variable.SwitchBlock r (fun _ -> 
2018-10-19 22:21:53 -         child.SetTo(Variable.Discrete(cpt[parent[r]]))  
2018-10-19 22:21:53 -         ())
2018-10-19 22:21:53 -     child
2018-10-19 22:21:53 - (* 
2018-10-19 22:21:53 - using (Variable.ForEach(r))
2018-10-19 22:21:53 - using (Variable.Switch(parent[r]))
2018-10-19 22:21:53 - {
2018-10-19 22:21:53 -     child[n] = Variable.Discrete(cpt[parent[n]]);
2018-10-19 22:21:53 - }
2018-10-19 22:21:53 - return child;*)
2018-10-19 22:21:54 - The type 'Range' is not compatible with the type 'Variable<int>'
2018-10-19 22:21:54 - This value is not a function and cannot be applied.
2018-10-19 22:21:54 - A unique overload for method 'Discrete' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Discrete([<ParamArray>] probs: float []) : Variable<int>, Variable.Discrete([<ParamArray>] probs: float []) : Variable<int>, Variable.Discrete(probs: Variable<Vector>) : Variable<int>, Variable.Discrete(v: Vector) : Variable<int>, Variable.Discrete(valueRange: Range, [<ParamArray>] probs: float []) : Variable<int>
2018-10-19 22:22:50 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-19 22:22:50 -     let r = Range(2) // parent.Range
2018-10-19 22:22:50 -     let child = Variable.Array<int>(r)
2018-10-19 22:22:50 -     //Variable.ForeachBlock r ( fun r -> child.[r] <- Variable.Discrete<Vector>(cpt[parent[n]]))
2018-10-19 22:22:50 -     Variable.SwitchBlock r (fun _ -> 
2018-10-19 22:22:50 -         child.SetTo(Variable.Bernoulli(0.7)) //Variable.Discrete(cpt[parent[r]]))  
2018-10-19 22:22:50 -         ())
2018-10-19 22:22:50 -     child
2018-10-19 22:22:50 - (* 
2018-10-19 22:22:50 - using (Variable.ForEach(r))
2018-10-19 22:22:50 - using (Variable.Switch(parent[r]))
2018-10-19 22:22:50 - {
2018-10-19 22:22:50 -     child[n] = Variable.Discrete(cpt[parent[n]]);
2018-10-19 22:22:50 - }
2018-10-19 22:22:50 - return child;*)
2018-10-19 22:22:50 - The type 'Range' is not compatible with the type 'Variable<int>'
2018-10-19 22:22:50 - No overloads match for method 'SetTo'. The available overloads are shown below.
2018-10-19 22:22:50 - Possible overload: 'VariableArray.SetTo(that: VariableArray<int>) : unit'. Type constraint mismatch. The type 
2018-10-19 22:22:50 -     'Variable<bool>'    
2018-10-19 22:22:50 - is not compatible with type
2018-10-19 22:22:50 -     'VariableArray<int>'    
2018-10-19 22:22:50 - .
2018-10-19 22:22:50 - Possible overload: 'VariableArray.SetTo(that: VariableArray<Variable<int>,int []>) : unit'. Type constraint mismatch. The type 
2018-10-19 22:22:50 -     'Variable<bool>'    
2018-10-19 22:22:50 - is not compatible with type
2018-10-19 22:22:50 -     'VariableArray<Variable<int>,int []>'    
2018-10-19 22:22:50 - .
2018-10-19 22:22:50 - Possible overload: 'VariableArrayBase.SetTo(that: VariableArrayBase<Variable<int>,int []>) : unit'. Type constraint mismatch. The type 
2018-10-19 22:22:50 -     'Variable<bool>'    
2018-10-19 22:22:50 - is not compatible with type
2018-10-19 22:22:50 -     'VariableArrayBase<Variable<int>,int []>'    
2018-10-19 22:22:50 - .
2018-10-19 22:22:50 - Possible overload: 'Variable.SetTo(variable: Variable<int []>) : unit'. Type constraint mismatch. The type 
2018-10-19 22:22:50 -     'Variable<bool>'    
2018-10-19 22:22:50 - is not compatible with type
2018-10-19 22:22:50 -     'Variable<int []>'    
2018-10-19 22:22:50 - .
2018-10-19 22:36:47 - let r = Range(2) // parent.Range
2018-10-19 22:36:47 - let child = Variable.Array<int>(r)
2018-10-19 22:36:47 - Variable.ForeachBlock r ( fun r -> child.[r] <- Variable.Bernoulli(0.7))
2018-10-19 22:36:47 - No overloads match for method 'Item'. The available overloads are shown below.
2018-10-19 22:36:47 - Possible overload: 'VariableArray.set_Item(index: int, value: Variable<int>) : unit'. Type constraint mismatch. The type 
2018-10-19 22:36:47 -     'Range'    
2018-10-19 22:36:47 - is not compatible with type
2018-10-19 22:36:47 -     'int'    
2018-10-19 22:36:47 - .
2018-10-19 22:36:47 - Possible overload: 'VariableArray.set_Item(index: Variable<int>, value: Variable<int>) : unit'. Type constraint mismatch. The type 
2018-10-19 22:36:47 -     'Range'    
2018-10-19 22:36:47 - is not compatible with type
2018-10-19 22:36:47 -     'Variable<int>'    
2018-10-19 22:36:47 - .
2018-10-19 22:36:47 - Possible overload: 'VariableArray.set_Item(range: Range, value: Variable<int>) : unit'. Type constraint mismatch. The type 
2018-10-19 22:36:47 -     'Variable<bool>'    
2018-10-19 22:36:47 - is not compatible with type
2018-10-19 22:36:47 -     'Variable<int>'    
2018-10-19 22:36:47 - .
2018-10-20 13:59:11 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-20 13:59:11 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-20 13:59:11 - For help type #help;;
2018-10-20 13:59:11 - > val it :
2018-10-20 13:59:11 -   ResizeArray<System.Type *
2018-10-20 13:59:11 -               (obj ->
2018-10-20 13:59:11 -                  seq<string *
2018-10-20 13:59:11 -                      string> *
2018-10-20 13:59:11 -                  string)>
2018-10-20 13:59:11 - = seq []
2018-10-20 13:59:11 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-20 13:59:11 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-20 13:59:11 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-20 13:59:12 - Reporting 0 opened comms
2018-10-20 14:00:15 - #load "Paket.fsx"
2018-10-20 14:00:25 - Paket.Package
2018-10-20 14:00:25 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-20 14:00:25 -       "Microsoft.ML.Probabilistic"
2018-10-20 14:00:25 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-20 14:00:25 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-20 14:00:25 -       "NETStandard.Library"
2018-10-20 14:00:25 -   ]
2018-10-20 14:02:27 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-20 14:02:36 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-20 14:03:19 - open System.IO
2018-10-20 14:03:20 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-20 14:03:20 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-20 14:03:20 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-20 14:03:20 - #r "Microsoft.ML.Probabilistic"
2018-10-20 14:03:20 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-20 14:03:20 - #r "netstandard"
2018-10-20 14:03:35 - open System
2018-10-20 14:03:35 - open Microsoft.ML.Probabilistic  
2018-10-20 14:03:35 - open Microsoft.ML.Probabilistic.Models  
2018-10-20 14:03:35 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-20 14:03:35 - open Microsoft.ML.Probabilistic.Factors  
2018-10-20 14:03:35 - open Microsoft.ML.Probabilistic.Math
2018-10-20 14:03:36 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-20 14:03:40 - open Microsoft.ML.Probabilistic.FSharp
2018-10-20 14:07:28 - let engine =  InferenceEngine ()
2018-10-20 14:07:30 - let NumberOfExamples = Variable.New<int>().Named("NofE")
2018-10-20 14:07:30 - let N = Range(NumberOfExamples).Named("N")
2018-10-20 14:07:31 - let C = Range(2).Named("C")
2018-10-20 14:07:31 - let S = Range(2).Named("S")
2018-10-20 14:07:31 - let R = Range(2).Named("R")
2018-10-20 14:07:31 - let W = Range(2).Named("W")
2018-10-20 14:07:32 - let ProbCloudyPrior = Variable.New<Dirichlet>().Named("ProbCloudyPrior")
2018-10-20 14:07:32 - let ProbCloudy = Variable<Vector>.Random<Dirichlet>(ProbCloudyPrior).Named("ProbCloudy")
2018-10-20 14:07:32 - ProbCloudy.SetValueRange(C)
2018-10-20 14:07:37 - let CPTSprinklerPrior = Variable.Array<Dirichlet>(C).Named("CPTSprinklerPrior")
2018-10-20 14:07:37 - let CPTSprinkler = Variable.Array<Vector>(C).Named("CPTSprinkler")
2018-10-20 14:07:45 - CPTSprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior.[C]))
2018-10-20 14:07:45 - let CPTRainPrior = Variable.Array<Dirichlet>(C).Named("CPTRainPrior")
2018-10-20 14:07:45 - let CPTRain = Variable.Array<Vector>(C).Named("CPTRain")
2018-10-20 14:07:46 - CPTRain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTRainPrior.[C]))
2018-10-20 14:07:46 - let CPTWetGrassPrior= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-20 14:07:46 - let CPTWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-20 14:07:47 - CPTWetGrass.[S].[R].SetTo(Variable<Vector>.Random<Dirichlet>(CPTWetGrassPrior.[S].[R]))
2018-10-20 14:07:47 - CPTWetGrass.SetValueRange(W)
2018-10-20 14:07:53 - let Cloudy = Variable.Array<int>(N).Named("Cloudy");
2018-10-20 14:07:53 - Cloudy.[N].SetTo(Variable.Discrete(ProbCloudy).ForEach(N))
2018-10-20 14:10:31 - //using the Switch Block  
2018-10-20 14:10:31 - let mixtureSize = 2  
2018-10-20 14:10:31 - let k2 = Range(mixtureSize)  
2018-10-20 14:10:31 - let c = Variable.Discrete(k2, [|0.5;0.5|])  
2018-10-20 14:10:31 - let means2 = Variable.Observed( [|1.0;2.0|], k2)
2018-10-20 14:10:31 - let x = Variable.New<double>();  
2018-10-20 14:10:31 - Variable.SwitchBlock c (fun _ -> 
2018-10-20 14:10:31 -     let _ = x.SetTo(Variable.GaussianFromMeanAndVariance(means2.[c], 1.0))  
2018-10-20 14:10:31 -     ()  
2018-10-20 14:10:31 - )
2018-10-20 14:10:32 - //using the SwitchExpr Block  
2018-10-20 14:10:32 - let k =  Range(2) 
2018-10-20 14:10:32 - let means = Variable.ArrayInit k (fun k ->  
2018-10-20 14:10:32 -                 Variable.VectorGaussianFromMeanAndPrecision( Vector.Constant(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-10-20 14:10:33 - let precs = Variable.ArrayInit k (fun k ->  
2018-10-20 14:10:33 -                 Variable.WishartFromShapeAndScale(1.0,  
2018-10-20 14:10:33 -                     PositiveDefiniteMatrix.Identity(2)))  
2018-10-20 14:10:33 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-10-20 14:10:33 - let n = Range(100)
2018-10-20 14:10:33 - let z = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-20 14:10:33 - let data = Variable.ArrayInit n (fun i ->  
2018-10-20 14:10:33 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-20 14:10:33 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-20 14:10:48 - means.GetType()
2018-10-20 14:11:04 - //using the SwitchExpr Block  
2018-10-20 14:11:04 - let k =  Range(2) 
2018-10-20 14:11:04 - let means:VariableArray<Vector> = Variable.ArrayInit k (fun k ->  
2018-10-20 14:11:04 -                 Variable.VectorGaussianFromMeanAndPrecision( Vector.Constant(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-10-20 14:13:44 - c.GetType()
2018-10-20 14:14:10 - means2.GetType()
2018-10-20 14:14:35 - x.GetType()
2018-10-20 14:14:51 - //using the Switch Block  
2018-10-20 14:14:51 - let mixtureSize = 2  
2018-10-20 14:14:51 - let k2 = Range(mixtureSize)  
2018-10-20 14:14:51 - let c:Variable<int> = Variable.Discrete(k2, [|0.5;0.5|])  
2018-10-20 14:14:51 - let means2:VariableArray<float> = Variable.Observed( [|1.0;2.0|], k2)
2018-10-20 14:14:51 - let xVariable<float> = Variable.New<double>();  
2018-10-20 14:14:51 - Variable.SwitchBlock c (fun _ -> 
2018-10-20 14:14:51 -     let _ = x.SetTo(Variable.GaussianFromMeanAndVariance(means2.[c], 1.0))  
2018-10-20 14:14:51 -     ()  
2018-10-20 14:14:51 - )
2018-10-20 14:14:52 - Unexpected identifier in pattern. Expected infix operator, quote symbol or other token.
2018-10-20 14:14:57 - //using the Switch Block  
2018-10-20 14:14:57 - let mixtureSize = 2  
2018-10-20 14:14:57 - let k2 = Range(mixtureSize)  
2018-10-20 14:14:57 - let c:Variable<int> = Variable.Discrete(k2, [|0.5;0.5|])  
2018-10-20 14:14:57 - let means2:VariableArray<float> = Variable.Observed( [|1.0;2.0|], k2)
2018-10-20 14:14:57 - let x:Variable<float> = Variable.New<double>();  
2018-10-20 14:14:57 - Variable.SwitchBlock c (fun _ -> 
2018-10-20 14:14:57 -     let _ = x.SetTo(Variable.GaussianFromMeanAndVariance(means2.[c], 1.0))  
2018-10-20 14:14:57 -     ()  
2018-10-20 14:14:57 - )
2018-10-20 16:53:55 - precs.GetType()
2018-10-20 16:54:50 - let precs:VariableArray<PositiveDefiniteMatrix> = 
2018-10-20 16:54:50 -     Variable.ArrayInit k (fun k -> 
2018-10-20 16:54:50 -         Variable.WishartFromShapeAndScale(1.0,  
2018-10-20 16:54:50 -         PositiveDefiniteMatrix.Identity(2)))  
2018-10-20 16:54:50 - Possible incorrect indentation: this token is offside of context started at position (3:9). Try indenting this token further or using standard formatting conventions.
2018-10-20 16:54:50 - Possible incorrect indentation: this token is offside of context started at position (3:9). Try indenting this token further or using standard formatting conventions.
2018-10-20 16:55:06 - let precs:VariableArray<PositiveDefiniteMatrix> = 
2018-10-20 16:55:06 -     Variable.ArrayInit k (fun k -> 
2018-10-20 16:55:06 -                             Variable.WishartFromShapeAndScale(1.0,  
2018-10-20 16:55:06 -                             PositiveDefiniteMatrix.Identity(2)))  
2018-10-20 16:55:07 - Possible incorrect indentation: this token is offside of context started at position (3:29). Try indenting this token further or using standard formatting conventions.
2018-10-20 16:55:07 - Possible incorrect indentation: this token is offside of context started at position (3:29). Try indenting this token further or using standard formatting conventions.
2018-10-20 16:55:33 - let precs:VariableArray<PositiveDefiniteMatrix> =  
2018-10-20 16:55:33 -     Variable.ArrayInit k (fun k -> 
2018-10-20 16:55:33 -                             Variable.WishartFromShapeAndScale(1.0,  
2018-10-20 16:55:33 -                             PositiveDefiniteMatrix.Identity(2)))  
2018-10-20 16:55:33 - Possible incorrect indentation: this token is offside of context started at position (3:29). Try indenting this token further or using standard formatting conventions.
2018-10-20 16:55:33 - Possible incorrect indentation: this token is offside of context started at position (3:29). Try indenting this token further or using standard formatting conventions.
2018-10-20 16:55:42 - let precs:VariableArray<PositiveDefiniteMatrix> =  
2018-10-20 16:55:42 -     Variable.ArrayInit k (fun k -> 
2018-10-20 16:55:42 -                             Variable.WishartFromShapeAndScale(1.0,  
2018-10-20 16:55:42 -                                 PositiveDefiniteMatrix.Identity(2)))  
2018-10-20 16:55:55 - let precs:VariableArray<PositiveDefiniteMatrix> =  
2018-10-20 16:55:55 -     Variable.ArrayInit k (fun k -> 
2018-10-20 16:55:55 -         Variable.WishartFromShapeAndScale(1.0,  
2018-10-20 16:55:55 -             PositiveDefiniteMatrix.Identity(2)))  
2018-10-20 16:56:47 - // Loop over mixture components
2018-10-20 16:56:47 - let means:VariableArray<Vector> = 
2018-10-20 16:56:47 -     Variable.ArrayInit k (fun k ->  
2018-10-20 16:56:47 -         Variable.VectorGaussianFromMeanAndPrecision( Vector.Constant(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-10-20 17:03:18 - z.GetType()
2018-10-20 17:03:45 - let z:VariableArray<int> = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-20 17:16:17 - let data = Variable.ArrayInit n (fun i ->  
2018-10-20 17:16:17 -                Variable.SwitchExpr (z.[i]) (fun zi -> printf "%A" zi.GetType(); 
2018-10-20 17:16:17 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-20 17:16:17 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-20 17:16:17 - Unexpected identifier in expression
2018-10-20 17:16:17 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-20 17:16:17 - Unexpected symbol ')' in lambda expression. Expected incomplete structured construct at or before this point or other token.
2018-10-20 17:16:17 - Incomplete structured construct at or before this point in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-20 17:17:02 - let data = Variable.ArrayInit n (fun i ->  
2018-10-20 17:17:02 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-20 17:17:02 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-20 17:17:02 - Expression evaluation failed: VariableArray<Vector> vVector[]11 cannot be indexed by vint[]3[index7].
2018-10-20 17:17:02 - Parameter name: index
2018-10-20 17:17:02 - ArgumentExceptionVariableArray<Vector> vVector[]11 cannot be indexed by vint[]3[index7].
2018-10-20 17:17:02 - Parameter name: index
2018-10-20 17:17:02 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 17:17:02 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 17:17:02 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 17:17:02 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Variable`1[T] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 17:17:02 -   at FSI_0060+data@2-3.Invoke (Microsoft.ML.Probabilistic.Models.Variable`1[T] zi) [0x00005] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 17:17:02 -   at FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x0000d] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 17:17:02 -   at FSI_0060+data@1-2.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x00013] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 17:17:02 -   at FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 17:17:02 -   at <StartupCode$FSI_0060>.$FSI_0060.main@ () [0x0000a] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 17:17:02 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-20 17:17:02 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-20 17:24:44 - let z:VariableArray<int> = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-20 17:24:45 - Expression evaluation failed: Range 'index7' is already open in a ForEach block.  Use a cloned range instead.
2018-10-20 17:24:45 - InvalidOperationExceptionRange 'index7' is already open in a ForEach block.  Use a cloned range instead.
2018-10-20 17:24:45 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0008f] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 17:24:45 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 17:24:45 -   at Microsoft.ML.Probabilistic.Models.VariableArray`1[T]..ctor (Microsoft.ML.Probabilistic.Models.Range range) [0x00006] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 17:24:45 -   at Microsoft.ML.Probabilistic.Models.Variable.Array[T] (Microsoft.ML.Probabilistic.Models.Range r) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 17:24:45 -   at FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00000] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 17:24:45 -   at <StartupCode$FSI_0061>.$FSI_0061.main@ () [0x0000a] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 17:24:45 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-20 17:24:45 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-20 17:25:08 - // Size of array to store outcomes
2018-10-20 17:25:08 - let n = Range(100).Named("n")
2018-10-20 17:25:11 - let z:VariableArray<int> = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-20 17:25:16 - let data = Variable.ArrayInit n (fun i ->  
2018-10-20 17:25:16 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-20 17:25:16 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-20 17:25:16 - Expression evaluation failed: Range 'index6' is already open in a ForEach or Switch block
2018-10-20 17:25:16 - InvalidOperationExceptionRange 'index6' is already open in a ForEach or Switch block
2018-10-20 17:25:16 -   at Microsoft.ML.Probabilistic.Models.ForEachBlock.CheckRangeCanBeOpened (Microsoft.ML.Probabilistic.Models.Range range) [0x00079] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 17:25:16 -   at Microsoft.ML.Probabilistic.Models.SwitchBlock.OpenBlock () [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 17:25:16 -   at Microsoft.ML.Probabilistic.Models.SwitchBlock..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] conditionVariable, Microsoft.ML.Probabilistic.Models.Range range) [0x00010] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 17:25:16 -   at Microsoft.ML.Probabilistic.Models.Variable.Switch (Microsoft.ML.Probabilistic.Models.Variable`1[T] i) [0x00007] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 17:25:16 -   at FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x00000] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 17:25:16 -   at FSI_0064+data@1-4.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x00013] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 17:25:16 -   at FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 17:25:16 -   at <StartupCode$FSI_0064>.$FSI_0064.main@ () [0x0000a] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 17:25:16 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-20 17:25:16 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-20 17:25:48 - //using the SwitchExpr Block - to model 100 outcomes of a 2-component mixture Wishart distributed variable
2018-10-20 17:25:48 - let k =  Range(2).Named("k")
2018-10-20 17:25:48 - // Loop over mixture components
2018-10-20 17:25:48 - let means:VariableArray<Vector> = 
2018-10-20 17:25:48 -     Variable.ArrayInit k (fun k ->  
2018-10-20 17:25:48 -         Variable.VectorGaussianFromMeanAndPrecision( Vector.Constant(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-10-20 17:25:49 - let precs:VariableArray<PositiveDefiniteMatrix> =  
2018-10-20 17:25:49 -     Variable.ArrayInit k (fun k -> 
2018-10-20 17:25:49 -         Variable.WishartFromShapeAndScale(1.0,  
2018-10-20 17:25:49 -             PositiveDefiniteMatrix.Identity(2)))  
2018-10-20 17:25:49 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-10-20 17:26:49 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-10-20 17:26:53 - let n = Range(100).Named("n")
2018-10-20 17:26:55 - let z:VariableArray<int> = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-20 17:27:00 - let data = Variable.ArrayInit n (fun i ->  
2018-10-20 17:27:00 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-20 17:27:00 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-20 17:34:02 - let data = Variable.ArrayInit n (fun i:int ->  
2018-10-20 17:34:02 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-20 17:34:02 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-20 17:34:02 - Unexpected symbol ':' in lambda expression. Expected '->' or other token.
2018-10-20 17:34:02 - Incomplete structured construct at or before this point in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-20 17:34:13 - let data = Variable.ArrayInit n (fun (i:int)->  
2018-10-20 17:34:13 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-20 17:34:13 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-20 17:34:14 - This expression was expected to have type
2018-10-20 17:34:14 -     'Range'    
2018-10-20 17:34:14 - but here has type
2018-10-20 17:34:14 -     'int'    
2018-10-20 17:34:32 - let data = Variable.ArrayInit n (fun (i:Range)->  
2018-10-20 17:34:32 -                Variable.SwitchExpr (z.[i]) (fun zi ->  
2018-10-20 17:34:32 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-20 17:34:42 - let data = Variable.ArrayInit n (fun (i:Range)->  
2018-10-20 17:34:42 -                Variable.SwitchExpr (z.[i]) (fun zi:Range ->  
2018-10-20 17:34:42 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-20 17:34:42 - Unexpected symbol ':' in lambda expression. Expected '->' or other token.
2018-10-20 17:34:50 - let data = Variable.ArrayInit n (fun (i:Range)->  
2018-10-20 17:34:50 -                Variable.SwitchExpr (z.[i]) (fun (zi:Range) ->  
2018-10-20 17:34:50 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-20 17:34:51 - This expression was expected to have type
2018-10-20 17:34:51 -     'Variable<int>'    
2018-10-20 17:34:51 - but here has type
2018-10-20 17:34:51 -     'Range'    
2018-10-20 17:35:02 - let data = Variable.ArrayInit n (fun (i:Range)->  
2018-10-20 17:35:02 -                Variable.SwitchExpr (z.[i]) (fun (zi:Variable<int>) ->  
2018-10-20 17:35:02 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-20 18:03:09 - let C = Range(2).Named("C") // Cloudy
2018-10-20 18:03:09 - let S = Range(2).Named("S") // Sprinkler
2018-10-20 18:03:09 - let R = Range(2).Named("R") // Rain
2018-10-20 18:03:09 - let W = Range(2).Named("W") // Wet
2018-10-20 18:14:54 - ProbCloudyPrior.GetType()
2018-10-20 18:15:15 - let ProbCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("ProbCloudyPrior")
2018-10-20 18:15:15 - let ProbCloudy = Variable<Vector>.Random<Dirichlet>(ProbCloudyPrior).Named("ProbCloudy")
2018-10-20 18:15:15 - ProbCloudy.SetValueRange(C)
2018-10-20 18:15:35 - ProbCloudy.GetType()
2018-10-20 18:15:48 - let ProbCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("ProbCloudyPrior")
2018-10-20 18:15:48 - let ProbCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(ProbCloudyPrior).Named("ProbCloudy")
2018-10-20 18:15:48 - ProbCloudy.SetValueRange(C)
2018-10-20 18:46:40 - let CPTWetGrassPrior= 
2018-10-20 18:46:40 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>
2018-10-20 18:46:40 -         (Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-20 18:46:40 - let CPTWetGrass = 
2018-10-20 18:46:40 -     Variable.Array<VariableArray<Vector>, Vector[][]>
2018-10-20 18:46:40 -         (Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-20 18:46:41 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-20 18:46:41 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-20 18:46:41 - The field, constructor or member 'Named' is not defined.
2018-10-20 18:46:41 - The member or object constructor 'Array' does not take 1 argument(s). An overload was found taking 1 arguments.
2018-10-20 18:46:41 - The field, constructor or member 'Named' is not defined.
2018-10-20 18:46:41 - The member or object constructor 'Array' does not take 1 argument(s). An overload was found taking 1 arguments.
2018-10-20 18:47:00 - let CPTWetGrassPrior= 
2018-10-20 18:47:00 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]> (
2018-10-20 18:47:00 -         Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-20 18:47:00 - let CPTWetGrass = 
2018-10-20 18:47:00 -     Variable.Array<VariableArray<Vector>, Vector[][]> ()
2018-10-20 18:47:00 -         Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-20 18:47:01 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-20 18:47:01 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-20 18:47:01 - Unexpected symbol ')' in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-20 18:47:01 - The field, constructor or member 'Named' is not defined.
2018-10-20 18:47:01 - The member or object constructor 'Array' does not take 1 argument(s). An overload was found taking 1 arguments.
2018-10-20 18:47:27 - let CPTWetGrassPrior= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]> (
2018-10-20 18:47:27 -         Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-20 18:47:27 - let CPTWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]> (
2018-10-20 18:47:27 -         Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-20 18:47:27 - Possible incorrect indentation: this token is offside of context started at position (1:23). Try indenting this token further or using standard formatting conventions.
2018-10-20 18:47:27 - Possible incorrect indentation: this token is offside of context started at position (1:23). Try indenting this token further or using standard formatting conventions.
2018-10-20 18:47:27 - Possible incorrect indentation: this token is offside of context started at position (1:23). Try indenting this token further or using standard formatting conventions.
2018-10-20 18:47:27 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-20 18:47:27 - Possible incorrect indentation: this token is offside of context started at position (3:19). Try indenting this token further or using standard formatting conventions.
2018-10-20 18:47:27 - Possible incorrect indentation: this token is offside of context started at position (3:19). Try indenting this token further or using standard formatting conventions.
2018-10-20 18:47:27 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-20 18:47:27 - The field, constructor or member 'Named' is not defined.
2018-10-20 18:47:27 - The member or object constructor 'Array' does not take 1 argument(s). An overload was found taking 1 arguments.
2018-10-20 18:47:27 - The field, constructor or member 'Named' is not defined.
2018-10-20 18:47:27 - The member or object constructor 'Array' does not take 1 argument(s). An overload was found taking 1 arguments.
2018-10-20 18:47:42 - let CPTWetGrassPrior= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]> (
2018-10-20 18:47:42 -                             Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-20 18:47:42 - let CPTWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]> (
2018-10-20 18:47:42 -                             Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-20 18:47:42 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-20 18:47:42 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-20 18:47:42 - The field, constructor or member 'Named' is not defined.
2018-10-20 18:47:42 - The member or object constructor 'Array' does not take 1 argument(s). An overload was found taking 1 arguments.
2018-10-20 18:47:42 - The field, constructor or member 'Named' is not defined.
2018-10-20 18:47:42 - The member or object constructor 'Array' does not take 1 argument(s). An overload was found taking 1 arguments.
2018-10-20 18:48:05 - let CPTWetGrassPrior= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-20 18:48:05 -                             Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-20 18:48:05 - let CPTWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-20 18:48:05 -                             Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-20 18:48:17 - let CPTWetGrassPrior= 
2018-10-20 18:48:17 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-20 18:48:17 -         Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-20 18:48:17 - let CPTWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-20 18:48:17 -                             Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-20 18:48:57 - CPTWetGrassPrior.GetType()
2018-10-20 18:58:00 - let CPTWetGrassPrior= 
2018-10-20 18:58:00 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-20 18:58:00 -         Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-20 18:58:00 - let CPTWetGrass = 
2018-10-20 18:58:00 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-20 18:58:00 -         Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-20 19:09:25 - CPTWetGrassPrior.Range
2018-10-20 19:09:43 - CPTWetGrass.Range
2018-10-20 19:37:34 - let probCloudy = Vector.FromArray(0.5, 0.5)
2018-10-20 19:37:34 - let cptSprinkler = [| Vector.FromArray(0.1, 0.9) /* cloudy */, Vector.FromArray(0.5, 0.5) /* not cloudy */ |]
2018-10-20 19:37:34 - let cptRain = [| { Vector.FromArray(0.8, 0.2) /* cloudy */, Vector.FromArray(0.2, 0.8) /* not cloudy */|]
2018-10-20 19:37:34 - Unexpected symbol ',' in expression
2018-10-20 19:37:34 - Unmatched '[|'
2018-10-20 19:37:34 - Unexpected symbol '|]' in expression
2018-10-20 19:37:34 - Unexpected symbol ',' in expression
2018-10-20 19:37:34 - Unmatched '{'
2018-10-20 19:37:34 - Unexpected symbol ']' in expression
2018-10-20 19:37:34 - Unmatched '[|'
2018-10-20 19:37:34 - Unexpected end of input
2018-10-20 19:37:34 - Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.
2018-10-20 19:37:47 - let probCloudy = Vector.FromArray(0.5, 0.5)
2018-10-20 19:37:47 - let cptSprinkler = [| Vector.FromArray(0.1, 0.9) /* cloudy */; Vector.FromArray(0.5, 0.5) /* not cloudy */ |]
2018-10-20 19:37:47 - let cptRain = [| { Vector.FromArray(0.8, 0.2) /* cloudy */; Vector.FromArray(0.2, 0.8) /* not cloudy */|]
2018-10-20 19:37:48 - Unexpected symbol ';' in expression
2018-10-20 19:37:48 - Unmatched '[|'
2018-10-20 19:37:48 - Unexpected symbol '|]' in expression
2018-10-20 19:37:48 - Unexpected symbol ';' in expression
2018-10-20 19:37:48 - Unmatched '{'
2018-10-20 19:37:48 - Unexpected symbol ']' in expression
2018-10-20 19:37:48 - Unmatched '[|'
2018-10-20 19:38:45 - let probCloudy = Vector.FromArray(0.5, 0.5)
2018-10-20 19:38:45 - let cptSprinkler = [| Vector.FromArray(0.1, 0.9) (* cloudy *); Vector.FromArray(0.5, 0.5) (* not cloudy *) |]
2018-10-20 19:38:45 - let cptRain = [| Vector.FromArray(0.8, 0.2) (* cloudy *); Vector.FromArray(0.2, 0.8) (* not cloudy *)|]
2018-10-20 19:40:50 - let cptWetGrass = 
2018-10-20 19:40:50 -     [|
2018-10-20 19:40:50 -         [| Vector.FromArray(0.99, 0.01) (* rain *);  Vector.FromArray(0.9, 0.1) (* not rain *) |]; // Sprinkler
2018-10-20 19:40:50 -         [| Vector.FromArray(0.9, 0.1) (* rain *); Vector.FromArray(0.0, 1.0) (* not rain *) |]  // Not sprinkler
2018-10-20 19:40:50 -     |]
2018-10-20 20:16:57 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-20 20:16:57 -     let r = parent.Range
2018-10-20 20:16:57 -     //let child = Variable.Array<int>(r)
2018-10-20 20:16:57 -     //Variable.ForeachBlock r ( fun r -> child.[r] <- Variable.Discrete<Vector>(cpt[parent[n]]))
2018-10-20 20:16:57 -     let child:Variable.Array<int> = Variable.ArrayInit r (fun (i:Range)->  
2018-10-20 20:16:57 -                    Variable.SwitchExpr (z.[i]) (fun (zi:Variable<int>) ->  
2018-10-20 20:16:57 -                        Variable.Discrete(cpt[parent.[zi]])))
2018-10-20 20:16:57 -     child
2018-10-20 20:16:58 - The type 'Array' is not defined in 'FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable'.
2018-10-20 20:16:58 - This value is not a function and cannot be applied.
2018-10-20 20:16:58 - A unique overload for method 'Discrete' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Discrete([<ParamArray>] probs: float []) : Variable<int>, Variable.Discrete([<ParamArray>] probs: float []) : Variable<int>, Variable.Discrete(probs: Variable<Vector>) : Variable<int>, Variable.Discrete(v: Vector) : Variable<int>, Variable.Discrete(valueRange: Range, [<ParamArray>] probs: float []) : Variable<int>
2018-10-20 20:18:38 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-20 20:18:38 -     let r = parent.Range
2018-10-20 20:18:38 -     //let child = Variable.Array<int>(r)
2018-10-20 20:18:38 -     //Variable.ForeachBlock r ( fun r -> child.[r] <- Variable.Discrete<Vector>(cpt[parent[n]]))
2018-10-20 20:18:38 -     let child:Variable.Array<int> = Variable.ArrayInit r (fun (i:Range)->  
2018-10-20 20:18:38 -                    Variable.SwitchExpr (z.[i]) (fun (zi:Variable<int>) ->  
2018-10-20 20:18:38 -                        Variable.Discrete(cpt.[parent.[zi]])))
2018-10-20 20:18:38 -     child
2018-10-20 20:18:39 - The type 'Array' is not defined in 'FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable'.
2018-10-20 20:19:05 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-20 20:19:05 -     let r = parent.Range
2018-10-20 20:19:05 -     //let child = Variable.Array<int>(r)
2018-10-20 20:19:05 -     //Variable.ForeachBlock r ( fun r -> child.[r] <- Variable.Discrete<Vector>(cpt[parent[n]]))
2018-10-20 20:19:05 -     let (child:Variable.Array<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-20 20:19:05 -                    Variable.SwitchExpr (z.[i]) (fun (zi:Variable<int>) ->  
2018-10-20 20:19:05 -                        Variable.Discrete(cpt.[parent.[zi]])))
2018-10-20 20:19:05 -     child
2018-10-20 20:19:05 - The type 'Array' is not defined in 'FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable'.
2018-10-20 20:29:28 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-20 20:29:28 -     let r = parent.Range
2018-10-20 20:29:28 -     //let child = Variable.Array<int>(r)
2018-10-20 20:29:28 -     //Variable.ForeachBlock r ( fun r -> child.[r] <- Variable.Discrete<Vector>(cpt[parent[n]]))
2018-10-20 20:29:28 -     let (child:Variable.Array<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-20 20:29:28 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:Variable<int>) ->  
2018-10-20 20:29:28 -                        Variable.Discrete(cpt.[pi])))
2018-10-20 20:29:28 -     child
2018-10-20 20:29:28 - The type 'Array' is not defined in 'FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable'.
2018-10-20 20:31:07 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-20 20:31:07 -     let r = parent.Range
2018-10-20 20:31:07 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-20 20:31:07 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:Variable<int>) ->  
2018-10-20 20:31:07 -                        Variable.Discrete(cpt.[pi])))
2018-10-20 20:31:07 -     child
2018-10-20 20:37:21 - let AddChildFromTwoParents (parent1:VariableArray<int>) (parent2:VariableArray<int>) (cpt:VariableArray<VariableArray<Vector>, Vector[][]>) = 
2018-10-20 20:37:21 -     let n = parent1.Range
2018-10-20 20:37:21 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-20 20:37:21 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:Variable<int>) ->  
2018-10-20 20:37:21 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:Variable<int>) ->  
2018-10-20 20:37:21 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-20 20:37:21 -     child
2018-10-20 20:37:21 -         
2018-10-20 20:37:22 - The value or constructor 'r' is not defined. Maybe you want one of the following:
2018-10-20 20:37:22 -    R
2018-10-20 20:37:22 -    SR
2018-10-20 20:37:22 -    or
2018-10-20 20:37:22 -    C
2018-10-20 20:37:22 -    N
2018-10-20 20:37:32 - let AddChildFromTwoParents (parent1:VariableArray<int>) (parent2:VariableArray<int>) (cpt:VariableArray<VariableArray<Vector>, Vector[][]>) = 
2018-10-20 20:37:32 -     let r = parent1.Range
2018-10-20 20:37:32 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-20 20:37:32 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:Variable<int>) ->  
2018-10-20 20:37:32 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:Variable<int>) ->  
2018-10-20 20:37:32 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-20 20:37:32 -     child
2018-10-20 20:37:32 -         
2018-10-20 20:39:04 - let AddChildFromTwoParents (parent1:VariableArray<int>) (parent2:VariableArray<int>) (cpt:VariableArray<VariableArray<Vector>, Vector[][]>) = 
2018-10-20 20:39:04 -     let r = parent1.Range
2018-10-20 20:39:04 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-20 20:39:04 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:Variable<int>) ->  
2018-10-20 20:39:04 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:Variable<int>) ->  
2018-10-20 20:39:04 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-20 20:39:04 -     child
2018-10-20 20:39:04 -         
2018-10-20 20:43:06 - let Sprinkler:VariableArray<int> = (AddChildFromOneParent Cloudy CPTSprinkler).Named("Sprinkler")
2018-10-20 20:43:06 - let Rain:VariableArray<int> = (AddChildFromOneParent Cloudy CPTRain).Named("Rain")
2018-10-20 20:43:06 - let WetGrass:VariableArray<int> = (AddChildFromTwoParents Sprinkler Rain CPTWetGrass).Named("WetGrass")
2018-10-20 20:43:06 - Expression evaluation failed: Sprinkler[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-20 20:43:06 - ArgumentExceptionSprinkler[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-20 20:43:06 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange (System.Boolean throwIfMissing) [0x00022] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:43:06 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange () [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:43:06 -   at Microsoft.ML.Probabilistic.Models.Variable.Switch (Microsoft.ML.Probabilistic.Models.Variable`1[T] i) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:43:06 -   at FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x00000] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:43:06 -   at FSI_0112+AddChildFromTwoParents@3-3.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x0002d] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:43:06 -   at FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:43:06 -   at FSI_0112.AddChildFromTwoParents (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent1, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent2, Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray] cpt) [0x0001a] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:43:06 -   at <StartupCode$FSI_0113>.$FSI_0113.main@ () [0x0004b] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:43:06 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-20 20:43:06 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-20 20:44:56 - let CPTSprinklerPrior = Variable.Array<Dirichlet>(C).Named("CPTSprinklerPrior")
2018-10-20 20:44:56 - let CPTSprinkler = Variable.Array<Vector>(C).Named("CPTSprinkler")
2018-10-20 20:45:00 - CPTSprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior.[C]))
2018-10-20 20:45:03 - let CPTRainPrior = Variable.Array<Dirichlet>(C).Named("CPTRainPrior")
2018-10-20 20:45:03 - let CPTRain = Variable.Array<Vector>(C).Named("CPTRain")
2018-10-20 20:45:04 - CPTRain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTRainPrior.[C]))
2018-10-20 20:45:07 - let CPTWetGrassPrior= 
2018-10-20 20:45:07 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-20 20:45:07 -         Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-20 20:45:07 - let CPTWetGrass = 
2018-10-20 20:45:07 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-20 20:45:07 -         Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-20 20:45:08 - CPTWetGrass.[S].[R].SetTo(Variable<Vector>.Random<Dirichlet>(CPTWetGrassPrior.[S].[R]))
2018-10-20 20:45:08 - CPTWetGrass.SetValueRange(W)
2018-10-20 20:45:11 - let Cloudy = Variable.Array<int>(N).Named("Cloudy")
2018-10-20 20:45:11 - Cloudy.[N].SetTo(Variable.Discrete(ProbCloudy).ForEach(N))
2018-10-20 20:45:11 - Expression evaluation failed: Range 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-20 20:45:11 - InvalidOperationExceptionRange 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-20 20:45:11 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0008f] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:45:11 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:45:11 -   at Microsoft.ML.Probabilistic.Models.VariableArray`1[T]..ctor (Microsoft.ML.Probabilistic.Models.Range range) [0x00006] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:45:11 -   at Microsoft.ML.Probabilistic.Models.Variable.Array[T] (Microsoft.ML.Probabilistic.Models.Range r) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:45:11 -   at <StartupCode$FSI_0123>.$FSI_0123.main@ () [0x00005] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:45:11 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-20 20:45:11 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-20 20:45:27 - let NumberOfExamples = Variable.New<int>().Named("NofE")
2018-10-20 20:45:27 - let N = Range(NumberOfExamples).Named("N")
2018-10-20 20:45:30 - let C = Range(2).Named("C") // Cloudy
2018-10-20 20:45:30 - let S = Range(2).Named("S") // Sprinkler
2018-10-20 20:45:30 - let R = Range(2).Named("R") // Rain
2018-10-20 20:45:30 - let W = Range(2).Named("W") // Wet
2018-10-20 20:45:35 - let ProbCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("ProbCloudyPrior")
2018-10-20 20:45:35 - let ProbCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(ProbCloudyPrior).Named("ProbCloudy")
2018-10-20 20:45:35 - ProbCloudy.SetValueRange(C)
2018-10-20 20:45:37 - let CPTSprinklerPrior = Variable.Array<Dirichlet>(C).Named("CPTSprinklerPrior")
2018-10-20 20:45:37 - let CPTSprinkler = Variable.Array<Vector>(C).Named("CPTSprinkler")
2018-10-20 20:45:40 - CPTSprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior.[C]))
2018-10-20 20:45:41 - let CPTRainPrior = Variable.Array<Dirichlet>(C).Named("CPTRainPrior")
2018-10-20 20:45:41 - let CPTRain = Variable.Array<Vector>(C).Named("CPTRain")
2018-10-20 20:45:42 - CPTRain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTRainPrior.[C]))
2018-10-20 20:45:43 - let CPTWetGrassPrior= 
2018-10-20 20:45:43 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-20 20:45:43 -         Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-20 20:45:43 - let CPTWetGrass = 
2018-10-20 20:45:43 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-20 20:45:43 -         Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-20 20:45:48 - CPTWetGrass.[S].[R].SetTo(Variable<Vector>.Random<Dirichlet>(CPTWetGrassPrior.[S].[R]))
2018-10-20 20:45:48 - CPTWetGrass.SetValueRange(W)
2018-10-20 20:45:48 - let Cloudy = Variable.Array<int>(N).Named("Cloudy")
2018-10-20 20:45:48 - Cloudy.[N].SetTo(Variable.Discrete(ProbCloudy).ForEach(N))
2018-10-20 20:45:51 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-20 20:45:51 -     let r = parent.Range
2018-10-20 20:45:51 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-20 20:45:51 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:Variable<int>) ->  
2018-10-20 20:45:51 -                        Variable.Discrete(cpt.[pi])))
2018-10-20 20:45:51 -     child
2018-10-20 20:45:56 - let AddChildFromTwoParents (parent1:VariableArray<int>) (parent2:VariableArray<int>) (cpt:VariableArray<VariableArray<Vector>, Vector[][]>) = 
2018-10-20 20:45:56 -     let r = parent1.Range
2018-10-20 20:45:56 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-20 20:45:56 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:Variable<int>) ->  
2018-10-20 20:45:56 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:Variable<int>) ->  
2018-10-20 20:45:56 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-20 20:45:56 -     child
2018-10-20 20:45:56 -         
2018-10-20 20:45:59 - let Sprinkler:VariableArray<int> = (AddChildFromOneParent Cloudy CPTSprinkler).Named("Sprinkler")
2018-10-20 20:45:59 - let Rain:VariableArray<int> = (AddChildFromOneParent Cloudy CPTRain).Named("Rain")
2018-10-20 20:45:59 - let WetGrass:VariableArray<int> = (AddChildFromTwoParents Sprinkler Rain CPTWetGrass).Named("WetGrass")
2018-10-20 20:45:59 - Expression evaluation failed: Sprinkler[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-20 20:45:59 - ArgumentExceptionSprinkler[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-20 20:45:59 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange (System.Boolean throwIfMissing) [0x00022] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:45:59 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange () [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:45:59 -   at Microsoft.ML.Probabilistic.Models.Variable.Switch (Microsoft.ML.Probabilistic.Models.Variable`1[T] i) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:45:59 -   at FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x00000] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:45:59 -   at FSI_0140+AddChildFromTwoParents@3-6.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x0002d] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:45:59 -   at FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:45:59 -   at FSI_0140.AddChildFromTwoParents (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent1, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent2, Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray] cpt) [0x0001a] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:45:59 -   at <StartupCode$FSI_0141>.$FSI_0141.main@ () [0x0004b] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:45:59 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-20 20:45:59 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-20 20:47:05 - CPTSprinkler.SetValueRange(S)
2018-10-20 20:47:36 - let Sprinkler:VariableArray<int> = (AddChildFromOneParent Cloudy CPTSprinkler).Named("Sprinkler")
2018-10-20 20:47:36 - let Rain:VariableArray<int> = (AddChildFromOneParent Cloudy CPTRain).Named("Rain")
2018-10-20 20:47:36 - let WetGrass:VariableArray<int> = (AddChildFromTwoParents Sprinkler Rain CPTWetGrass).Named("WetGrass")
2018-10-20 20:47:36 - Expression evaluation failed: Range 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-20 20:47:36 - InvalidOperationExceptionRange 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-20 20:47:36 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0008f] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:47:36 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:47:36 -   at Microsoft.ML.Probabilistic.Models.VariableArray`1[T]..ctor (Microsoft.ML.Probabilistic.Models.Range range) [0x00006] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:47:36 -   at Microsoft.ML.Probabilistic.Models.Variable.Array[T] (Microsoft.ML.Probabilistic.Models.Range r) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:47:36 -   at FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00000] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:47:36 -   at FSI_0139.AddChildFromOneParent (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] cpt) [0x00016] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:47:36 -   at <StartupCode$FSI_0144>.$FSI_0144.main@ () [0x0000a] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:47:36 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-20 20:47:36 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-20 20:47:44 - let NumberOfExamples = Variable.New<int>().Named("NofE")
2018-10-20 20:47:44 - let N = Range(NumberOfExamples).Named("N")
2018-10-20 20:47:49 - let C = Range(2).Named("C") // Cloudy
2018-10-20 20:47:49 - let S = Range(2).Named("S") // Sprinkler
2018-10-20 20:47:49 - let R = Range(2).Named("R") // Rain
2018-10-20 20:47:49 - let W = Range(2).Named("W") // Wet
2018-10-20 20:47:50 - let ProbCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("ProbCloudyPrior")
2018-10-20 20:47:50 - let ProbCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(ProbCloudyPrior).Named("ProbCloudy")
2018-10-20 20:47:50 - ProbCloudy.SetValueRange(C)
2018-10-20 20:47:50 - let CPTSprinklerPrior = Variable.Array<Dirichlet>(C).Named("CPTSprinklerPrior")
2018-10-20 20:47:50 - let CPTSprinkler = Variable.Array<Vector>(C).Named("CPTSprinkler")
2018-10-20 20:47:51 - CPTSprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior.[C]))
2018-10-20 20:47:51 - CPTSprinkler.SetValueRange(S)
2018-10-20 20:47:52 - let CPTRainPrior = Variable.Array<Dirichlet>(C).Named("CPTRainPrior")
2018-10-20 20:47:52 - let CPTRain = Variable.Array<Vector>(C).Named("CPTRain")
2018-10-20 20:47:52 - CPTRain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTRainPrior.[C]))
2018-10-20 20:47:52 - let CPTWetGrassPrior= 
2018-10-20 20:47:52 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-20 20:47:52 -         Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-20 20:47:52 - let CPTWetGrass = 
2018-10-20 20:47:52 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-20 20:47:52 -         Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-20 20:47:52 - CPTWetGrass.[S].[R].SetTo(Variable<Vector>.Random<Dirichlet>(CPTWetGrassPrior.[S].[R]))
2018-10-20 20:47:52 - CPTWetGrass.SetValueRange(W)
2018-10-20 20:47:53 - let Cloudy = Variable.Array<int>(N).Named("Cloudy")
2018-10-20 20:47:53 - Cloudy.[N].SetTo(Variable.Discrete(ProbCloudy).ForEach(N))
2018-10-20 20:47:55 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-20 20:47:55 -     let r = parent.Range
2018-10-20 20:47:55 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-20 20:47:55 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:Variable<int>) ->  
2018-10-20 20:47:55 -                        Variable.Discrete(cpt.[pi])))
2018-10-20 20:47:55 -     child
2018-10-20 20:47:57 - let AddChildFromTwoParents (parent1:VariableArray<int>) (parent2:VariableArray<int>) (cpt:VariableArray<VariableArray<Vector>, Vector[][]>) = 
2018-10-20 20:47:57 -     let r = parent1.Range
2018-10-20 20:47:57 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-20 20:47:57 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:Variable<int>) ->  
2018-10-20 20:47:57 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:Variable<int>) ->  
2018-10-20 20:47:57 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-20 20:47:57 -     child
2018-10-20 20:47:57 -         
2018-10-20 20:48:00 - let Sprinkler:VariableArray<int> = (AddChildFromOneParent Cloudy CPTSprinkler).Named("Sprinkler")
2018-10-20 20:48:00 - let Rain:VariableArray<int> = (AddChildFromOneParent Cloudy CPTRain).Named("Rain")
2018-10-20 20:48:00 - let WetGrass:VariableArray<int> = (AddChildFromTwoParents Sprinkler Rain CPTWetGrass).Named("WetGrass")
2018-10-20 20:48:00 - Expression evaluation failed: Rain[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-20 20:48:00 - ArgumentExceptionRain[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-20 20:48:00 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange (System.Boolean throwIfMissing) [0x00022] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:48:00 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange () [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:48:00 -   at Microsoft.ML.Probabilistic.Models.Variable.Switch (Microsoft.ML.Probabilistic.Models.Variable`1[T] i) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:48:00 -   at FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x00000] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:48:00 -   at FSI_0163+AddChildFromTwoParents@4-10.Invoke (Microsoft.ML.Probabilistic.Models.Variable`1[T] pi1) [0x00029] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:48:00 -   at FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x0000d] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:48:00 -   at FSI_0163+AddChildFromTwoParents@3-9.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x0002d] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:48:00 -   at FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:48:00 -   at FSI_0163.AddChildFromTwoParents (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent1, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent2, Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray] cpt) [0x0001a] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:48:00 -   at <StartupCode$FSI_0164>.$FSI_0164.main@ () [0x0004b] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:48:00 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-20 20:48:00 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-20 20:48:26 - CPTRain.SetValueRange(R)
2018-10-20 20:48:32 - let Sprinkler:VariableArray<int> = (AddChildFromOneParent Cloudy CPTSprinkler).Named("Sprinkler")
2018-10-20 20:48:32 - let Rain:VariableArray<int> = (AddChildFromOneParent Cloudy CPTRain).Named("Rain")
2018-10-20 20:48:32 - let WetGrass:VariableArray<int> = (AddChildFromTwoParents Sprinkler Rain CPTWetGrass).Named("WetGrass")
2018-10-20 20:48:32 - Expression evaluation failed: Range 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-20 20:48:32 - InvalidOperationExceptionRange 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-20 20:48:32 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0008f] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:48:32 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:48:32 -   at Microsoft.ML.Probabilistic.Models.VariableArray`1[T]..ctor (Microsoft.ML.Probabilistic.Models.Range range) [0x00006] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:48:32 -   at Microsoft.ML.Probabilistic.Models.Variable.Array[T] (Microsoft.ML.Probabilistic.Models.Range r) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-20 20:48:32 -   at FSI_0013.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00000] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:48:32 -   at FSI_0162.AddChildFromOneParent (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] cpt) [0x00016] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:48:32 -   at <StartupCode$FSI_0167>.$FSI_0167.main@ () [0x0000a] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-20 20:48:32 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-20 20:48:32 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-20 20:49:08 - Reporting 0 opened comms
2018-10-20 20:50:38 - Reporting 0 opened comms
2018-10-20 20:51:28 - let engine =  InferenceEngine ()
2018-10-20 20:51:29 - let NumberOfExamples = Variable.New<int>().Named("NofE")
2018-10-20 20:51:29 - let N = Range(NumberOfExamples).Named("N")
2018-10-20 20:51:29 - let C = Range(2).Named("C") // Cloudy
2018-10-20 20:51:29 - let S = Range(2).Named("S") // Sprinkler
2018-10-20 20:51:29 - let R = Range(2).Named("R") // Rain
2018-10-20 20:51:29 - let W = Range(2).Named("W") // Wet
2018-10-20 20:51:29 - let ProbCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("ProbCloudyPrior")
2018-10-20 20:51:29 - let ProbCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(ProbCloudyPrior).Named("ProbCloudy")
2018-10-20 20:51:29 - ProbCloudy.SetValueRange(C)
2018-10-20 20:51:30 - let CPTSprinklerPrior = Variable.Array<Dirichlet>(C).Named("CPTSprinklerPrior")
2018-10-20 20:51:30 - let CPTSprinkler = Variable.Array<Vector>(C).Named("CPTSprinkler")
2018-10-20 20:51:30 - CPTSprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior.[C]))
2018-10-20 20:51:30 - CPTSprinkler.SetValueRange(S)
2018-10-20 20:51:30 - let CPTRainPrior = Variable.Array<Dirichlet>(C).Named("CPTRainPrior")
2018-10-20 20:51:30 - let CPTRain = Variable.Array<Vector>(C).Named("CPTRain")
2018-10-20 20:51:31 - CPTRain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTRainPrior.[C]))
2018-10-20 20:51:31 - CPTRain.SetValueRange(R)
2018-10-20 20:51:31 - let CPTWetGrassPrior= 
2018-10-20 20:51:31 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-20 20:51:31 -         Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-20 20:51:31 - let CPTWetGrass = 
2018-10-20 20:51:31 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-20 20:51:31 -         Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-20 20:51:31 - CPTWetGrass.[S].[R].SetTo(Variable<Vector>.Random<Dirichlet>(CPTWetGrassPrior.[S].[R]))
2018-10-20 20:51:31 - CPTWetGrass.SetValueRange(W)
2018-10-20 20:51:32 - let Cloudy = Variable.Array<int>(N).Named("Cloudy")
2018-10-20 20:51:32 - Cloudy.[N].SetTo(Variable.Discrete(ProbCloudy).ForEach(N))
2018-10-20 20:51:32 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-20 20:51:32 -     let r = parent.Range
2018-10-20 20:51:32 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-20 20:51:32 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:Variable<int>) ->  
2018-10-20 20:51:32 -                        Variable.Discrete(cpt.[pi])))
2018-10-20 20:51:32 -     child
2018-10-20 20:51:32 - let AddChildFromTwoParents (parent1:VariableArray<int>) (parent2:VariableArray<int>) (cpt:VariableArray<VariableArray<Vector>, Vector[][]>) = 
2018-10-20 20:51:32 -     let r = parent1.Range
2018-10-20 20:51:32 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-20 20:51:32 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:Variable<int>) ->  
2018-10-20 20:51:32 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:Variable<int>) ->  
2018-10-20 20:51:32 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-20 20:51:32 -     child
2018-10-20 20:51:32 -         
2018-10-20 20:51:36 - let Sprinkler:VariableArray<int> = (AddChildFromOneParent Cloudy CPTSprinkler).Named("Sprinkler")
2018-10-20 20:51:36 - let Rain:VariableArray<int> = (AddChildFromOneParent Cloudy CPTRain).Named("Rain")
2018-10-20 20:51:36 - let WetGrass:VariableArray<int> = (AddChildFromTwoParents Sprinkler Rain CPTWetGrass).Named("WetGrass")
2018-10-20 21:01:22 - let LearnParameters cloudy:int[] 
2018-10-20 21:01:22 -                         sprinkler:int[] 
2018-10-20 21:01:22 -                         rain:int[] 
2018-10-20 21:01:22 -                         wetgrass:int[] 
2018-10-20 21:01:22 -                         probCloudyPrior:Dirichlet 
2018-10-20 21:01:22 -                         cptSprinklerPrior:Dirichlet[] 
2018-10-20 21:01:22 -                         cptRainPrior:Dirichlet[] 
2018-10-20 21:01:22 -                         cptWetGrassPrior:Dirichlet[][] =
2018-10-20 21:01:22 -     ()
2018-10-20 21:01:23 - Syntax error in labelled type argument
2018-10-20 21:02:01 - let LearnParameters (cloudy:int[])
2018-10-20 21:02:01 -                         (sprinkler:int[] )
2018-10-20 21:02:01 -                         (rain:int[] )
2018-10-20 21:02:01 -                         (wetgrass:int[] )
2018-10-20 21:02:01 -                         (probCloudyPrior:Dirichlet) 
2018-10-20 21:02:01 -                         (cptSprinklerPrior:Dirichlet[] )
2018-10-20 21:02:01 -                         (cptRainPrior:Dirichlet[] )
2018-10-20 21:02:01 -                         (cptWetGrassPrior:Dirichlet[][]) =
2018-10-20 21:02:01 -     ()
2018-10-20 21:02:11 - let LearnParameters (cloudy:int[])
2018-10-20 21:02:11 -                     (sprinkler:int[] )
2018-10-20 21:02:11 -                     (rain:int[] )
2018-10-20 21:02:11 -                     (wetgrass:int[] )
2018-10-20 21:02:11 -                     (probCloudyPrior:Dirichlet) 
2018-10-20 21:02:11 -                     (cptSprinklerPrior:Dirichlet[] )
2018-10-20 21:02:11 -                     (cptRainPrior:Dirichlet[] )
2018-10-20 21:02:11 -                     (cptWetGrassPrior:Dirichlet[][]) =
2018-10-20 21:02:11 -     ()
2018-10-20 21:06:30 - #### `LearnParameters`
2018-10-20 21:06:30 - Unexpected symbol # in directive. Expected identifier or other token.
2018-10-20 21:06:30 - parse error
2018-10-22 16:17:04 - type CSRWPosterior = {probCloudyPosterior:Dirichlet;  cptSprinklerPosterior:Dirichlet[];  cptRainPosterior:Dirichlet[];  cptWetGrassPosterior:Dirichlet[][];}
2018-10-22 17:26:22 - #load "Paket.fsx"
2018-10-22 17:26:31 - Paket.Package
2018-10-22 17:26:31 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-22 17:26:31 -       "Microsoft.ML.Probabilistic"
2018-10-22 17:26:31 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-22 17:26:31 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-22 17:26:31 -       "NETStandard.Library"
2018-10-22 17:26:31 -   ]
2018-10-22 17:26:56 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-22 17:26:58 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-22 17:27:17 - //#load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-22 17:27:17 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-22 17:27:17 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-22 17:27:17 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-22 17:27:17 - #r "Microsoft.ML.Probabilistic"
2018-10-22 17:27:17 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-22 17:27:17 - #r "netstandard"
2018-10-22 17:27:18 - open System
2018-10-22 17:27:18 - open Microsoft.ML.Probabilistic  
2018-10-22 17:27:18 - open Microsoft.ML.Probabilistic.Models  
2018-10-22 17:27:18 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-22 17:27:18 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-22 17:27:18 - open Microsoft.ML.Probabilistic.Math
2018-10-22 17:27:18 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-22 17:27:20 - open Microsoft.ML.Probabilistic.FSharp
2018-10-22 17:27:21 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-22 17:27:21 -     let r = parent.Range
2018-10-22 17:27:21 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-22 17:27:21 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:Variable<int>) ->  
2018-10-22 17:27:21 -                        Variable.Discrete(cpt.[pi])))
2018-10-22 17:27:21 -     child
2018-10-22 17:27:21 - let AddChildFromTwoParents (parent1:VariableArray<int>) (parent2:VariableArray<int>) (cpt:VariableArray<VariableArray<Vector>, Vector[][]>) = 
2018-10-22 17:27:21 -     let r = parent1.Range
2018-10-22 17:27:21 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-22 17:27:21 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:Variable<int>) ->  
2018-10-22 17:27:21 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:Variable<int>) ->  
2018-10-22 17:27:21 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-22 17:27:21 -     child
2018-10-22 17:27:21 -         
2018-10-22 17:27:23 - let engine =  InferenceEngine ()
2018-10-22 17:27:24 - let NumberOfExamples = Variable.New<int>().Named("NofE")
2018-10-22 17:27:24 - let N = Range(NumberOfExamples).Named("N")
2018-10-22 17:27:24 - let C = Range(2).Named("C") // Cloudy
2018-10-22 17:27:24 - let S = Range(2).Named("S") // Sprinkler
2018-10-22 17:27:24 - let R = Range(2).Named("R") // Rain
2018-10-22 17:27:24 - let W = Range(2).Named("W") // Wet
2018-10-22 17:27:24 - type CSRWPosterior = {probCloudyPosterior:Dirichlet;  cptSprinklerPosterior:Dirichlet[];  cptRainPosterior:Dirichlet[];  cptWetGrassPosterior:Dirichlet[][];}
2018-10-22 17:34:38 - ### More methods: `learnParameters` etc.
2018-10-22 17:34:39 - Unexpected symbol # in directive. Expected identifier or other token.
2018-10-22 17:34:39 - parse error
2018-10-22 17:48:58 - type PrimaryRandomVariables =
2018-10-22 17:48:58 -     {cloudy:VariableArray<int>;
2018-10-22 17:48:58 -     sprinkler:VariableArray<int>;
2018-10-22 17:48:58 -     rain:VariableArray<int>;
2018-10-22 17:48:58 -     wetGrass:VariableArray<int>;
2018-10-22 17:48:58 -     }
2018-10-22 17:51:57 - type PrimaryRandomVariables =
2018-10-22 17:51:57 -     {cloudy:VariableArray<int>;
2018-10-22 17:51:57 -     sprinkler:VariableArray<int>;
2018-10-22 17:51:57 -     rain:VariableArray<int>;
2018-10-22 17:51:57 -     wetGrass:VariableArray<int> }
2018-10-22 17:52:04 - type DistributionParameters =
2018-10-22 17:52:04 -     {probCloudy:Variable<Vector> ;
2018-10-22 17:52:04 -     cptSprinkler:VariableArray<Vector> ;
2018-10-22 17:52:04 -     cptRain:VariableArray<Vector> ;
2018-10-22 17:52:04 -     cptWetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-22 17:54:37 - type PriorDistributions =
2018-10-22 17:54:37 -     {probCloudyPrior:Variable<Dirichlet> ;
2018-10-22 17:54:37 -     cptSprinklerPrior:VariableArray<Dirichlet> ;
2018-10-22 17:54:37 -     cptRainPrior:VariableArray<Dirichlet> ;
2018-10-22 17:54:37 -     cptWetGrassPrior:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-22 17:56:18 - type PosteriorDistributions =
2018-10-22 17:56:18 -     {probCloudyPosterior:Dirichlet ;
2018-10-22 17:56:18 -     cptSprinklerPosterior:Dirichlet[] ;
2018-10-22 17:56:18 -     cptRainPosterior:Dirichlet[] ;
2018-10-22 17:56:18 -     cptWetGrassPosterior:Dirichlet[][] }
2018-10-22 18:01:08 - type Ranges = {c:Range;s:Range;r:Range;w:Range}
2018-10-22 18:04:26 - let ranges = {c=Range(2).Named("C");s=Range(2).Named("S");r=Range(2).Named("R");w=Range(2).Named("W")}
2018-10-22 18:05:29 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-22 18:05:29 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-22 18:05:29 - probCloudy.SetValueRange(C)
2018-10-22 18:05:53 - let cptSprinklerPrior = Variable.Array<Dirichlet>(C).Named("cptSprinklerPrior")
2018-10-22 18:05:53 - let cptSprinkler = Variable.Array<Vector>(C).Named("cptSprinkler")
2018-10-22 18:06:10 - cptSprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior.[C]))
2018-10-22 18:06:11 - Expression evaluation failed: VariableArray<Dirichlet> CPTSprinklerPrior cannot be indexed by C. Perhaps you omitted C as an argument to the constructor?
2018-10-22 18:06:11 - Parameter name: index
2018-10-22 18:06:11 - ArgumentExceptionVariableArray<Dirichlet> CPTSprinklerPrior cannot be indexed by C. Perhaps you omitted C as an argument to the constructor?
2018-10-22 18:06:11 - Parameter name: index
2018-10-22 18:06:11 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 18:06:11 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 18:06:11 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 18:06:11 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 18:06:11 -   at <StartupCode$FSI_0221>.$FSI_0221.main@ () [0x00019] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-22 18:06:11 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-22 18:06:11 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-22 18:06:11 - cptSprinkler.SetValueRange(S)
2018-10-22 18:06:22 - cptSprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[C]))
2018-10-22 18:06:54 - let cptRainPrior = Variable.Array<Dirichlet>(C).Named("cptRainPrior")
2018-10-22 18:06:54 - let cptRain = Variable.Array<Vector>(C).Named("cptRain")
2018-10-22 18:06:55 - cptRain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(cptRainPrior.[C]))
2018-10-22 18:06:55 - cptRain.SetValueRange(R)
2018-10-22 18:08:21 - let cptWetGrassPrior= 
2018-10-22 18:08:21 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-22 18:08:21 -         Variable.Array<Dirichlet>(R), S).Named("cptWetGrassPrior")
2018-10-22 18:08:21 - let cptWetGrass = 
2018-10-22 18:08:21 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-22 18:08:21 -         Variable.Array<Vector>(R), S).Named("cptWetGrass")
2018-10-22 18:08:32 - cptWetGrass.[S].[R].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[S].[R]))
2018-10-22 18:08:32 - cptWetGrass.SetValueRange(W)
2018-10-22 18:08:50 - let cloudy = Variable.Array<int>(N).Named("Cloudy")
2018-10-22 18:08:50 - cloudy.[N].SetTo(Variable.Discrete(probCloudy).ForEach(N))
2018-10-22 18:15:59 - let sprinkler:VariableArray<int> = (AddChildFromOneParent Cloudy CPTSprinkler).Named("Sprinkler")
2018-10-22 18:15:59 - let rain:VariableArray<int> = (AddChildFromOneParent Cloudy CPTRain).Named("Rain")
2018-10-22 18:15:59 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents Sprinkler Rain CPTWetGrass).Named("WetGrass")
2018-10-22 18:29:36 - type PrimaryObservedValues =
2018-10-22 18:29:36 -     {cloudyValues:array<int>;
2018-10-22 18:29:36 -     sprinklerValues:array<int>;
2018-10-22 18:29:36 -     rainValues:array<int>;
2018-10-22 18:29:36 -     wetGrassValues:array<int> }
2018-10-22 18:29:52 - type RandomVariables =
2018-10-22 18:29:52 -     {cloudy:VariableArray<int>;
2018-10-22 18:29:52 -     sprinkler:VariableArray<int>;
2018-10-22 18:29:52 -     rain:VariableArray<int>;
2018-10-22 18:29:52 -     wetGrass:VariableArray<int> }
2018-10-22 18:29:54 - type ObservedValues =
2018-10-22 18:29:54 -     {cloudyValues:array<int>;
2018-10-22 18:29:54 -     sprinklerValues:array<int>;
2018-10-22 18:29:54 -     rainValues:array<int>;
2018-10-22 18:29:54 -     wetGrassValues:array<int> }
2018-10-22 18:30:54 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("Sprinkler")
2018-10-22 18:30:54 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("Rain")
2018-10-22 18:30:54 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("WetGrass")
2018-10-22 18:31:17 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("sprinkler")
2018-10-22 18:31:17 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("rain")
2018-10-22 18:31:17 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("wetGrass")
2018-10-22 18:45:09 - type RandomVariables =
2018-10-22 18:45:09 -     {cloudy:VariableArray<int>;
2018-10-22 18:45:09 -     sprinkler:VariableArray<int>;
2018-10-22 18:45:09 -     rain:VariableArray<int>;
2018-10-22 18:45:09 -     wetGrass:VariableArray<int> }
2018-10-22 18:45:09 - type ObservedValues =
2018-10-22 18:45:09 -     {cloudy:array<int>;
2018-10-22 18:45:09 -     sprinkler:array<int>;
2018-10-22 18:45:09 -     rain:array<int>;
2018-10-22 18:45:09 -     wetGrass:array<int> }
2018-10-22 18:45:10 - type DistributionParameters =
2018-10-22 18:45:10 -     {cloudy:Variable<Vector> ;
2018-10-22 18:45:10 -     sprinkler:VariableArray<Vector> ;
2018-10-22 18:45:10 -     rain:VariableArray<Vector> ;
2018-10-22 18:45:10 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-22 18:45:12 - type PriorDistributions =
2018-10-22 18:45:12 -     {cloudy:Variable<Dirichlet> ;
2018-10-22 18:45:12 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-22 18:45:12 -     rain:VariableArray<Dirichlet> ;
2018-10-22 18:45:12 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-22 18:45:20 - type PosteriorDistributions =
2018-10-22 18:45:20 -     {cloudy:Dirichlet ;
2018-10-22 18:45:20 -         sprinkler:Dirichlet[] ;
2018-10-22 18:45:20 -         rain:Dirichlet[] ;
2018-10-22 18:45:20 -         wetGrass:Dirichlet[][] }
2018-10-22 18:46:03 - let ranges = {c=Range(2).Named("c");s=Range(2).Named("s");r=Range(2).Named("r");w=Range(2).Named("w")}
2018-10-22 18:59:04 - let priorProbabilities:PriorProbabilities =
2018-10-22 18:59:04 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-22 18:59:04 -     sprinkler= Variable.Array<Dirichlet>(C).Named("cptSprinklerPrior") ;
2018-10-22 18:59:04 -     rain= Variable.Array<Dirichlet>(C).Named("cptRainPrior");
2018-10-22 18:59:04 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-22 18:59:04 -         Variable.Array<Dirichlet>(R), S).Named("cptWetGrassPrior")}
2018-10-22 18:59:04 - Possible incorrect indentation: this token is offside of context started at position (5:70). Try indenting this token further or using standard formatting conventions.
2018-10-22 18:59:04 - Possible incorrect indentation: this token is offside of context started at position (5:70). Try indenting this token further or using standard formatting conventions.
2018-10-22 18:59:04 - The type 'PriorProbabilities' is not defined. Maybe you want one of the following:
2018-10-22 18:59:04 -    PriorDistributions
2018-10-22 18:59:04 -    CharFromProbabilitiesOp
2018-10-22 18:59:04 -    PrimaryRandomVariables
2018-10-22 18:59:04 - The type 'Variable<Dirichlet>' is not compatible with the type 'Dirichlet'
2018-10-22 18:59:04 - This expression was expected to have type
2018-10-22 18:59:04 -     'Dirichlet []'    
2018-10-22 18:59:04 - but here has type
2018-10-22 18:59:04 -     'VariableArray<Dirichlet>'    
2018-10-22 18:59:04 - This expression was expected to have type
2018-10-22 18:59:04 -     'Dirichlet []'    
2018-10-22 18:59:04 - but here has type
2018-10-22 18:59:04 -     'VariableArray<Dirichlet>'    
2018-10-22 18:59:04 - This expression was expected to have type
2018-10-22 18:59:04 -     'Dirichlet [] []'    
2018-10-22 18:59:04 - but here has type
2018-10-22 18:59:04 -     'VariableArray<VariableArray<Dirichlet>,Dirichlet [] []>'    
2018-10-22 18:59:41 - let distributionParameters:DistributionParameters =
2018-10-22 18:59:41 -     {cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-22 18:59:41 -     sprinkler= Variable.Array<Vector>(C).Named("cptSprinkler") ;
2018-10-22 18:59:41 -     rain= Variable.Array<Vector>(C).Named("cptRain");
2018-10-22 18:59:41 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-22 18:59:41 -         Variable.Array<Vector>(R), S).Named("cptWetGrass")}
2018-10-22 18:59:42 - Possible incorrect indentation: this token is offside of context started at position (5:64). Try indenting this token further or using standard formatting conventions.
2018-10-22 18:59:42 - Possible incorrect indentation: this token is offside of context started at position (5:64). Try indenting this token further or using standard formatting conventions.
2018-10-22 19:00:06 - let priorProbabilities:PriorProbabilities =
2018-10-22 19:00:06 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-22 19:00:06 -     sprinkler= Variable.Array<Dirichlet>(C).Named("cptSprinklerPrior") ;
2018-10-22 19:00:06 -     rain= Variable.Array<Dirichlet>(C).Named("cptRainPrior");
2018-10-22 19:00:06 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-22 19:00:06 -                     Variable.Array<Dirichlet>(R), S).Named("cptWetGrassPrior")}
2018-10-22 19:00:07 - Possible incorrect indentation: this token is offside of context started at position (5:70). Try indenting this token further or using standard formatting conventions.
2018-10-22 19:00:07 - Possible incorrect indentation: this token is offside of context started at position (5:70). Try indenting this token further or using standard formatting conventions.
2018-10-22 19:00:07 - The type 'PriorProbabilities' is not defined. Maybe you want one of the following:
2018-10-22 19:00:07 -    PriorDistributions
2018-10-22 19:00:07 -    CharFromProbabilitiesOp
2018-10-22 19:00:07 -    PrimaryRandomVariables
2018-10-22 19:00:07 - The type 'Variable<Dirichlet>' is not compatible with the type 'Dirichlet'
2018-10-22 19:00:07 - This expression was expected to have type
2018-10-22 19:00:07 -     'Dirichlet []'    
2018-10-22 19:00:07 - but here has type
2018-10-22 19:00:07 -     'VariableArray<Dirichlet>'    
2018-10-22 19:00:07 - This expression was expected to have type
2018-10-22 19:00:07 -     'Dirichlet []'    
2018-10-22 19:00:07 - but here has type
2018-10-22 19:00:07 -     'VariableArray<Dirichlet>'    
2018-10-22 19:00:07 - This expression was expected to have type
2018-10-22 19:00:07 -     'Dirichlet [] []'    
2018-10-22 19:00:07 - but here has type
2018-10-22 19:00:07 -     'VariableArray<VariableArray<Dirichlet>,Dirichlet [] []>'    
2018-10-22 19:00:14 - let distributionParameters:DistributionParameters =
2018-10-22 19:00:14 -     {cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-22 19:00:14 -     sprinkler= Variable.Array<Vector>(C).Named("cptSprinkler") ;
2018-10-22 19:00:14 -     rain= Variable.Array<Vector>(C).Named("cptRain");
2018-10-22 19:00:14 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-22 19:00:14 -                 Variable.Array<Vector>(R), S).Named("cptWetGrass")}
2018-10-22 19:00:15 - Possible incorrect indentation: this token is offside of context started at position (5:64). Try indenting this token further or using standard formatting conventions.
2018-10-22 19:00:15 - Possible incorrect indentation: this token is offside of context started at position (5:64). Try indenting this token further or using standard formatting conventions.
2018-10-22 19:00:41 - let priorProbabilities:PriorProbabilities = {
2018-10-22 19:00:41 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-22 19:00:41 -     sprinkler= Variable.Array<Dirichlet>(C).Named("cptSprinklerPrior") ;
2018-10-22 19:00:41 -     rain= Variable.Array<Dirichlet>(C).Named("cptRainPrior");
2018-10-22 19:00:41 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-22 19:00:41 -                     Variable.Array<Dirichlet>(R), S).Named("cptWetGrassPrior")}
2018-10-22 19:00:42 - The type 'PriorProbabilities' is not defined. Maybe you want one of the following:
2018-10-22 19:00:42 -    PriorDistributions
2018-10-22 19:00:42 -    CharFromProbabilitiesOp
2018-10-22 19:00:42 -    PrimaryRandomVariables
2018-10-22 19:00:42 - The type 'Variable<Dirichlet>' is not compatible with the type 'Dirichlet'
2018-10-22 19:00:42 - This expression was expected to have type
2018-10-22 19:00:42 -     'Dirichlet []'    
2018-10-22 19:00:42 - but here has type
2018-10-22 19:00:42 -     'VariableArray<Dirichlet>'    
2018-10-22 19:00:42 - This expression was expected to have type
2018-10-22 19:00:42 -     'Dirichlet []'    
2018-10-22 19:00:42 - but here has type
2018-10-22 19:00:42 -     'VariableArray<Dirichlet>'    
2018-10-22 19:00:42 - This expression was expected to have type
2018-10-22 19:00:42 -     'Dirichlet [] []'    
2018-10-22 19:00:42 - but here has type
2018-10-22 19:00:42 -     'VariableArray<VariableArray<Dirichlet>,Dirichlet [] []>'    
2018-10-22 19:00:42 - let distributionParameters:DistributionParameters = {
2018-10-22 19:00:42 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-22 19:00:42 -     sprinkler= Variable.Array<Vector>(C).Named("cptSprinkler") ;
2018-10-22 19:00:42 -     rain= Variable.Array<Vector>(C).Named("cptRain");
2018-10-22 19:00:42 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-22 19:00:42 -                 Variable.Array<Vector>(R), S).Named("cptWetGrass")}
2018-10-22 19:01:38 - let priorDistributions:PriorDistributions = {
2018-10-22 19:01:38 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-22 19:01:38 -     sprinkler= Variable.Array<Dirichlet>(C).Named("cptSprinklerPrior") ;
2018-10-22 19:01:38 -     rain= Variable.Array<Dirichlet>(C).Named("cptRainPrior");
2018-10-22 19:01:38 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-22 19:01:38 -                     Variable.Array<Dirichlet>(R), S).Named("cptWetGrassPrior")}
2018-10-22 19:03:27 - distributionParameters.cloudy.SetValueRange(C)
2018-10-22 19:05:53 - distributionParameters.sprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(priorDistributions.sprinkler.[C]))
2018-10-22 19:05:53 - distributionParameters.sprinkler.SetValueRange(S)
2018-10-22 19:07:29 - distributionParameters.rain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(priorDistributions.rain.[C]))
2018-10-22 19:07:29 - distributionParameters.rain.SetValueRange(R)
2018-10-22 19:08:58 - distributionParameters.sprinkler.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priorDistributions.sprinkler.[ranges.c]))
2018-10-22 19:08:58 - distributionParameters.sprinkler.SetValueRange(ranges.s)
2018-10-22 19:08:59 - Expression evaluation failed: VariableArray<Vector> cptSprinkler cannot be indexed by c. Perhaps you omitted c as an argument to the constructor?
2018-10-22 19:08:59 - Parameter name: index
2018-10-22 19:08:59 - ArgumentExceptionVariableArray<Vector> cptSprinkler cannot be indexed by c. Perhaps you omitted c as an argument to the constructor?
2018-10-22 19:08:59 - Parameter name: index
2018-10-22 19:08:59 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:08:59 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:08:59 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:08:59 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:08:59 -   at <StartupCode$FSI_0261>.$FSI_0261.main@ () [0x0000f] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-22 19:08:59 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-22 19:08:59 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-22 19:09:25 - let ranges = {c=Range(2).Named("c");s=Range(2).Named("s");r=Range(2).Named("r");w=Range(2).Named("w")}
2018-10-22 19:09:33 - ranges
2018-10-22 19:09:54 - distributionParameters.cloudy.SetValueRange(ranges.c)
2018-10-22 19:10:59 - distributionParameters.sprinkler.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priorDistributions.sprinkler.[ranges.c]))
2018-10-22 19:10:59 - distributionParameters.sprinkler.SetValueRange(ranges.r)
2018-10-22 19:11:00 - Expression evaluation failed: VariableArray<Vector> cptSprinkler cannot be indexed by c. Perhaps you omitted c as an argument to the constructor?
2018-10-22 19:11:00 - Parameter name: index
2018-10-22 19:11:00 - ArgumentExceptionVariableArray<Vector> cptSprinkler cannot be indexed by c. Perhaps you omitted c as an argument to the constructor?
2018-10-22 19:11:00 - Parameter name: index
2018-10-22 19:11:00 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:11:00 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:11:00 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:11:00 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:11:00 -   at <StartupCode$FSI_0267>.$FSI_0267.main@ () [0x0000f] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-22 19:11:00 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-22 19:11:00 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-22 19:13:04 - distributionParameters.sprinkler.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priorDistributions.sprinkler.[ranges.c]))
2018-10-22 19:13:04 - distributionParameters.sprinkler.SetValueRange(ranges.s)
2018-10-22 19:13:04 - Expression evaluation failed: VariableArray<Vector> cptSprinkler cannot be indexed by c. Perhaps you omitted c as an argument to the constructor?
2018-10-22 19:13:04 - Parameter name: index
2018-10-22 19:13:04 - ArgumentExceptionVariableArray<Vector> cptSprinkler cannot be indexed by c. Perhaps you omitted c as an argument to the constructor?
2018-10-22 19:13:04 - Parameter name: index
2018-10-22 19:13:04 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:13:04 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:13:04 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:13:04 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:13:04 -   at <StartupCode$FSI_0268>.$FSI_0268.main@ () [0x0000f] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-22 19:13:04 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-22 19:13:04 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-22 19:14:01 - distributionParameters.sprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(priorDistributions.sprinkler.[C]))
2018-10-22 19:14:01 - distributionParameters.sprinkler.SetValueRange(S)
2018-10-22 19:14:01 - Expression evaluation failed: Cannot define a variable more than once in the same condition block context: (SwitchBlock(vint__3[index7]==index6),SwitchBlock(Sprinkler[N]==S))
2018-10-22 19:14:01 - InvalidOperationExceptionCannot define a variable more than once in the same condition block context: (SwitchBlock(vint__3[index7]==index6),SwitchBlock(Sprinkler[N]==S))
2018-10-22 19:14:01 -   at Microsoft.ML.Probabilistic.Models.Variable.SetDefinition (Microsoft.ML.Probabilistic.Models.MethodInvoke methodInvoke) [0x0003d] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:14:01 -   at Microsoft.ML.Probabilistic.Models.Variable`1[T].SetTo (Microsoft.ML.Probabilistic.Models.MethodInvoke methodInvoke) [0x00019] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:14:01 -   at Microsoft.ML.Probabilistic.Models.Variable`1[T].SetTo (Microsoft.ML.Probabilistic.Models.Variable`1[T] variable) [0x00055] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:14:01 -   at <StartupCode$FSI_0269>.$FSI_0269.main@ () [0x0002d] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-22 19:14:01 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-22 19:14:01 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-22 19:14:24 - distributionParameters.rain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(priorDistributions.rain.[C]))
2018-10-22 19:14:24 - distributionParameters.rain.SetValueRange(R)
2018-10-22 19:14:25 - Expression evaluation failed: Cannot define a variable more than once in the same condition block context: (SwitchBlock(vint__3[index7]==index6),SwitchBlock(Sprinkler[N]==S))
2018-10-22 19:14:25 - InvalidOperationExceptionCannot define a variable more than once in the same condition block context: (SwitchBlock(vint__3[index7]==index6),SwitchBlock(Sprinkler[N]==S))
2018-10-22 19:14:25 -   at Microsoft.ML.Probabilistic.Models.Variable.SetDefinition (Microsoft.ML.Probabilistic.Models.MethodInvoke methodInvoke) [0x0003d] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:14:25 -   at Microsoft.ML.Probabilistic.Models.Variable`1[T].SetTo (Microsoft.ML.Probabilistic.Models.MethodInvoke methodInvoke) [0x00019] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:14:25 -   at Microsoft.ML.Probabilistic.Models.Variable`1[T].SetTo (Microsoft.ML.Probabilistic.Models.Variable`1[T] variable) [0x00055] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:14:25 -   at <StartupCode$FSI_0270>.$FSI_0270.main@ () [0x0002d] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-22 19:14:25 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-22 19:14:25 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-22 19:14:34 - let priorDistributions:PriorDistributions = {
2018-10-22 19:14:34 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-22 19:14:34 -     sprinkler= Variable.Array<Dirichlet>(C).Named("cptSprinklerPrior") ;
2018-10-22 19:14:34 -     rain= Variable.Array<Dirichlet>(C).Named("cptRainPrior");
2018-10-22 19:14:34 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-22 19:14:34 -                     Variable.Array<Dirichlet>(R), S).Named("cptWetGrassPrior")}
2018-10-22 19:14:35 - let distributionParameters:DistributionParameters = {
2018-10-22 19:14:35 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-22 19:14:35 -     sprinkler= Variable.Array<Vector>(C).Named("cptSprinkler") ;
2018-10-22 19:14:35 -     rain= Variable.Array<Vector>(C).Named("cptRain");
2018-10-22 19:14:35 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-22 19:14:35 -                 Variable.Array<Vector>(R), S).Named("cptWetGrass")}
2018-10-22 19:14:36 - distributionParameters.cloudy.SetValueRange(ranges.c)
2018-10-22 19:14:41 - distributionParameters.sprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(priorDistributions.sprinkler.[C]))
2018-10-22 19:14:41 - distributionParameters.sprinkler.SetValueRange(S)
2018-10-22 19:14:43 - distributionParameters.rain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(priorDistributions.rain.[C]))
2018-10-22 19:14:43 - distributionParameters.rain.SetValueRange(R)
2018-10-22 19:15:14 - let priorDistributions:PriorDistributions = {
2018-10-22 19:15:14 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-22 19:15:14 -     sprinkler= Variable.Array<Dirichlet>(C).Named("cptSprinklerPrior") ;
2018-10-22 19:15:14 -     rain= Variable.Array<Dirichlet>(C).Named("cptRainPrior");
2018-10-22 19:15:14 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-22 19:15:14 -                     Variable.Array<Dirichlet>(R), S).Named("cptWetGrassPrior")}
2018-10-22 19:15:14 - let distributionParameters:DistributionParameters = {
2018-10-22 19:15:14 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-22 19:15:14 -     sprinkler= Variable.Array<Vector>(C).Named("cptSprinkler") ;
2018-10-22 19:15:14 -     rain= Variable.Array<Vector>(C).Named("cptRain");
2018-10-22 19:15:14 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-22 19:15:14 -                 Variable.Array<Vector>(R), S).Named("cptWetGrass")}
2018-10-22 19:15:15 - distributionParameters.cloudy.SetValueRange(ranges.c)
2018-10-22 19:15:15 - distributionParameters.sprinkler.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priorDistributions.sprinkler.[ranges.c]))
2018-10-22 19:15:15 - distributionParameters.sprinkler.SetValueRange(ranges.s)
2018-10-22 19:15:16 - Expression evaluation failed: VariableArray<Vector> cptSprinkler cannot be indexed by c. Perhaps you omitted c as an argument to the constructor?
2018-10-22 19:15:16 - Parameter name: index
2018-10-22 19:15:16 - ArgumentExceptionVariableArray<Vector> cptSprinkler cannot be indexed by c. Perhaps you omitted c as an argument to the constructor?
2018-10-22 19:15:16 - Parameter name: index
2018-10-22 19:15:16 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:15:16 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:15:16 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:15:16 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:15:16 -   at <StartupCode$FSI_0283>.$FSI_0283.main@ () [0x0000f] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-22 19:15:16 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-22 19:15:16 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-22 19:15:44 - distributionParameters.sprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(priorDistributions.sprinkler.[C]))
2018-10-22 19:15:44 - distributionParameters.sprinkler.SetValueRange(S)
2018-10-22 19:18:27 - let priors:PriorDistributions = {
2018-10-22 19:18:27 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-22 19:18:27 -     sprinkler= Variable.Array<Dirichlet>(C).Named("cptSprinklerPrior") ;
2018-10-22 19:18:27 -     rain= Variable.Array<Dirichlet>(C).Named("cptRainPrior");
2018-10-22 19:18:27 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-22 19:18:27 -                     Variable.Array<Dirichlet>(R), S).Named("cptWetGrassPrior")}
2018-10-22 19:18:43 - let parameters:DistributionParameters = {
2018-10-22 19:18:43 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-22 19:18:43 -     sprinkler= Variable.Array<Vector>(C).Named("cptSprinkler") ;
2018-10-22 19:18:43 -     rain= Variable.Array<Vector>(C).Named("cptRain");
2018-10-22 19:18:43 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-22 19:18:43 -                 Variable.Array<Vector>(R), S).Named("cptWetGrass")}
2018-10-22 19:19:17 - parameters.cloudy.SetValueRange(ranges.c)
2018-10-22 19:19:51 - parameters.sprinkler.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[C]))
2018-10-22 19:19:51 - parameters.sprinkler.SetValueRange(S)
2018-10-22 19:19:51 - Expression evaluation failed: VariableArray<Vector> cptSprinkler cannot be indexed by c. Perhaps you omitted c as an argument to the constructor?
2018-10-22 19:19:51 - Parameter name: index
2018-10-22 19:19:51 - ArgumentExceptionVariableArray<Vector> cptSprinkler cannot be indexed by c. Perhaps you omitted c as an argument to the constructor?
2018-10-22 19:19:51 - Parameter name: index
2018-10-22 19:19:51 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:19:51 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:19:51 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:19:51 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:19:51 -   at <StartupCode$FSI_0290>.$FSI_0290.main@ () [0x0000f] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-22 19:19:51 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-22 19:19:51 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-22 19:20:42 - let ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-22 19:21:18 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-22 19:21:34 - parameters.sprinkler.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[C]))
2018-10-22 19:21:34 - parameters.sprinkler.SetValueRange(S)
2018-10-22 19:21:34 - Expression evaluation failed: VariableArray<Vector> cptSprinkler cannot be indexed by c. Perhaps you omitted c as an argument to the constructor?
2018-10-22 19:21:34 - Parameter name: index
2018-10-22 19:21:34 - ArgumentExceptionVariableArray<Vector> cptSprinkler cannot be indexed by c. Perhaps you omitted c as an argument to the constructor?
2018-10-22 19:21:34 - Parameter name: index
2018-10-22 19:21:34 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:21:34 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:21:34 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:21:34 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:21:34 -   at <StartupCode$FSI_0293>.$FSI_0293.main@ () [0x0000f] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-22 19:21:34 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-22 19:21:34 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-22 19:21:42 - parameters.sprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[C]))
2018-10-22 19:21:42 - parameters.sprinkler.SetValueRange(S)
2018-10-22 19:21:48 - parameters.rain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(priors.rain.[C]))
2018-10-22 19:21:48 - parameters.rain.SetValueRange(R)
2018-10-22 19:21:56 - parameters.rain.[range.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.rain.[C]))
2018-10-22 19:21:56 - parameters.rain.SetValueRange(R)
2018-10-22 19:21:57 - The value, namespace, type or module 'range' is not defined. Maybe you want one of the following:
2018-10-22 19:21:57 -    Range
2018-10-22 19:21:57 -    Ranges
2018-10-22 19:21:57 -    ranges
2018-10-22 19:21:57 -    Rand
2018-10-22 19:21:57 -    raise
2018-10-22 19:21:57 - A unique overload for method 'Item' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: VariableArray.get_Item(index: Variable<int>) : Variable<Vector>, VariableArray.get_Item(index: int) : Variable<Vector>, VariableArray.get_Item(range: Range) : Variable<Vector>
2018-10-22 19:22:04 - parameters.rain.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.rain.[C]))
2018-10-22 19:22:04 - parameters.rain.SetValueRange(R)
2018-10-22 19:22:05 - Expression evaluation failed: VariableArray<Vector> cptRain cannot be indexed by c. Perhaps you omitted c as an argument to the constructor?
2018-10-22 19:22:05 - Parameter name: index
2018-10-22 19:22:05 - ArgumentExceptionVariableArray<Vector> cptRain cannot be indexed by c. Perhaps you omitted c as an argument to the constructor?
2018-10-22 19:22:05 - Parameter name: index
2018-10-22 19:22:05 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:22:05 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:22:05 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:22:05 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:22:05 -   at <StartupCode$FSI_0299>.$FSI_0299.main@ () [0x0000f] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-22 19:22:05 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-22 19:22:05 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-22 19:22:22 - parameters.rain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(priors.rain.[C]))
2018-10-22 19:22:22 - parameters.rain.SetValueRange(R)
2018-10-22 19:22:23 - Expression evaluation failed: Cannot define a variable more than once in the same condition block context: (SwitchBlock(vint__3[index7]==index6),SwitchBlock(Sprinkler[N]==S))
2018-10-22 19:22:23 - InvalidOperationExceptionCannot define a variable more than once in the same condition block context: (SwitchBlock(vint__3[index7]==index6),SwitchBlock(Sprinkler[N]==S))
2018-10-22 19:22:23 -   at Microsoft.ML.Probabilistic.Models.Variable.SetDefinition (Microsoft.ML.Probabilistic.Models.MethodInvoke methodInvoke) [0x0003d] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:22:23 -   at Microsoft.ML.Probabilistic.Models.Variable`1[T].SetTo (Microsoft.ML.Probabilistic.Models.MethodInvoke methodInvoke) [0x00019] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:22:23 -   at Microsoft.ML.Probabilistic.Models.Variable`1[T].SetTo (Microsoft.ML.Probabilistic.Models.Variable`1[T] variable) [0x00055] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:22:23 -   at <StartupCode$FSI_0300>.$FSI_0300.main@ () [0x0002d] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-22 19:22:23 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-22 19:22:23 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-22 19:23:23 - let priors:PriorDistributions = {
2018-10-22 19:23:23 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-22 19:23:23 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-22 19:23:23 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-22 19:23:23 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-22 19:23:23 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-22 19:23:53 - let parameters:DistributionParameters = {
2018-10-22 19:23:53 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-22 19:23:53 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-10-22 19:23:53 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-10-22 19:23:53 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-22 19:23:53 -                 Variable.Array<Vector>(ranges.r), ranges.r).Named("cptWetGrass")}
2018-10-22 19:24:05 - parameters.cloudy.SetValueRange(ranges.c)
2018-10-22 19:24:24 - parameters.sprinkler.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c]))
2018-10-22 19:24:24 - parameters.sprinkler.SetValueRange(ranges.s)
2018-10-22 19:24:43 - parameters.rain.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c]))
2018-10-22 19:24:43 - parameters.rain.SetValueRange(ranges.r)
2018-10-22 19:26:01 - parameters.wetGrass.[ranges.s].[ranges.r].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[ranges.s].[ranges.r]))
2018-10-22 19:26:01 - parameters.wetGrass.SetValueRange(ranges.w)
2018-10-22 19:26:02 - Expression evaluation failed: VariableArray<VariableArray<Vector>, Vector[][]> cptWetGrass cannot be indexed by s. Perhaps you omitted s as an argument to the constructor?
2018-10-22 19:26:02 - Parameter name: index
2018-10-22 19:26:02 - ArgumentExceptionVariableArray<VariableArray<Vector>, Vector[][]> cptWetGrass cannot be indexed by s. Perhaps you omitted s as an argument to the constructor?
2018-10-22 19:26:02 - Parameter name: index
2018-10-22 19:26:02 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:26:02 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:26:02 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:26:02 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:26:02 -   at <StartupCode$FSI_0309>.$FSI_0309.main@ () [0x0000f] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-22 19:26:02 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-22 19:26:02 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-22 19:26:28 - let parameters:DistributionParameters = {
2018-10-22 19:26:28 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-22 19:26:28 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-10-22 19:26:28 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-10-22 19:26:28 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-22 19:26:28 -                 Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-10-22 19:26:43 - let priors:PriorDistributions = {
2018-10-22 19:26:43 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-22 19:26:43 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-22 19:26:43 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-22 19:26:43 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-22 19:26:43 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-22 19:26:44 - let parameters:DistributionParameters = {
2018-10-22 19:26:44 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-22 19:26:44 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-10-22 19:26:44 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-10-22 19:26:44 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-22 19:26:44 -                 Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-10-22 19:26:44 - parameters.cloudy.SetValueRange(ranges.c)
2018-10-22 19:26:45 - parameters.sprinkler.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c]))
2018-10-22 19:26:45 - parameters.sprinkler.SetValueRange(ranges.s)
2018-10-22 19:26:45 - parameters.rain.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c]))
2018-10-22 19:26:45 - parameters.rain.SetValueRange(ranges.r)
2018-10-22 19:26:46 - parameters.wetGrass.[ranges.s].[ranges.r].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[ranges.s].[ranges.r]))
2018-10-22 19:26:46 - parameters.wetGrass.SetValueRange(ranges.w)
2018-10-22 19:26:46 - Expression evaluation failed: VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> cptWetGrassPrior cannot be indexed by s. Perhaps you omitted s as an argument to the constructor?
2018-10-22 19:26:46 - Parameter name: index
2018-10-22 19:26:46 - ArgumentExceptionVariableArray<VariableArray<Dirichlet>, Dirichlet[][]> cptWetGrassPrior cannot be indexed by s. Perhaps you omitted s as an argument to the constructor?
2018-10-22 19:26:46 - Parameter name: index
2018-10-22 19:26:46 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:26:46 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:26:46 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:26:46 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:26:46 -   at <StartupCode$FSI_0319>.$FSI_0319.main@ () [0x00032] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-22 19:26:46 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-22 19:26:46 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-22 19:28:57 - let priors:PriorDistributions = {
2018-10-22 19:28:57 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-22 19:28:57 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-22 19:28:57 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-22 19:28:57 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-22 19:28:57 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-22 19:28:58 - let parameters:DistributionParameters = {
2018-10-22 19:28:58 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-22 19:28:58 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-10-22 19:28:58 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-10-22 19:28:58 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-22 19:28:58 -                 Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-10-22 19:28:58 - parameters.cloudy.SetValueRange(ranges.c)
2018-10-22 19:28:59 - parameters.sprinkler.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c]))
2018-10-22 19:28:59 - parameters.sprinkler.SetValueRange(ranges.s)
2018-10-22 19:28:59 - parameters.rain.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c]))
2018-10-22 19:28:59 - parameters.rain.SetValueRange(ranges.r)
2018-10-22 19:29:00 - parameters.wetGrass.[ranges.s].[ranges.r].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[ranges.s].[ranges.r]))
2018-10-22 19:29:00 - parameters.wetGrass.SetValueRange(ranges.w)
2018-10-22 19:29:00 - Expression evaluation failed: VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> cptWetGrassPrior cannot be indexed by s. Perhaps you omitted s as an argument to the constructor?
2018-10-22 19:29:00 - Parameter name: index
2018-10-22 19:29:00 - ArgumentExceptionVariableArray<VariableArray<Dirichlet>, Dirichlet[][]> cptWetGrassPrior cannot be indexed by s. Perhaps you omitted s as an argument to the constructor?
2018-10-22 19:29:00 - Parameter name: index
2018-10-22 19:29:00 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:29:00 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:29:00 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:29:00 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-22 19:29:00 -   at <StartupCode$FSI_0328>.$FSI_0328.main@ () [0x00032] in <a2895c6915a44a85863853c5978a20e4>:0 
2018-10-22 19:29:00 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-22 19:29:00 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-22 19:31:19 - parameters.wetGrass.[ranges.s].[ranges.r].SetTo(Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[ranges.s].[ranges.r]))
2018-10-22 19:31:19 - parameters.wetGrass.SetValueRange(ranges.w)
2018-10-24 15:08:39 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-24 15:08:39 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-24 15:08:39 - For help type #help;;
2018-10-24 15:08:39 - > val it :
2018-10-24 15:08:39 -   ResizeArray<System.Type *
2018-10-24 15:08:39 -               (obj ->
2018-10-24 15:08:39 -                  seq<string *
2018-10-24 15:08:39 -                      string> *
2018-10-24 15:08:39 -                  string)>
2018-10-24 15:08:39 - = seq []
2018-10-24 15:08:39 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-24 15:08:39 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-24 15:08:39 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-24 15:08:40 - Reporting 0 opened comms
2018-10-24 15:52:56 - Reporting 0 opened comms
2018-10-24 15:52:56 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-24 15:52:56 -     let r = parent.Range
2018-10-24 15:52:56 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-24 15:52:56 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:Variable<int>) ->  
2018-10-24 15:52:56 -                        Variable.Discrete(cpt.[pi])))
2018-10-24 15:52:56 -     child
2018-10-24 15:52:58 - The type 'VariableArray' is not defined.
2018-10-24 15:52:58 - The type 'VariableArray' is not defined.
2018-10-24 15:52:58 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-24 15:52:58 - The type 'VariableArray' is not defined.
2018-10-24 15:52:58 - The value, namespace, type or module 'Variable' is not defined.
2018-10-24 15:52:58 - let AddChildFromTwoParents (parent1:VariableArray<int>) (parent2:VariableArray<int>) (cpt:VariableArray<VariableArray<Vector>, Vector[][]>) = 
2018-10-24 15:52:58 -     let r = parent1.Range
2018-10-24 15:52:58 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-24 15:52:58 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:Variable<int>) ->  
2018-10-24 15:52:58 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:Variable<int>) ->  
2018-10-24 15:52:58 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-24 15:52:58 -     child
2018-10-24 15:52:58 -         
2018-10-24 15:52:59 - The type 'VariableArray' is not defined.
2018-10-24 15:52:59 - The type 'VariableArray' is not defined.
2018-10-24 15:52:59 - The type 'VariableArray' is not defined.
2018-10-24 15:52:59 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-24 15:52:59 - The type 'VariableArray' is not defined.
2018-10-24 15:52:59 - The value, namespace, type or module 'Variable' is not defined.
2018-10-24 15:52:59 - let Engine =  InferenceEngine ()
2018-10-24 15:53:00 - The value or constructor 'InferenceEngine' is not defined.
2018-10-24 15:53:00 - let NumberOfExamples = Variable.New<int>().Named("NofE")
2018-10-24 15:53:00 - let N = Range(NumberOfExamples).Named("N")
2018-10-24 15:53:00 - The value, namespace, type or module 'Variable' is not defined.
2018-10-24 15:53:00 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-24 15:53:00 -    raise
2018-10-24 15:53:01 - let C = Range(2).Named("C") // Cloudy
2018-10-24 15:53:01 - let S = Range(2).Named("S") // Sprinkler
2018-10-24 15:53:01 - let R = Range(2).Named("R") // Rain
2018-10-24 15:53:01 - let W = Range(2).Named("W") // Wet
2018-10-24 15:53:01 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-24 15:53:01 -    raise
2018-10-24 15:53:01 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-24 15:53:01 -    raise
2018-10-24 15:53:01 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-24 15:53:01 -    raise
2018-10-24 15:53:01 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-24 15:53:01 -    raise
2018-10-24 15:53:01 - let ProbCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("ProbCloudyPrior")
2018-10-24 15:53:01 - let ProbCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(ProbCloudyPrior).Named("ProbCloudy")
2018-10-24 15:53:01 - ProbCloudy.SetValueRange(C)
2018-10-24 15:53:02 - The type 'Variable' is not defined.
2018-10-24 15:53:02 - The value, namespace, type or module 'Variable' is not defined.
2018-10-24 15:53:02 - The type 'Variable' is not defined.
2018-10-24 15:53:02 - The value or constructor 'Variable' is not defined.
2018-10-24 15:53:02 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-24 15:53:02 - let CPTSprinklerPrior = Variable.Array<Dirichlet>(C).Named("CPTSprinklerPrior")
2018-10-24 15:53:02 - let CPTSprinkler = Variable.Array<Vector>(C).Named("CPTSprinkler")
2018-10-24 15:53:03 - The value, namespace, type or module 'Variable' is not defined.
2018-10-24 15:53:03 - The value, namespace, type or module 'Variable' is not defined.
2018-10-24 15:53:03 - CPTSprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTSprinklerPrior.[C]))
2018-10-24 15:53:03 - The value or constructor 'CPTSprinkler' is not defined.
2018-10-24 15:53:03 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-24 15:53:04 - CPTSprinkler.SetValueRange(S)
2018-10-24 15:53:04 - The value, namespace, type or module 'CPTSprinkler' is not defined.
2018-10-24 15:53:04 - let CPTRainPrior = Variable.Array<Dirichlet>(C).Named("CPTRainPrior")
2018-10-24 15:53:04 - let CPTRain = Variable.Array<Vector>(C).Named("CPTRain")
2018-10-24 15:53:05 - The value, namespace, type or module 'Variable' is not defined.
2018-10-24 15:53:05 - The value, namespace, type or module 'Variable' is not defined.
2018-10-24 15:53:05 - CPTRain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(CPTRainPrior.[C]))
2018-10-24 15:53:06 - The value or constructor 'CPTRain' is not defined.
2018-10-24 15:53:06 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-24 15:53:06 - CPTRain.SetValueRange(R)
2018-10-24 15:53:07 - The value, namespace, type or module 'CPTRain' is not defined.
2018-10-24 15:53:07 - let CPTWetGrassPrior= 
2018-10-24 15:53:07 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-24 15:53:07 -         Variable.Array<Dirichlet>(R), S).Named("CPTWetGrassPrior")
2018-10-24 15:53:07 - let CPTWetGrass = 
2018-10-24 15:53:07 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-24 15:53:07 -         Variable.Array<Vector>(R), S).Named("CPTWetGrass")
2018-10-24 15:53:07 - The value, namespace, type or module 'Variable' is not defined.
2018-10-24 15:53:07 - The value, namespace, type or module 'Variable' is not defined.
2018-10-24 15:53:08 - CPTWetGrass.[S].[R].SetTo(Variable<Vector>.Random<Dirichlet>(CPTWetGrassPrior.[S].[R]))
2018-10-24 15:53:08 - CPTWetGrass.SetValueRange(W)
2018-10-24 15:53:08 - The value or constructor 'CPTWetGrass' is not defined.
2018-10-24 15:53:08 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-24 15:53:08 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-24 15:53:08 - The value, namespace, type or module 'CPTWetGrass' is not defined.
2018-10-24 15:53:08 - let Cloudy = Variable.Array<int>(N).Named("Cloudy")
2018-10-24 15:53:08 - Cloudy.[N].SetTo(Variable.Discrete(ProbCloudy).ForEach(N))
2018-10-24 15:53:09 - The value, namespace, type or module 'Variable' is not defined.
2018-10-24 15:53:09 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-24 15:53:09 - let AddChildFromOneParent (parent:VariableArray<int>) (cpt:VariableArray<Vector>) =
2018-10-24 15:53:09 -     let r = parent.Range
2018-10-24 15:53:09 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-24 15:53:09 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:Variable<int>) ->  
2018-10-24 15:53:09 -                        Variable.Discrete(cpt.[pi])))
2018-10-24 15:53:09 -     child
2018-10-24 15:53:09 - The type 'VariableArray' is not defined.
2018-10-24 15:53:09 - The type 'VariableArray' is not defined.
2018-10-24 15:53:09 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-24 15:53:09 - The type 'VariableArray' is not defined.
2018-10-24 15:53:09 - The value, namespace, type or module 'Variable' is not defined.
2018-10-24 15:53:10 - let AddChildFromTwoParents (parent1:VariableArray<int>) (parent2:VariableArray<int>) (cpt:VariableArray<VariableArray<Vector>, Vector[][]>) = 
2018-10-24 15:53:10 -     let r = parent1.Range
2018-10-24 15:53:10 -     let (child:VariableArray<int>) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-24 15:53:10 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:Variable<int>) ->  
2018-10-24 15:53:10 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:Variable<int>) ->  
2018-10-24 15:53:10 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-24 15:53:10 -     child
2018-10-24 15:53:10 -         
2018-10-24 15:53:10 - The type 'VariableArray' is not defined.
2018-10-24 15:53:10 - The type 'VariableArray' is not defined.
2018-10-24 15:53:10 - The type 'VariableArray' is not defined.
2018-10-24 15:53:10 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-24 15:53:10 - The type 'VariableArray' is not defined.
2018-10-24 15:53:10 - The value, namespace, type or module 'Variable' is not defined.
2018-10-24 15:55:22 - Reporting 0 opened comms
2018-10-24 17:47:02 - let buildPriors z:Ranges =
2018-10-24 17:47:02 -     {
2018-10-24 17:47:02 -     cloudy= Dirichlet0().Named("probCloudyPrior");
2018-10-24 17:47:02 -     sprinkler= Dirichlet1(z.c).Named("cptSprinklerPrior") ;
2018-10-24 17:47:02 -     rain= Dirichlet1(z.c).Named("cptRainPrior");
2018-10-24 17:47:02 -     wetGrass= Dirichlet2(Dirichlet1(z.r), z.s).Named("cptWetGrassPrior")}
2018-10-24 17:47:05 - The type 'Ranges' is not defined.
2018-10-24 17:47:05 - The record label 'cloudy' is not defined.
2018-10-24 17:47:16 - #load "Paket.fsx"
2018-10-24 17:47:34 - Paket.Package
2018-10-24 17:47:34 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-24 17:47:34 -       "Microsoft.ML.Probabilistic"
2018-10-24 17:47:34 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-24 17:47:34 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-24 17:47:34 -       "NETStandard.Library"
2018-10-24 17:47:34 -   ]
2018-10-24 17:51:15 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-24 17:51:28 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-24 17:52:59 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-24 17:52:59 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-24 17:52:59 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-24 17:53:00 - #r "Microsoft.ML.Probabilistic"
2018-10-24 17:53:00 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-24 17:53:00 - #r "netstandard"
2018-10-24 17:53:02 - open System
2018-10-24 17:53:02 - open Microsoft.ML.Probabilistic  
2018-10-24 17:53:02 - open Microsoft.ML.Probabilistic.Models  
2018-10-24 17:53:02 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-24 17:53:02 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-24 17:53:02 - open Microsoft.ML.Probabilistic.Math
2018-10-24 17:53:05 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-24 17:53:16 - open Microsoft.ML.Probabilistic.FSharp
2018-10-24 17:53:17 - type Parent:VariableArray<int>
2018-10-24 17:53:17 - type Child:VariableArray<int>
2018-10-24 17:53:17 - type ParentCase:Variable<int>
2018-10-24 17:53:17 - type ConditionalProbabilityTable:VariableArray<Vector>
2018-10-24 17:53:17 - let AddChildFromOneParent (parent:Parent) (cpt:ConditionalProbabilityTable) =
2018-10-24 17:53:17 -     let r = parent.Range
2018-10-24 17:53:17 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-24 17:53:17 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:ParentCase) ->  
2018-10-24 17:53:17 -                        Variable.Discrete(cpt.[pi])))
2018-10-24 17:53:17 -     child
2018-10-24 17:53:18 - Unexpected symbol ':' in type definition. Expected '(' or other token.
2018-10-24 17:53:18 - parse error
2018-10-24 17:53:18 - type ConditionalProbabilityTable2D:VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-24 17:53:18 - let AddChildFromTwoParents (parent1:Parent) (parent2:Parent) (cpt:ConditionalProbabilityTable2D) = 
2018-10-24 17:53:18 -     let r = parent1.Range
2018-10-24 17:53:18 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-24 17:53:18 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:ParentCase) ->  
2018-10-24 17:53:18 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:ParentCase) ->  
2018-10-24 17:53:18 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-24 17:53:18 -     child       
2018-10-24 17:53:19 - Unexpected symbol ':' in type definition. Expected '(' or other token.
2018-10-24 17:53:19 - parse error
2018-10-24 17:53:19 - type RandomVariables =
2018-10-24 17:53:19 -     {cloudy:VariableArray<int>;
2018-10-24 17:53:19 -     sprinkler:VariableArray<int>;
2018-10-24 17:53:19 -     rain:VariableArray<int>;
2018-10-24 17:53:19 -     wetGrass:VariableArray<int> }
2018-10-24 17:53:21 - type ObservedValues =
2018-10-24 17:53:21 -     {cloudy:array<int>;
2018-10-24 17:53:21 -     sprinkler:array<int>;
2018-10-24 17:53:21 -     rain:array<int>;
2018-10-24 17:53:21 -     wetGrass:array<int> }
2018-10-24 17:53:22 - type DistributionParameters =
2018-10-24 17:53:22 -     {cloudy:Variable<Vector> ;
2018-10-24 17:53:22 -     sprinkler:VariableArray<Vector> ;
2018-10-24 17:53:22 -     rain:VariableArray<Vector> ;
2018-10-24 17:53:22 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-24 17:53:23 - type PriorDistributions =
2018-10-24 17:53:23 -     {cloudy:Variable<Dirichlet> ;
2018-10-24 17:53:23 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-24 17:53:23 -     rain:VariableArray<Dirichlet> ;
2018-10-24 17:53:23 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-24 17:53:23 - type PosteriorDistributions =
2018-10-24 17:53:23 -     {cloudy:Dirichlet ;
2018-10-24 17:53:23 -         sprinkler:Dirichlet[] ;
2018-10-24 17:53:23 -         rain:Dirichlet[] ;
2018-10-24 17:53:23 -         wetGrass:Dirichlet[][] }
2018-10-24 17:53:24 - type Ranges = {c:Range;s:Range;r:Range;w:Range}
2018-10-24 17:53:25 - let engine =  InferenceEngine ()
2018-10-24 17:53:26 - let NumberOfExamples = Variable.New<int>().Named("NofE")
2018-10-24 17:53:26 - let N = Range(NumberOfExamples).Named("N")
2018-10-24 17:53:26 - let C = Range(2).Named("C") // Cloudy
2018-10-24 17:53:26 - let S = Range(2).Named("S") // Sprinkler
2018-10-24 17:53:26 - let R = Range(2).Named("R") // Rain
2018-10-24 17:53:26 - let W = Range(2).Named("W") // Wet
2018-10-24 17:53:27 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-24 17:53:28 - let buildPriors z:Ranges =
2018-10-24 17:53:28 -     {
2018-10-24 17:53:28 -     cloudy= Dirichlet0().Named("probCloudyPrior");
2018-10-24 17:53:28 -     sprinkler= Dirichlet1(z.c).Named("cptSprinklerPrior") ;
2018-10-24 17:53:28 -     rain= Dirichlet1(z.c).Named("cptRainPrior");
2018-10-24 17:53:28 -     wetGrass= Dirichlet2(Dirichlet1(z.r), z.s).Named("cptWetGrassPrior")}
2018-10-24 17:53:28 - The record type 'Ranges' does not contain a label 'cloudy'.
2018-10-24 17:53:28 - let priors = buildPriors ranges
2018-10-24 17:53:29 - The value or constructor 'buildPriors' is not defined.
2018-10-24 17:53:29 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-24 17:57:39 - let buildPriors z:Ranges =
2018-10-24 17:57:39 -     {
2018-10-24 17:57:39 -     cloudy=    Dirichlet0().Named("probCloudyPrior");
2018-10-24 17:57:39 -     sprinkler= Dirichlet1(z.c).Named("cptSprinklerPrior") ;
2018-10-24 17:57:39 -     rain=      Dirichlet1(z.c).Named("cptRainPrior");
2018-10-24 17:57:39 -     wetGrass=  Dirichlet2(Dirichlet1(z.r), z.s).Named("cptWetGrassPrior")}
2018-10-24 17:57:40 - The record type 'Ranges' does not contain a label 'cloudy'.
2018-10-24 17:59:32 - let buildPriors z:Ranges =
2018-10-24 17:59:32 -     let priors:PriorDistributions ={
2018-10-24 17:59:32 -         cloudy=    Dirichlet0().Named("probCloudyPrior");
2018-10-24 17:59:32 -         sprinkler= Dirichlet1(z.c).Named("cptSprinklerPrior") ;
2018-10-24 17:59:32 -         rain=      Dirichlet1(z.c).Named("cptRainPrior");
2018-10-24 17:59:32 -         wetGrass=  Dirichlet2(Dirichlet1(z.r), z.s).Named("cptWetGrassPrior")}
2018-10-24 17:59:32 -     priors
2018-10-24 17:59:34 - The value or constructor 'Dirichlet0' is not defined. Maybe you want one of the following:
2018-10-24 17:59:34 -    Dirichlet
2018-10-24 17:59:34 -    DirichletOp
2018-10-24 17:59:34 -    DirichletEstimator
2018-10-24 17:59:34 -    DirichletSymmetricOp
2018-10-24 17:59:34 - The value or constructor 'Dirichlet1' is not defined. Maybe you want one of the following:
2018-10-24 17:59:34 -    Dirichlet
2018-10-24 17:59:34 -    DirichletOp
2018-10-24 17:59:34 -    DirichletEstimator
2018-10-24 17:59:34 -    DirichletSymmetricOp
2018-10-24 17:59:34 - The value or constructor 'Dirichlet1' is not defined. Maybe you want one of the following:
2018-10-24 17:59:34 -    Dirichlet
2018-10-24 17:59:34 -    DirichletOp
2018-10-24 17:59:34 -    DirichletEstimator
2018-10-24 17:59:34 -    DirichletSymmetricOp
2018-10-24 17:59:34 - The value or constructor 'Dirichlet2' is not defined. Maybe you want one of the following:
2018-10-24 17:59:34 -    Dirichlet
2018-10-24 17:59:34 -    DirichletOp
2018-10-24 17:59:34 -    DirichletEstimator
2018-10-24 17:59:34 -    DirichletSymmetricOp
2018-10-24 17:59:34 - This expression was expected to have type
2018-10-24 17:59:34 -     'Ranges'    
2018-10-24 17:59:34 - but here has type
2018-10-24 17:59:34 -     'PriorDistributions'    
2018-10-24 17:59:40 - type Dirichlet0 = Variable.New<Dirichlet>
2018-10-24 17:59:40 - type Dirichlet1 = Variable.Array<Dirichlet>
2018-10-24 17:59:40 - type Dirichlet2 = Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>
2018-10-24 17:59:40 - let priors:PriorDistributions = {
2018-10-24 17:59:40 -     cloudy= Dirichlet0().Named("probCloudyPrior");
2018-10-24 17:59:40 -     sprinkler= Dirichlet1(ranges.c).Named("cptSprinklerPrior") ;
2018-10-24 17:59:40 -     rain= Dirichlet1(ranges.c).Named("cptRainPrior");
2018-10-24 17:59:40 -     wetGrass= Dirichlet2(Dirichlet1(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-24 17:59:42 - The type 'New' is not defined in 'FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable'.
2018-10-24 17:59:42 - The type 'New' is not defined in 'FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable'.
2018-10-24 17:59:42 - The type 'Array' is not defined in 'FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable'.
2018-10-24 17:59:42 - The type 'Array' is not defined in 'FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable'.
2018-10-24 17:59:42 - The type 'Array' is not defined in 'FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable'.
2018-10-24 17:59:42 - The type 'Array' is not defined in 'FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable'.
2018-10-24 17:59:42 - The field, constructor or member 'Named' is not defined.
2018-10-24 17:59:42 - The object constructor 'Object' takes 0 argument(s) but is here given 1. The required signature is 'Object() : Dirichlet1'.
2018-10-24 17:59:42 - The object constructor 'Object' takes 0 argument(s) but is here given 1. The required signature is 'Object() : Dirichlet1'.
2018-10-24 17:59:42 - The object constructor 'Object' takes 0 argument(s) but is here given 1. The required signature is 'Object() : Dirichlet1'.
2018-10-24 17:59:42 - The object constructor 'Object' takes 0 argument(s) but is here given 2. The required signature is 'Object() : Dirichlet2'.
2018-10-24 18:01:30 - let Dirichlet0 = Variable.New<Dirichlet>
2018-10-24 18:01:30 - let Dirichlet1 = Variable.Array<Dirichlet>
2018-10-24 18:01:30 - let Dirichlet2 = Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>
2018-10-24 18:01:30 - let priors:PriorDistributions = {
2018-10-24 18:01:30 -     cloudy= Dirichlet0().Named("probCloudyPrior");
2018-10-24 18:01:30 -     sprinkler= Dirichlet1(ranges.c).Named("cptSprinklerPrior") ;
2018-10-24 18:01:30 -     rain= Dirichlet1(ranges.c).Named("cptRainPrior");
2018-10-24 18:01:30 -     wetGrass= Dirichlet2(Dirichlet1(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-24 18:01:32 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2018-10-24 18:01:32 - The member or object constructor 'Array' does not take 1 argument(s). An overload was found taking 1 arguments.
2018-10-24 18:01:32 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-24 18:01:32 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-24 18:01:32 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-24 18:02:49 - //let Dirichlet0 = Variable.New<Dirichlet>
2018-10-24 18:02:49 - //let Dirichlet1 = Variable.Array<Dirichlet>
2018-10-24 18:02:49 - //let Dirichlet2 = Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>
2018-10-24 18:02:49 - let priors:PriorDistributions = {
2018-10-24 18:02:49 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-24 18:02:49 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-24 18:02:49 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-24 18:02:49 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-24 18:02:49 -         Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-24 18:02:50 - Possible incorrect indentation: this token is offside of context started at position (9:15). Try indenting this token further or using standard formatting conventions.
2018-10-24 18:02:50 - Possible incorrect indentation: this token is offside of context started at position (9:15). Try indenting this token further or using standard formatting conventions.
2018-10-24 18:03:00 - //let Dirichlet0 = Variable.New<Dirichlet>
2018-10-24 18:03:00 - //let Dirichlet1 = Variable.Array<Dirichlet>
2018-10-24 18:03:00 - //let Dirichlet2 = Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>
2018-10-24 18:03:00 - let priors:PriorDistributions = {
2018-10-24 18:03:00 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-24 18:03:00 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-24 18:03:00 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-24 18:03:00 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-24 18:03:00 -             Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-24 18:03:02 - Possible incorrect indentation: this token is offside of context started at position (9:15). Try indenting this token further or using standard formatting conventions.
2018-10-24 18:03:02 - Possible incorrect indentation: this token is offside of context started at position (9:15). Try indenting this token further or using standard formatting conventions.
2018-10-24 18:03:25 - //let Dirichlet0 = Variable.New<Dirichlet>
2018-10-24 18:03:25 - //let Dirichlet1 = Variable.Array<Dirichlet>
2018-10-24 18:03:25 - //let Dirichlet2 = Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>
2018-10-24 18:03:25 - let priors:PriorDistributions = {
2018-10-24 18:03:25 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-24 18:03:25 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-24 18:03:25 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-24 18:03:25 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-24 18:03:25 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-24 18:05:21 - let buildPriors z:Ranges =
2018-10-24 18:05:21 -     let priors:PriorDistributions ={
2018-10-24 18:05:21 -             cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-24 18:05:21 -             sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-24 18:05:21 -             rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-24 18:05:21 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-24 18:05:21 -                             Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-24 18:05:21 -     priors
2018-10-24 18:05:23 - This expression was expected to have type
2018-10-24 18:05:23 -     'Ranges'    
2018-10-24 18:05:23 - but here has type
2018-10-24 18:05:23 -     'PriorDistributions'    
2018-10-24 18:05:42 - let buildPriors (z:Ranges) =
2018-10-24 18:05:42 -     let priors:PriorDistributions ={
2018-10-24 18:05:42 -             cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-24 18:05:42 -             sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-24 18:05:42 -             rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-24 18:05:42 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-24 18:05:42 -                             Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-24 18:05:42 -     priors
2018-10-24 18:05:46 - let priors = buildPriors ranges
2018-10-24 18:08:43 - let priors = buildPriors ranges
2018-10-24 18:55:14 - let buildDistributionParameters (z:Ranges) (priors:PriorDistributions) =
2018-10-24 18:55:14 -     let parameters:DistributionParameters = {
2018-10-24 18:55:14 -         cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-24 18:55:14 -         sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-10-24 18:55:14 -         rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-10-24 18:55:14 -         wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-24 18:55:14 -                     Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-10-24 18:55:14 -     parameters.cloudy.SetValueRange(z.c)
2018-10-24 18:55:14 -     parameters.sprinkler.[z.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[z.c]))
2018-10-24 18:55:14 -     parameters.sprinkler.SetValueRange(z.s)
2018-10-24 18:55:14 -     parameters.rain.[z.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.rain.[z.c]))
2018-10-24 18:55:14 -     parameters.rain.SetValueRange(z.r)
2018-10-24 18:55:14 -     parameters.wetGrass.[z.s].[z.r].SetTo(Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[z.s].[z.r]))
2018-10-24 18:55:14 -     parameters.wetGrass.SetValueRange(z.w)
2018-10-24 18:55:14 -     parameters        
2018-10-24 18:55:16 - The value or constructor 'probCloudyPrior' is not defined.
2018-10-24 18:55:16 - A unique overload for method 'Random' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Random<'T>(dist: IDistribution<'T>) : Variable<'T>, Variable.Random<'TDist when 'TDist :> IDistribution<Vector>>(dist: Variable<'TDist>) : Variable<Vector>
2018-10-24 18:56:36 - let buildDistributionParameters (z:Ranges) (priors:PriorDistributions) =
2018-10-24 18:56:36 -     let parameters:DistributionParameters = {
2018-10-24 18:56:36 -         cloudy= Variable<Vector>.Random<Dirichlet>(priors.cloudy).Named("probCloudy");
2018-10-24 18:56:36 -         sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-10-24 18:56:36 -         rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-10-24 18:56:36 -         wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-24 18:56:36 -                     Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-10-24 18:56:36 -     parameters.cloudy.SetValueRange(z.c)
2018-10-24 18:56:36 -     parameters.sprinkler.[z.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[z.c]))
2018-10-24 18:56:36 -     parameters.sprinkler.SetValueRange(z.s)
2018-10-24 18:56:36 -     parameters.rain.[z.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.rain.[z.c]))
2018-10-24 18:56:36 -     parameters.rain.SetValueRange(z.r)
2018-10-24 18:56:36 -     parameters.wetGrass.[z.s].[z.r].SetTo(Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[z.s].[z.r]))
2018-10-24 18:56:36 -     parameters.wetGrass.SetValueRange(z.w)
2018-10-24 18:56:36 -     parameters        
2018-10-24 19:12:57 - let parameters = buildDistributionParameters ranges priors
2018-10-24 19:18:54 - let NumberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-24 19:18:54 - let N = Range(NumberOfExamples).Named("N")
2018-10-24 19:19:02 - let NumberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-24 19:19:02 - let N:Range = Range(NumberOfExamples).Named("N")
2018-10-24 19:25:14 - let buildPriors (z:Ranges) =
2018-10-24 19:25:14 -     let priors:PriorDistributions ={
2018-10-24 19:25:14 -             cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-24 19:25:14 -             sprinkler= Variable.Array<Dirichlet>(z.c).Named("cptSprinklerPrior") ;
2018-10-24 19:25:14 -             rain= Variable.Array<Dirichlet>(z.c).Named("cptRainPrior");
2018-10-24 19:25:14 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-24 19:25:14 -                             Variable.Array<Dirichlet>(z.r), z.s).Named("cptWetGrassPrior")}
2018-10-24 19:25:14 -     priors
2018-10-24 19:28:33 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) =
2018-10-24 19:28:33 -     let parameters:DistributionParameters = {
2018-10-24 19:28:33 -         cloudy= Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy");
2018-10-24 19:28:33 -         sprinkler= Variable.Array<Vector>(rg.c).Named("cptSprinkler") ;
2018-10-24 19:28:33 -         rain= Variable.Array<Vector>(rg.c).Named("cptRain");
2018-10-24 19:28:33 -         wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-24 19:28:33 -                     Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")}
2018-10-24 19:28:33 -     parameters.cloudy.SetValueRange(rg.c)
2018-10-24 19:28:33 -     parameters.sprinkler.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c]))
2018-10-24 19:28:33 -     parameters.sprinkler.SetValueRange(rg.s)
2018-10-24 19:28:33 -     parameters.rain.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c]))
2018-10-24 19:28:33 -     parameters.rain.SetValueRange(rg.r)
2018-10-24 19:28:33 -     parameters.wetGrass.[rg.s].[rg.r].SetTo(Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r]))
2018-10-24 19:28:33 -     parameters.wetGrass.SetValueRange(rg.w)
2018-10-24 19:28:33 -     parameters        
2018-10-24 19:32:58 - let buildRandomVariables (n:Range) (parameters:DistributionParameters) =
2018-10-24 19:32:58 -     let cloudy:VariableArray<int> = Variable.Array<int>(n).Named("cloudy")
2018-10-24 19:32:58 -     let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy parameters.sprinkler).Named("sprinkler")
2018-10-24 19:32:58 -     let rain:VariableArray<int> = (AddChildFromOneParent cloudy parameters.rain).Named("rain")
2018-10-24 19:32:58 -     let wetGrass:VariableArray<int> = (AddChildFromTwoParents s r cptWetGrass).Named("wetGrass")
2018-10-24 19:32:58 -     {cloudy = cloudy; sprinkler =sprinkler; rain = rain; wetGrass = wetGrass}
2018-10-24 19:33:04 - The value or constructor 'AddChildFromOneParent' is not defined.
2018-10-24 19:33:04 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-24 19:33:04 - The value or constructor 'AddChildFromOneParent' is not defined.
2018-10-24 19:33:04 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-24 19:33:04 - The value or constructor 'AddChildFromTwoParents' is not defined.
2018-10-24 19:33:04 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-24 19:33:04 - The type 'VariableArray<int>' is not compatible with the type 'Dirichlet'
2018-10-24 19:33:04 - This expression was expected to have type
2018-10-24 19:33:04 -     'Dirichlet []'    
2018-10-24 19:33:04 - but here has type
2018-10-24 19:33:04 -     'VariableArray<int>'    
2018-10-24 19:33:04 - This expression was expected to have type
2018-10-24 19:33:04 -     'Dirichlet []'    
2018-10-24 19:33:04 - but here has type
2018-10-24 19:33:04 -     'VariableArray<int>'    
2018-10-24 19:33:04 - This expression was expected to have type
2018-10-24 19:33:04 -     'Dirichlet [] []'    
2018-10-24 19:33:04 - but here has type
2018-10-24 19:33:04 -     'VariableArray<int>'    
2018-10-24 19:38:13 - type Parent = VariableArray<int>
2018-10-24 19:38:13 - type Child = VariableArray<int>
2018-10-24 19:38:13 - type ParentCase = Variable<int>
2018-10-24 19:38:13 - type ConditionalProbabilityTable = VariableArray<Vector>
2018-10-24 19:38:13 - let AddChildFromOneParent (parent:Parent) (cpt:ConditionalProbabilityTable) =
2018-10-24 19:38:13 -     let r = parent.Range
2018-10-24 19:38:13 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-24 19:38:13 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:ParentCase) ->  
2018-10-24 19:38:13 -                        Variable.Discrete(cpt.[pi])))
2018-10-24 19:38:13 -     child
2018-10-24 19:38:18 - type ConditionalProbabilityTable2D:VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-24 19:38:18 - let AddChildFromTwoParents (parent1:Parent) (parent2:Parent) (cpt:ConditionalProbabilityTable2D) = 
2018-10-24 19:38:18 -     let r = parent1.Range
2018-10-24 19:38:18 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-24 19:38:18 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:ParentCase) ->  
2018-10-24 19:38:18 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:ParentCase) ->  
2018-10-24 19:38:18 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-24 19:38:18 -     child       
2018-10-24 19:38:19 - Unexpected symbol ':' in type definition. Expected '(' or other token.
2018-10-24 19:38:19 - parse error
2018-10-24 19:38:30 - type ConditionalProbabilityTable2D = VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-24 19:38:30 - let AddChildFromTwoParents (parent1:Parent) (parent2:Parent) (cpt:ConditionalProbabilityTable2D) = 
2018-10-24 19:38:30 -     let r = parent1.Range
2018-10-24 19:38:30 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-24 19:38:30 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:ParentCase) ->  
2018-10-24 19:38:30 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:ParentCase) ->  
2018-10-24 19:38:30 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-24 19:38:30 -     child       
2018-10-24 19:38:47 - let buildRandomVariables (n:Range) (parameters:DistributionParameters) =
2018-10-24 19:38:47 -     let cloudy:VariableArray<int> = Variable.Array<int>(n).Named("cloudy")
2018-10-24 19:38:47 -     let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy parameters.sprinkler).Named("sprinkler")
2018-10-24 19:38:47 -     let rain:VariableArray<int> = (AddChildFromOneParent cloudy parameters.rain).Named("rain")
2018-10-24 19:38:47 -     let wetGrass:VariableArray<int> = (AddChildFromTwoParents s r cptWetGrass).Named("wetGrass")
2018-10-24 19:38:47 -     {cloudy = cloudy; sprinkler =sprinkler; rain = rain; wetGrass = wetGrass}
2018-10-24 19:38:48 - The value or constructor 's' is not defined. Maybe you want one of the following:
2018-10-24 19:38:48 -    S
2018-10-24 19:38:48 -    SR
2018-10-24 19:38:48 -    MS
2018-10-24 19:38:48 -    C
2018-10-24 19:38:48 -    N
2018-10-24 19:38:48 - The value or constructor 'r' is not defined. Maybe you want one of the following:
2018-10-24 19:38:48 -    R
2018-10-24 19:38:48 -    SR
2018-10-24 19:38:48 -    or
2018-10-24 19:38:48 -    C
2018-10-24 19:38:48 -    N
2018-10-24 19:38:48 - The value or constructor 'cptWetGrass' is not defined.
2018-10-24 19:38:48 - The type 'VariableArray<int>' is not compatible with the type 'Dirichlet'
2018-10-24 19:38:48 - This expression was expected to have type
2018-10-24 19:38:48 -     'Dirichlet []'    
2018-10-24 19:38:48 - but here has type
2018-10-24 19:38:48 -     'VariableArray<int>'    
2018-10-24 19:38:48 - This expression was expected to have type
2018-10-24 19:38:48 -     'Dirichlet []'    
2018-10-24 19:38:48 - but here has type
2018-10-24 19:38:48 -     'VariableArray<int>'    
2018-10-24 19:38:48 - This expression was expected to have type
2018-10-24 19:38:48 -     'Dirichlet [] []'    
2018-10-24 19:38:48 - but here has type
2018-10-24 19:38:48 -     'VariableArray<int>'    
2018-10-24 19:39:24 - let buildRandomVariables (n:Range) (parameters:DistributionParameters) =
2018-10-24 19:39:24 -     let cloudy:VariableArray<int> = Variable.Array<int>(n).Named("cloudy")
2018-10-24 19:39:24 -     let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy parameters.sprinkler).Named("sprinkler")
2018-10-24 19:39:24 -     let rain:VariableArray<int> = (AddChildFromOneParent cloudy parameters.rain).Named("rain")
2018-10-24 19:39:24 -     let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain parameters.wetGrass).Named("wetGrass")
2018-10-24 19:39:24 -     {cloudy = cloudy; sprinkler =sprinkler; rain = rain; wetGrass = wetGrass}
2018-10-24 19:39:24 - The type 'VariableArray<int>' is not compatible with the type 'Dirichlet'
2018-10-24 19:39:24 - This expression was expected to have type
2018-10-24 19:39:24 -     'Dirichlet []'    
2018-10-24 19:39:24 - but here has type
2018-10-24 19:39:24 -     'VariableArray<int>'    
2018-10-24 19:39:24 - This expression was expected to have type
2018-10-24 19:39:24 -     'Dirichlet []'    
2018-10-24 19:39:24 - but here has type
2018-10-24 19:39:24 -     'VariableArray<int>'    
2018-10-24 19:39:24 - This expression was expected to have type
2018-10-24 19:39:24 -     'Dirichlet [] []'    
2018-10-24 19:39:24 - but here has type
2018-10-24 19:39:24 -     'VariableArray<int>'    
2018-10-24 19:42:09 - let (buildRandomVariables (n:Range) (cpt:DistributionParameters)):RandomVariables =
2018-10-24 19:42:09 -     let cloudy:VariableArray<int> = Variable.Array<int>(n).Named("cloudy")
2018-10-24 19:42:09 -     let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cpt.sprinkler).Named("sprinkler")
2018-10-24 19:42:09 -     let rain:VariableArray<int> = (AddChildFromOneParent cloudy cpt.rain).Named("rain")
2018-10-24 19:42:09 -     let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cpt.wetGrass).Named("wetGrass")
2018-10-24 19:42:09 -     {cloudy = cloudy; sprinkler =sprinkler; rain = rain; wetGrass = wetGrass}
2018-10-24 19:42:10 - The pattern discriminator 'buildRandomVariables' is not defined.
2018-10-24 19:42:34 - let buildRandomVariables (n:Range) (cpt:DistributionParameters) :RandomVariables =
2018-10-24 19:42:34 -     let cloudy:VariableArray<int> = Variable.Array<int>(n).Named("cloudy")
2018-10-24 19:42:34 -     let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cpt.sprinkler).Named("sprinkler")
2018-10-24 19:42:34 -     let rain:VariableArray<int> = (AddChildFromOneParent cloudy cpt.rain).Named("rain")
2018-10-24 19:42:34 -     let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cpt.wetGrass).Named("wetGrass")
2018-10-24 19:42:34 -     {cloudy = cloudy; sprinkler =sprinkler; rain = rain; wetGrass = wetGrass}
2018-10-24 19:42:49 - buildRandomVariables N parameters
2018-10-24 19:42:49 - Expression evaluation failed: cloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-24 19:42:49 - ArgumentExceptioncloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-24 19:42:49 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange (System.Boolean throwIfMissing) [0x00022] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:42:49 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange () [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:42:49 -   at Microsoft.ML.Probabilistic.Models.Variable.Switch (Microsoft.ML.Probabilistic.Models.Variable`1[T] i) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:42:49 -   at FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x00000] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:42:49 -   at FSI_0064+AddChildFromOneParent@7.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x00020] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:42:49 -   at FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:42:49 -   at FSI_0064.AddChildFromOneParent (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] cpt) [0x00016] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:42:49 -   at FSI_0069.buildRandomVariables (Microsoft.ML.Probabilistic.Models.Range n, FSI_0034+DistributionParameters cpt) [0x00017] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:42:49 -   at <StartupCode$FSI_0070>.$FSI_0070.main@ () [0x0000a] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:42:49 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-24 19:42:49 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-24 19:43:14 - let rvs = buildRandomVariables N parameters
2018-10-24 19:43:15 - Expression evaluation failed: Range 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-24 19:43:15 - InvalidOperationExceptionRange 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-24 19:43:15 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0008f] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:43:15 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:43:15 -   at Microsoft.ML.Probabilistic.Models.VariableArray`1[T]..ctor (Microsoft.ML.Probabilistic.Models.Range range) [0x00006] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:43:15 -   at Microsoft.ML.Probabilistic.Models.Variable.Array[T] (Microsoft.ML.Probabilistic.Models.Range r) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:43:15 -   at FSI_0069.buildRandomVariables (Microsoft.ML.Probabilistic.Models.Range n, FSI_0034+DistributionParameters cpt) [0x00000] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:43:15 -   at <StartupCode$FSI_0071>.$FSI_0071.main@ () [0x0000a] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:43:15 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-24 19:43:15 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-24 19:43:32 - let NumberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-24 19:43:32 - let N:Range = Range(NumberOfExamples).Named("N")
2018-10-24 19:43:49 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-24 19:43:49 - let n:Range = Range(NumberOfExamples).Named("N")
2018-10-24 19:44:27 - let rvs = buildRandomVariables n parameters
2018-10-24 19:44:28 - Expression evaluation failed: cloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-24 19:44:28 - ArgumentExceptioncloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-24 19:44:28 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange (System.Boolean throwIfMissing) [0x00022] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:44:28 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange () [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:44:28 -   at Microsoft.ML.Probabilistic.Models.Variable.Switch (Microsoft.ML.Probabilistic.Models.Variable`1[T] i) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:44:28 -   at FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x00000] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:44:28 -   at FSI_0064+AddChildFromOneParent@7.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x00020] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:44:28 -   at FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:44:28 -   at FSI_0064.AddChildFromOneParent (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] cpt) [0x00016] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:44:28 -   at FSI_0069.buildRandomVariables (Microsoft.ML.Probabilistic.Models.Range n, FSI_0034+DistributionParameters cpt) [0x00017] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:44:28 -   at <StartupCode$FSI_0074>.$FSI_0074.main@ () [0x0000a] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:44:28 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-24 19:44:28 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-24 19:46:29 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-24 19:46:29 - let n:Range = Range(NumberOfExamples).Named("N")
2018-10-24 19:46:29 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-24 19:46:29 - let priors = buildPriors ranges
2018-10-24 19:46:29 - let parameters = buildDistributionParameters ranges priors
2018-10-24 19:46:54 - let rvs = buildRandomVariables n parameters
2018-10-24 19:46:55 - Expression evaluation failed: cloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-24 19:46:55 - ArgumentExceptioncloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-24 19:46:55 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange (System.Boolean throwIfMissing) [0x00022] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:46:55 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange () [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:46:55 -   at Microsoft.ML.Probabilistic.Models.Variable.Switch (Microsoft.ML.Probabilistic.Models.Variable`1[T] i) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:46:55 -   at FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x00000] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:46:55 -   at FSI_0064+AddChildFromOneParent@7.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x00020] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:46:55 -   at FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:46:55 -   at FSI_0064.AddChildFromOneParent (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] cpt) [0x00016] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:46:55 -   at FSI_0069.buildRandomVariables (Microsoft.ML.Probabilistic.Models.Range n, FSI_0034+DistributionParameters cpt) [0x00017] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:46:55 -   at <StartupCode$FSI_0076>.$FSI_0076.main@ () [0x0000a] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:46:55 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-24 19:46:55 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-24 19:48:00 - type Parent = VariableArray<int>
2018-10-24 19:48:00 - type Child = VariableArray<int>
2018-10-24 19:48:00 - type ParentCase = Variable<int>
2018-10-24 19:48:00 - type ConditionalProbabilityTable = VariableArray<Vector>
2018-10-24 19:48:20 - let AddChildFromOneParent (parent:Parent) (cpt:ConditionalProbabilityTable) =
2018-10-24 19:48:20 -     let r = parent.Range
2018-10-24 19:48:20 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-24 19:48:20 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:ParentCase) ->  
2018-10-24 19:48:20 -                        Variable.Discrete(cpt.[pi])))
2018-10-24 19:48:20 -     child
2018-10-24 19:48:21 - type ConditionalProbabilityTable2D = VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-24 19:48:22 - let AddChildFromTwoParents (parent1:Parent) (parent2:Parent) (cpt:ConditionalProbabilityTable2D) = 
2018-10-24 19:48:22 -     let r = parent1.Range
2018-10-24 19:48:22 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-24 19:48:22 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:ParentCase) ->  
2018-10-24 19:48:22 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:ParentCase) ->  
2018-10-24 19:48:22 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-24 19:48:22 -     child       
2018-10-24 19:53:02 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) =
2018-10-24 19:53:02 -     let probCloudy= Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy");
2018-10-24 19:53:02 -     let cptSprinkler= Variable.Array<Vector>(rg.c).Named("cptSprinkler") ;
2018-10-24 19:53:02 -     let cptRain= Variable.Array<Vector>(rg.c).Named("cptRain");
2018-10-24 19:53:02 -     let cptWetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-24 19:53:02 -                     Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-24 19:53:02 -     probCloudy.SetValueRange(rg.c)
2018-10-24 19:53:02 -     cptSprinkler.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c]))
2018-10-24 19:53:02 -     cptSprinkler.SetValueRange(rg.s)
2018-10-24 19:53:02 -     cptRain.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c]))
2018-10-24 19:53:02 -     cptRain.SetValueRange(rg.r)
2018-10-24 19:53:02 -     cptWetGrass.[rg.s].[rg.r].SetTo(Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r]))
2018-10-24 19:53:02 -     cptWetGrass.SetValueRange(rg.w)
2018-10-24 19:53:02 -     {cloudy = probCloudy; sprinkler =cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-24 19:53:03 - Possible incorrect indentation: this token is offside of context started at position (5:22). Try indenting this token further or using standard formatting conventions.
2018-10-24 19:53:03 - Possible incorrect indentation: this token is offside of context started at position (5:22). Try indenting this token further or using standard formatting conventions.
2018-10-24 19:53:03 - The type 'Variable<Vector>' is not compatible with the type 'Dirichlet'
2018-10-24 19:53:03 - This expression was expected to have type
2018-10-24 19:53:03 -     'Dirichlet []'    
2018-10-24 19:53:03 - but here has type
2018-10-24 19:53:03 -     'VariableArray<Vector>'    
2018-10-24 19:53:03 - This expression was expected to have type
2018-10-24 19:53:03 -     'Dirichlet []'    
2018-10-24 19:53:03 - but here has type
2018-10-24 19:53:03 -     'VariableArray<Vector>'    
2018-10-24 19:53:03 - This expression was expected to have type
2018-10-24 19:53:03 -     'Dirichlet [] []'    
2018-10-24 19:53:03 - but here has type
2018-10-24 19:53:03 -     'VariableArray<VariableArray<Vector>,Vector [] []>'    
2018-10-24 19:53:29 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) =
2018-10-24 19:53:29 -     let probCloudy= Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-24 19:53:29 -     let cptSprinkler= Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-24 19:53:29 -     let cptRain= Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-24 19:53:29 -     let cptWetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-24 19:53:29 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-24 19:53:29 -     probCloudy.SetValueRange(rg.c)
2018-10-24 19:53:29 -     cptSprinkler.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c]))
2018-10-24 19:53:29 -     cptSprinkler.SetValueRange(rg.s)
2018-10-24 19:53:29 -     cptRain.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c]))
2018-10-24 19:53:29 -     cptRain.SetValueRange(rg.r)
2018-10-24 19:53:29 -     cptWetGrass.[rg.s].[rg.r].SetTo(Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r]))
2018-10-24 19:53:29 -     cptWetGrass.SetValueRange(rg.w)
2018-10-24 19:53:29 -     {cloudy = probCloudy; sprinkler =cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-24 19:53:30 - The type 'Variable<Vector>' is not compatible with the type 'Dirichlet'
2018-10-24 19:53:30 - This expression was expected to have type
2018-10-24 19:53:30 -     'Dirichlet []'    
2018-10-24 19:53:30 - but here has type
2018-10-24 19:53:30 -     'VariableArray<Vector>'    
2018-10-24 19:53:30 - This expression was expected to have type
2018-10-24 19:53:30 -     'Dirichlet []'    
2018-10-24 19:53:30 - but here has type
2018-10-24 19:53:30 -     'VariableArray<Vector>'    
2018-10-24 19:53:30 - This expression was expected to have type
2018-10-24 19:53:30 -     'Dirichlet [] []'    
2018-10-24 19:53:30 - but here has type
2018-10-24 19:53:30 -     'VariableArray<VariableArray<Vector>,Vector [] []>'    
2018-10-24 19:55:32 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-24 19:55:32 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-24 19:55:32 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-24 19:55:32 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-24 19:55:32 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-24 19:55:32 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-24 19:55:32 -     probCloudy.SetValueRange(rg.c)
2018-10-24 19:55:32 -     cptSprinkler.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c]))
2018-10-24 19:55:32 -     cptSprinkler.SetValueRange(rg.s)
2018-10-24 19:55:32 -     cptRain.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c]))
2018-10-24 19:55:32 -     cptRain.SetValueRange(rg.r)
2018-10-24 19:55:32 -     cptWetGrass.[rg.s].[rg.r].SetTo(Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r]))
2018-10-24 19:55:32 -     cptWetGrass.SetValueRange(rg.w)
2018-10-24 19:55:32 -     {cloudy = probCloudy; sprinkler =cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-24 19:55:44 - let parameters = buildDistributionParameters ranges priors
2018-10-24 19:56:19 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-24 19:56:19 - let n:Range = Range(NumberOfExamples).Named("N")
2018-10-24 19:56:19 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-24 19:56:19 - let priors = buildPriors ranges
2018-10-24 19:56:19 - let parameters = buildDistributionParameters ranges priors
2018-10-24 19:56:23 - let rvs = buildRandomVariables n parameters
2018-10-24 19:56:23 - Expression evaluation failed: cloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-24 19:56:23 - ArgumentExceptioncloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-24 19:56:23 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange (System.Boolean throwIfMissing) [0x00022] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:56:23 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange () [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:56:23 -   at Microsoft.ML.Probabilistic.Models.Variable.Switch (Microsoft.ML.Probabilistic.Models.Variable`1[T] i) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:56:23 -   at FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x00000] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:56:23 -   at FSI_0064+AddChildFromOneParent@7.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x00020] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:56:23 -   at FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:56:23 -   at FSI_0064.AddChildFromOneParent (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] cpt) [0x00016] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:56:23 -   at FSI_0069.buildRandomVariables (Microsoft.ML.Probabilistic.Models.Range n, FSI_0034+DistributionParameters cpt) [0x00017] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:56:23 -   at <StartupCode$FSI_0086>.$FSI_0086.main@ () [0x0000a] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:56:23 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-24 19:56:23 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-24 19:58:14 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-24 19:58:14 - let n:Range = Range(NumberOfExamples).Named("Noo")
2018-10-24 19:58:14 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-24 19:58:14 - let priors = buildPriors ranges
2018-10-24 19:58:14 - let parameters = buildDistributionParameters ranges priors
2018-10-24 19:58:18 - let rvs = buildRandomVariables n parameters
2018-10-24 19:58:19 - Expression evaluation failed: cloudy[Noo] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-24 19:58:19 - ArgumentExceptioncloudy[Noo] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-24 19:58:19 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange (System.Boolean throwIfMissing) [0x00022] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:58:19 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange () [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:58:19 -   at Microsoft.ML.Probabilistic.Models.Variable.Switch (Microsoft.ML.Probabilistic.Models.Variable`1[T] i) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-24 19:58:19 -   at FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x00000] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:58:19 -   at FSI_0064+AddChildFromOneParent@7.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x00020] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:58:19 -   at FSI_0030.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:58:19 -   at FSI_0064.AddChildFromOneParent (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] cpt) [0x00016] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:58:19 -   at FSI_0069.buildRandomVariables (Microsoft.ML.Probabilistic.Models.Range n, FSI_0034+DistributionParameters cpt) [0x00017] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:58:19 -   at <StartupCode$FSI_0088>.$FSI_0088.main@ () [0x0000a] in <c24438e3077f4925bc3ffa20c8632319>:0 
2018-10-24 19:58:19 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-24 19:58:19 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-24 19:59:11 - ranges
2018-10-24 19:59:22 - priors
2018-10-24 19:59:31 - parameters
2018-10-24 19:59:48 - priors
2018-10-24 20:02:49 - let buildRandomVariables (n:Range) (cpt:DistributionParameters) :RandomVariables =
2018-10-24 20:02:49 -     let cloudy:VariableArray<int> = Variable.Array<int>(n).Named("cloudy")
2018-10-24 20:02:49 -     cloudy.[n].SetTo(Variable.Discrete(probCloudy).ForEach(n))
2018-10-24 20:02:49 -     let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cpt.sprinkler).Named("sprinkler")
2018-10-24 20:02:49 -     let rain:VariableArray<int> = (AddChildFromOneParent cloudy cpt.rain).Named("rain")
2018-10-24 20:02:49 -     let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cpt.wetGrass).Named("wetGrass")
2018-10-24 20:02:49 -     {cloudy = cloudy; sprinkler =sprinkler; rain = rain; wetGrass = wetGrass}
2018-10-24 20:02:51 - The value or constructor 'probCloudy' is not defined.
2018-10-24 20:02:51 - A unique overload for method 'Discrete' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Discrete([<ParamArray>] probs: float []) : Variable<int>, Variable.Discrete([<ParamArray>] probs: float []) : Variable<int>, Variable.Discrete(probs: Variable<Vector>) : Variable<int>, Variable.Discrete(v: Vector) : Variable<int>, Variable.Discrete(valueRange: Range, [<ParamArray>] probs: float []) : Variable<int>
2018-10-24 20:04:42 - let buildRandomVariables (n:Range) (params:DistributionParameters) :RandomVariables =
2018-10-24 20:04:42 -     let cloudy: VariableArray<int> = Variable.Array<int>(n).Named("cloudy")
2018-10-24 20:04:42 -     cloudy.[n].SetTo(Variable.Discrete(params.cloudy).ForEach(n))
2018-10-24 20:04:42 -     let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy params.sprinkler).Named("sprinkler")
2018-10-24 20:04:42 -     let rain:VariableArray<int> = (AddChildFromOneParent cloudy params.rain).Named("rain")
2018-10-24 20:04:42 -     let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain params.wetGrass).Named("wetGrass")
2018-10-24 20:04:42 -     {cloudy = cloudy; sprinkler =sprinkler; rain = rain; wetGrass = wetGrass}
2018-10-24 20:04:43 - The identifier 'params' is reserved for future use by F#
2018-10-24 20:04:43 - The identifier 'params' is reserved for future use by F#
2018-10-24 20:04:43 - The identifier 'params' is reserved for future use by F#
2018-10-24 20:04:43 - The identifier 'params' is reserved for future use by F#
2018-10-24 20:04:43 - The identifier 'params' is reserved for future use by F#
2018-10-24 20:05:38 - let buildRandomVariables (n:Range) (paramz:DistributionParameters) :RandomVariables =
2018-10-24 20:05:38 -     let cloudy: VariableArray<int> = Variable.Array<int>(n).Named("cloudy")
2018-10-24 20:05:38 -     cloudy.[n].SetTo(Variable.Discrete(paramz.cloudy).ForEach(n))
2018-10-24 20:05:38 -     let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy paramz.sprinkler).Named("sprinkler")
2018-10-24 20:05:38 -     let rain:VariableArray<int> = (AddChildFromOneParent cloudy paramz.rain).Named("rain")
2018-10-24 20:05:38 -     let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain paramz.wetGrass).Named("wetGrass")
2018-10-24 20:05:38 -     {cloudy = cloudy; sprinkler =sprinkler; rain = rain; wetGrass = wetGrass}
2018-10-24 20:05:49 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-24 20:05:49 - let n:Range = Range(NumberOfExamples).Named("N")
2018-10-24 20:05:49 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-24 20:05:49 - let priors = buildPriors ranges
2018-10-24 20:05:49 - let parameters = buildDistributionParameters ranges priors
2018-10-24 20:06:01 - parameters
2018-10-24 20:06:11 - let rvs = buildRandomVariables n parameters
2018-10-24 20:15:37 - ObservedValues
2018-10-24 20:15:39 - The value or constructor 'ObservedValues' is not defined.
2018-10-24 20:16:51 - let z:ObservedValues = 3
2018-10-24 20:16:52 - This expression was expected to have type
2018-10-24 20:16:52 -     'ObservedValues'    
2018-10-24 20:16:52 - but here has type
2018-10-24 20:16:52 -     'int'    
2018-10-24 20:17:00 - let z:ObservedValues = {}
2018-10-24 20:17:01 - '{ }' is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list '[]'.
2018-10-24 20:17:12 - let z:ObservedValues = {cloudy= 2}
2018-10-24 20:17:13 - This expression was expected to have type
2018-10-24 20:17:13 -     'int array'    
2018-10-24 20:17:13 - but here has type
2018-10-24 20:17:13 -     'int'    
2018-10-24 20:17:13 - No assignment given for field 'sprinkler' of type 'FSI_0033.ObservedValues'
2018-10-24 20:30:52 - let probCloudy = Vector.FromArray(0.5, 0.5)
2018-10-24 20:30:52 - let cptSprinkler = [| Vector.FromArray(0.1, 0.9) (* cloudy *); Vector.FromArray(0.5, 0.5) (* not cloudy *) |]
2018-10-24 20:30:52 - let cptRain = [| Vector.FromArray(0.8, 0.2) (* cloudy *); Vector.FromArray(0.2, 0.8) (* not cloudy *)|]
2018-10-24 20:31:05 - probCloudy.GetType()
2018-10-24 20:31:23 - let probCloudy:DenseVector = Vector.FromArray(0.5, 0.5)
2018-10-24 20:31:23 - let cptSprinkler = [| Vector.FromArray(0.1, 0.9) (* cloudy *); Vector.FromArray(0.5, 0.5) (* not cloudy *) |]
2018-10-24 20:31:23 - let cptRain = [| Vector.FromArray(0.8, 0.2) (* cloudy *); Vector.FromArray(0.2, 0.8) (* not cloudy *)|]
2018-10-24 20:31:24 - This expression was expected to have type
2018-10-24 20:31:24 -     'DenseVector'    
2018-10-24 20:31:24 - but here has type
2018-10-24 20:31:24 -     'Vector'    
2018-10-24 20:31:31 - let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-24 20:31:31 - let cptSprinkler = [| Vector.FromArray(0.1, 0.9) (* cloudy *); Vector.FromArray(0.5, 0.5) (* not cloudy *) |]
2018-10-24 20:31:31 - let cptRain = [| Vector.FromArray(0.8, 0.2) (* cloudy *); Vector.FromArray(0.2, 0.8) (* not cloudy *)|]
2018-10-24 20:31:37 - let probCloudy = Vector.FromArray(0.5, 0.5)
2018-10-24 20:31:37 - let cptSprinkler = [| Vector.FromArray(0.1, 0.9) (* cloudy *); Vector.FromArray(0.5, 0.5) (* not cloudy *) |]
2018-10-24 20:31:37 - let cptRain = [| Vector.FromArray(0.8, 0.2) (* cloudy *); Vector.FromArray(0.2, 0.8) (* not cloudy *)|]
2018-10-24 20:31:44 - cptSprinkler.GetType()
2018-10-24 21:24:39 - type DistributionParameterValues =  
2018-10-24 21:24:39 -     {cloudy:Vector;     // probCloudy
2018-10-24 21:24:39 -     sprinkler:Vector[]; // cptSprinkler
2018-10-24 21:24:39 -     rain:Vector[];      // cptRain
2018-10-24 21:24:39 -     wetGrass:Vector[][] // cptWetGrass 
2018-10-24 21:24:39 -     }
2018-10-24 21:26:47 - type DistributionParameterValues =  
2018-10-24 21:26:47 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-24 21:26:47 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-24 21:26:47 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-24 21:26:47 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-24 21:26:47 -     }
2018-10-24 21:33:05 - let cptWetGrass = 
2018-10-24 21:33:05 -     [|  [| 0.99; 0.01|] (* rain *); [| 0.9, 0.1 |] (* not rain *) |]; // Sprinkler
2018-10-24 21:33:05 -         [|  0.9; 0.1 |] (* rain *); [| 0.0, 1.0 |] (* not rain *) |]  // Not sprinkler  |]
2018-10-24 21:33:05 -     |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-24 21:33:06 - Unexpected symbol '|]' in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-24 21:33:24 - let cptWetGrass = 
2018-10-24 21:33:24 -     [|  [| 0.99; 0.01|] (* rain *); [| 0.9; 0.1 |] (* not rain *) |]; // Sprinkler
2018-10-24 21:33:24 -         [|  0.9; 0.1 |] (* rain *); [| 0.0; 1.0 |] (* not rain *) |]  // Not sprinkler  |]
2018-10-24 21:33:24 -     |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-24 21:33:24 - Unexpected symbol '|]' in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-24 21:34:11 - let cptWetGrass: float[][] = 
2018-10-24 21:34:11 -     [|  [| 0.99; 0.01|] (* rain *); [| 0.9; 0.1 |] (* not rain *) |]; // Sprinkler
2018-10-24 21:34:11 -         [|  0.9; 0.1 |] (* rain *); [| 0.0; 1.0 |] (* not rain *) |]  // Not sprinkler  |]
2018-10-24 21:34:11 -     |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-24 21:34:12 - Unexpected symbol '|]' in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-24 21:35:08 - let cptWetGrass: float[][] = 
2018-10-24 21:35:08 -     [|  [|  [| 0.99; 0.01|] (* rain *); [| 0.9; 0.1 |] (* not rain *) |]; // Sprinkler
2018-10-24 21:35:08 -             [|  0.9; 0.1 |] (* rain *); [| 0.0; 1.0 |] (* not rain *) |]  // Not sprinkler  |]
2018-10-24 21:35:08 -     |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-24 21:35:09 - This expression was expected to have type
2018-10-24 21:35:09 -     'float []'    
2018-10-24 21:35:09 - but here has type
2018-10-24 21:35:09 -     'float'    
2018-10-24 21:35:09 - All elements of an array constructor expression must have the same type. This expression was expected to have type 'float []', but here has type 'float'.
2018-10-24 21:35:09 - This expression was expected to have type
2018-10-24 21:35:09 -     'float []'    
2018-10-24 21:35:09 - but here has type
2018-10-24 21:35:09 -     'float'    
2018-10-24 21:35:09 - All elements of an array constructor expression must have the same type. This expression was expected to have type 'float []', but here has type 'float'.
2018-10-24 21:35:09 - This expression was expected to have type
2018-10-24 21:35:09 -     'float'    
2018-10-24 21:35:09 - but here has type
2018-10-24 21:35:09 -     'Vector'    
2018-10-24 21:35:21 - let cptWetGrass: float[][][] = 
2018-10-24 21:35:21 -     [|  [|  [| 0.99; 0.01|] (* rain *); [| 0.9; 0.1 |] (* not rain *) |]; // Sprinkler
2018-10-24 21:35:21 -             [|  0.9; 0.1 |] (* rain *); [| 0.0; 1.0 |] (* not rain *) |]  // Not sprinkler  |]
2018-10-24 21:35:21 -     |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-24 21:35:22 - This expression was expected to have type
2018-10-24 21:35:22 -     'float []'    
2018-10-24 21:35:22 - but here has type
2018-10-24 21:35:22 -     'float'    
2018-10-24 21:35:22 - All elements of an array constructor expression must have the same type. This expression was expected to have type 'float []', but here has type 'float'.
2018-10-24 21:35:22 - This expression was expected to have type
2018-10-24 21:35:22 -     'float []'    
2018-10-24 21:35:22 - but here has type
2018-10-24 21:35:22 -     'float'    
2018-10-24 21:35:22 - All elements of an array constructor expression must have the same type. This expression was expected to have type 'float []', but here has type 'float'.
2018-10-24 21:35:22 - This expression was expected to have type
2018-10-24 21:35:22 -     'float []'    
2018-10-24 21:35:22 - but here has type
2018-10-24 21:35:22 -     'Vector'    
2018-10-24 21:35:38 - let cptWetGrass: float[][][] = 
2018-10-24 21:35:38 -     [|  [|  [| 0.99; 0.01|] (* rain *); [| 0.9; 0.1 |] (* not rain *) |]; // Sprinkler
2018-10-24 21:35:38 -             [|  0.9; 0.1 |] (* rain *); [| 0.0; 1.0 |] (* not rain *) |]  // Not sprinkler  |]
2018-10-24 21:35:38 -     //|> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-24 21:35:38 - This expression was expected to have type
2018-10-24 21:35:38 -     'float []'    
2018-10-24 21:35:38 - but here has type
2018-10-24 21:35:38 -     'float'    
2018-10-24 21:35:38 - All elements of an array constructor expression must have the same type. This expression was expected to have type 'float []', but here has type 'float'.
2018-10-24 21:35:38 - This expression was expected to have type
2018-10-24 21:35:38 -     'float []'    
2018-10-24 21:35:38 - but here has type
2018-10-24 21:35:38 -     'float'    
2018-10-24 21:35:38 - All elements of an array constructor expression must have the same type. This expression was expected to have type 'float []', but here has type 'float'.
2018-10-24 21:36:41 - let cptWetGrass: float[][][] = 
2018-10-24 21:36:41 -     [|  [|  [| 0.99; 0.01|] (* rain *); [| 0.9; 0.1 |] (* not rain *) |]; // Sprinkler
2018-10-24 21:36:41 -         [|  [|  0.9; 0.1 |] (* rain *); [| 0.0; 1.0 |] (* not rain *) |]  // Not sprinkler  |]
2018-10-24 21:36:41 -     //|> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-24 21:36:42 - Incomplete structured construct at or before this point in binding. Expected '|]' or other token.
2018-10-24 21:36:42 - Unmatched '[|'
2018-10-24 21:37:00 - let cptWetGrass: float[][][] = 
2018-10-24 21:37:00 -     [|  [|  [| 0.99; 0.01|] (* rain *); [| 0.9; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-24 21:37:00 -         [|  [|  0.9; 0.1 |] (* rain *); [| 0.0; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-24 21:37:00 -     //|> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-24 21:37:16 - let cptWetGrass = 
2018-10-24 21:37:16 -     [|  [|  [| 0.99; 0.01|] (* rain *); [| 0.9; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-24 21:37:16 -         [|  [|  0.9; 0.1 |] (* rain *); [| 0.0; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-24 21:37:16 -     |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-24 21:37:31 - cptWetGrass.GetType()
2018-10-24 21:37:49 - let cptWetGrass:Vector[][] = 
2018-10-24 21:37:49 -     [|  [|  [| 0.99; 0.01|] (* rain *); [| 0.9; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-24 21:37:49 -         [|  [|  0.9; 0.1 |] (* rain *); [| 0.0; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-24 21:37:49 -     |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-24 21:39:08 - let cptWetGrass:Vector[][] = 
2018-10-24 21:39:08 -     [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-24 21:39:08 -             [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-24 21:39:08 -         [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-24 21:39:08 -             [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-24 21:39:08 -     |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-24 21:45:47 - let probCloudy = Vector.FromArray(0.5, 0.5)
2018-10-24 21:45:47 - let cptSprinkler = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-24 21:45:47 - let cptRain =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-24 21:47:24 - let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-24 21:47:24 - let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-24 21:47:24 - let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-24 21:47:48 - let cptWetGrass:Vector[][] = 
2018-10-24 21:47:48 -     [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-24 21:47:48 -             [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-24 21:47:48 -         [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-24 21:47:48 -             [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-24 21:47:48 -     |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-24 21:50:32 - let setDistributionParameters () =
2018-10-24 21:50:32 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-24 21:50:32 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-24 21:50:32 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-24 21:50:32 -     let cptWetGrass:Vector[][] = 
2018-10-24 21:50:32 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-24 21:50:32 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-24 21:50:32 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-24 21:50:32 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-24 21:50:32 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-24 21:50:32 -     {cloudy= probCloudy
2018-10-24 21:50:32 -         sprinkler= cptSprinkler
2018-10-24 21:50:32 -         rain = cptRain
2018-10-24 21:50:32 -         wetGrass =  cptWetGrass }
2018-10-24 21:50:33 - The type 'bool' is not compatible with the type 'Vector'
2018-10-24 21:50:33 - This value is not a function and cannot be applied.
2018-10-24 21:50:33 - This value is not a function and cannot be applied.
2018-10-24 21:50:33 - This value is not a function and cannot be applied.
2018-10-24 21:50:33 - This expression was expected to have type
2018-10-24 21:50:33 -     'bool'    
2018-10-24 21:50:33 - but here has type
2018-10-24 21:50:33 -     'Vector [] []'    
2018-10-24 21:50:33 - No assignment given for field 'sprinkler' of type 'FSI_0117.DistributionParameterValues'
2018-10-24 21:51:37 - let setDistributionParameters () =
2018-10-24 21:51:37 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-24 21:51:37 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-24 21:51:37 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-24 21:51:37 -     let cptWetGrass:Vector[][] = 
2018-10-24 21:51:37 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-24 21:51:37 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-24 21:51:37 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-24 21:51:37 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-24 21:51:37 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-24 21:51:37 -     {cloudy= probCloudy;
2018-10-24 21:51:37 -         sprinkler= cptSprinkler;
2018-10-24 21:51:37 -         rain = cptRain;
2018-10-24 21:51:37 -         wetGrass =  cptWetGrass }
2018-10-24 21:51:52 - setDistributionParameters()
2018-10-24 21:52:57 - let setDistributionParameterValues ():DistributionParameterValues =
2018-10-24 21:52:57 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-24 21:52:57 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-24 21:52:57 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-24 21:52:57 -     let cptWetGrass:Vector[][] = 
2018-10-24 21:52:57 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-24 21:52:57 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-24 21:52:57 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-24 21:52:57 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-24 21:52:57 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-24 21:52:57 -     {cloudy= probCloudy;
2018-10-24 21:52:57 -         sprinkler= cptSprinkler;
2018-10-24 21:52:57 -         rain = cptRain;
2018-10-24 21:52:57 -         wetGrass =  cptWetGrass }
2018-10-24 21:53:04 - setDistributionParameterValues()
2018-10-25 14:09:31 - type Parent = VariableArray<int>
2018-10-25 14:09:31 - type Child = VariableArray<int>
2018-10-25 14:09:31 - type ParentCase = Variable<int>
2018-10-25 14:09:31 - type ConditionalProbabilityTable = VariableArray<Vector>
2018-10-25 14:09:32 - let AddChildFromOneParent (parent:Parent) (cpt:ConditionalProbabilityTable) =
2018-10-25 14:09:32 -     let r = parent.Range
2018-10-25 14:09:32 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-25 14:09:32 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:ParentCase) ->  
2018-10-25 14:09:32 -                        Variable.Discrete(cpt.[pi])))
2018-10-25 14:09:32 -     child
2018-10-25 14:09:32 - type ConditionalProbabilityTable2D = VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-25 14:09:32 - let AddChildFromTwoParents (parent1:Parent) (parent2:Parent) (cpt:ConditionalProbabilityTable2D) = 
2018-10-25 14:09:32 -     let r = parent1.Range
2018-10-25 14:09:32 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-25 14:09:32 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:ParentCase) ->  
2018-10-25 14:09:32 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:ParentCase) ->  
2018-10-25 14:09:32 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-25 14:09:32 -     child       
2018-10-25 14:09:33 - let engine =  InferenceEngine ()
2018-10-25 14:09:33 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 14:09:33 - let n:Range = Range(NumberOfExamples).Named("N")
2018-10-25 14:09:33 - let C = Range(2).Named("C") // Cloudy
2018-10-25 14:09:33 - let S = Range(2).Named("S") // Sprinkler
2018-10-25 14:09:33 - let R = Range(2).Named("R") // Rain
2018-10-25 14:09:33 - let W = Range(2).Named("W") // Wet
2018-10-25 14:09:33 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-25 14:09:33 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-25 14:09:33 - probCloudy.SetValueRange(C)
2018-10-25 14:09:33 - let cptSprinklerPrior = Variable.Array<Dirichlet>(C).Named("cptSprinklerPrior")
2018-10-25 14:09:33 - let cptSprinkler = Variable.Array<Vector>(C).Named("cptSprinkler")
2018-10-25 14:09:34 - cptSprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[C]))
2018-10-25 14:09:34 - cptSprinkler.SetValueRange(S)
2018-10-25 14:09:34 - let cptRainPrior = Variable.Array<Dirichlet>(C).Named("cptRainPrior")
2018-10-25 14:09:34 - let cptRain = Variable.Array<Vector>(C).Named("cptRain")
2018-10-25 14:09:34 - cptRain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(cptRainPrior.[C]))
2018-10-25 14:09:34 - cptRain.SetValueRange(R)
2018-10-25 14:09:34 - let cptWetGrassPrior= 
2018-10-25 14:09:34 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 14:09:34 -         Variable.Array<Dirichlet>(R), S).Named("cptWetGrassPrior")
2018-10-25 14:09:34 - let cptWetGrass = 
2018-10-25 14:09:34 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-25 14:09:34 -         Variable.Array<Vector>(R), S).Named("cptWetGrass")
2018-10-25 14:09:34 - cptWetGrass.[S].[R].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[S].[R]))
2018-10-25 14:09:34 - cptWetGrass.SetValueRange(W)
2018-10-25 14:09:35 - let cloudy = Variable.Array<int>(n).Named("cloudy")
2018-10-25 14:09:35 - cloudy.[n].SetTo(Variable.Discrete(probCloudy).ForEach(n))
2018-10-25 14:09:35 - Reporting 0 opened comms
2018-10-25 14:18:31 - Translated from the C#: a couple of helper methods
2018-10-25 14:18:32 - Identifiers followed by '#' are reserved for future use
2018-10-25 14:18:32 - Unexpected symbol ':' in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2018-10-25 14:18:32 - parse error
2018-10-25 14:49:37 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-25 14:49:37 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-25 14:49:37 - For help type #help;;
2018-10-25 14:49:37 - > val it :
2018-10-25 14:49:37 -   ResizeArray<System.Type *
2018-10-25 14:49:37 -               (obj ->
2018-10-25 14:49:37 -                  seq<string *
2018-10-25 14:49:37 -                      string> *
2018-10-25 14:49:37 -                  string)>
2018-10-25 14:49:37 - = seq []
2018-10-25 14:49:37 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-25 14:49:37 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-25 14:49:37 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-25 14:49:37 - Reporting 0 opened comms
2018-10-25 15:42:09 - shutdown request
2018-10-25 15:42:18 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-25 15:42:18 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-25 15:42:18 - For help type #help;;
2018-10-25 15:42:18 - > val it :
2018-10-25 15:42:18 -   ResizeArray<System.Type *
2018-10-25 15:42:18 -               (obj ->
2018-10-25 15:42:18 -                  seq<string *
2018-10-25 15:42:18 -                      string> *
2018-10-25 15:42:18 -                  string)>
2018-10-25 15:42:18 - = seq []
2018-10-25 15:42:18 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-25 15:42:18 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-25 15:42:18 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-25 15:42:18 - let ProbRain cloudy:Option<int> sprinkler:Option<int> = ()
2018-10-25 15:42:19 - Syntax error in labelled type argument
2018-10-25 15:42:19 - #load "Paket.fsx"
2018-10-25 15:42:26 - Paket.Package
2018-10-25 15:42:26 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-25 15:42:26 -       "Microsoft.ML.Probabilistic"
2018-10-25 15:42:26 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-25 15:42:26 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-25 15:42:26 -       "NETStandard.Library"
2018-10-25 15:42:26 -   ]
2018-10-25 15:42:48 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-25 15:42:50 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-25 15:42:58 - //#load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-25 15:42:58 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-25 15:42:58 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-25 15:42:58 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-25 15:42:58 - #r "Microsoft.ML.Probabilistic"
2018-10-25 15:42:58 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-25 15:42:58 - #r "netstandard"
2018-10-25 15:42:59 - open System
2018-10-25 15:42:59 - open Microsoft.ML.Probabilistic  
2018-10-25 15:42:59 - open Microsoft.ML.Probabilistic.Models  
2018-10-25 15:42:59 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-25 15:42:59 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-25 15:42:59 - open Microsoft.ML.Probabilistic.Math
2018-10-25 15:42:59 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-25 15:43:00 - open Microsoft.ML.Probabilistic.FSharp
2018-10-25 15:43:00 - type Parent = VariableArray<int>
2018-10-25 15:43:00 - type Child = VariableArray<int>
2018-10-25 15:43:00 - type ParentCase = Variable<int>
2018-10-25 15:43:00 - type ConditionalProbabilityTable = VariableArray<Vector>
2018-10-25 15:43:00 - let AddChildFromOneParent (parent:Parent) (cpt:ConditionalProbabilityTable) =
2018-10-25 15:43:00 -     let r = parent.Range
2018-10-25 15:43:00 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-25 15:43:00 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:ParentCase) ->  
2018-10-25 15:43:00 -                        Variable.Discrete(cpt.[pi])))
2018-10-25 15:43:00 -     child
2018-10-25 15:43:01 - type ConditionalProbabilityTable2D = VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-25 15:43:01 - let AddChildFromTwoParents (parent1:Parent) (parent2:Parent) (cpt:ConditionalProbabilityTable2D) = 
2018-10-25 15:43:01 -     let r = parent1.Range
2018-10-25 15:43:01 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-25 15:43:01 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:ParentCase) ->  
2018-10-25 15:43:01 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:ParentCase) ->  
2018-10-25 15:43:01 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-25 15:43:01 -     child       
2018-10-25 15:43:01 - type RandomVariables =
2018-10-25 15:43:01 -     {cloudy:VariableArray<int>;
2018-10-25 15:43:01 -     sprinkler:VariableArray<int>;
2018-10-25 15:43:01 -     rain:VariableArray<int>;
2018-10-25 15:43:01 -     wetGrass:VariableArray<int> }
2018-10-25 15:43:01 - type ObservedValues =
2018-10-25 15:43:01 -     {cloudy:array<int>;
2018-10-25 15:43:01 -     sprinkler:array<int>;
2018-10-25 15:43:01 -     rain:array<int>;
2018-10-25 15:43:01 -     wetGrass:array<int> }
2018-10-25 15:43:01 - type DistributionParameters =
2018-10-25 15:43:01 -     {cloudy:Variable<Vector> ;
2018-10-25 15:43:01 -     sprinkler:VariableArray<Vector> ;
2018-10-25 15:43:01 -     rain:VariableArray<Vector> ;
2018-10-25 15:43:01 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-25 15:43:01 - type DistributionParameterValues =  
2018-10-25 15:43:01 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-25 15:43:01 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-25 15:43:01 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-25 15:43:01 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-25 15:43:01 -     }
2018-10-25 15:43:02 - type PriorDistributions =
2018-10-25 15:43:02 -     {cloudy:Variable<Dirichlet> ;
2018-10-25 15:43:02 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-25 15:43:02 -     rain:VariableArray<Dirichlet> ;
2018-10-25 15:43:02 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-25 15:43:02 - type PosteriorDistributions =
2018-10-25 15:43:02 -     {cloudy:Dirichlet ;
2018-10-25 15:43:02 -         sprinkler:Dirichlet[] ;
2018-10-25 15:43:02 -         rain:Dirichlet[] ;
2018-10-25 15:43:02 -         wetGrass:Dirichlet[][] }
2018-10-25 15:43:02 - type Ranges = {c:Range;s:Range;r:Range;w:Range}
2018-10-25 15:43:02 - let engine =  InferenceEngine ()
2018-10-25 15:43:02 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 15:43:02 - let n:Range = Range(NumberOfExamples).Named("N")
2018-10-25 15:43:02 - The value or constructor 'NumberOfExamples' is not defined. Maybe you want one of the following:
2018-10-25 15:43:02 -    numberOfExamples
2018-10-25 15:43:02 - A unique overload for method 'Range' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Range(N: int) : Range, Range(size: IModelExpression<int>) : Range
2018-10-25 15:43:02 - let C = Range(2).Named("C") // Cloudy
2018-10-25 15:43:02 - let S = Range(2).Named("S") // Sprinkler
2018-10-25 15:43:02 - let R = Range(2).Named("R") // Rain
2018-10-25 15:43:02 - let W = Range(2).Named("W") // Wet
2018-10-25 15:43:03 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-25 15:43:03 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-25 15:43:03 - probCloudy.SetValueRange(C)
2018-10-25 15:43:03 - let cptSprinklerPrior = Variable.Array<Dirichlet>(C).Named("cptSprinklerPrior")
2018-10-25 15:43:03 - let cptSprinkler = Variable.Array<Vector>(C).Named("cptSprinkler")
2018-10-25 15:43:03 - cptSprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[C]))
2018-10-25 15:43:03 - cptSprinkler.SetValueRange(S)
2018-10-25 15:43:03 - let cptRainPrior = Variable.Array<Dirichlet>(C).Named("cptRainPrior")
2018-10-25 15:43:03 - let cptRain = Variable.Array<Vector>(C).Named("cptRain")
2018-10-25 15:43:03 - cptRain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(cptRainPrior.[C]))
2018-10-25 15:43:03 - cptRain.SetValueRange(R)
2018-10-25 15:43:04 - let cptWetGrassPrior= 
2018-10-25 15:43:04 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 15:43:04 -         Variable.Array<Dirichlet>(R), S).Named("cptWetGrassPrior")
2018-10-25 15:43:04 - let cptWetGrass = 
2018-10-25 15:43:04 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-25 15:43:04 -         Variable.Array<Vector>(R), S).Named("cptWetGrass")
2018-10-25 15:43:04 - cptWetGrass.[S].[R].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[S].[R]))
2018-10-25 15:43:04 - cptWetGrass.SetValueRange(W)
2018-10-25 15:43:04 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-25 15:43:04 - let priors:PriorDistributions = {
2018-10-25 15:43:04 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-25 15:43:04 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-25 15:43:04 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-25 15:43:04 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 15:43:04 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-25 15:43:04 - let parameters:DistributionParameters = {
2018-10-25 15:43:04 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-25 15:43:04 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-10-25 15:43:04 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-10-25 15:43:04 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-25 15:43:04 -                 Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-10-25 15:43:04 - parameters.cloudy.SetValueRange(ranges.c)
2018-10-25 15:43:04 - parameters.sprinkler.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c]))
2018-10-25 15:43:04 - parameters.sprinkler.SetValueRange(ranges.s)
2018-10-25 15:43:04 - parameters.rain.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c]))
2018-10-25 15:43:04 - parameters.rain.SetValueRange(ranges.r)
2018-10-25 15:43:04 - parameters.wetGrass.[ranges.s].[ranges.r].SetTo(Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[ranges.s].[ranges.r]))
2018-10-25 15:43:04 - parameters.wetGrass.SetValueRange(ranges.w)
2018-10-25 15:43:05 - let buildPriors (rg:Ranges) =
2018-10-25 15:43:05 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-25 15:43:05 -     sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-25 15:43:05 -     rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-25 15:43:05 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 15:43:05 -                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-25 15:43:05 - Possible incorrect indentation: this token is offside of context started at position (5:70). Try indenting this token further or using standard formatting conventions.
2018-10-25 15:43:05 - Possible incorrect indentation: this token is offside of context started at position (5:70). Try indenting this token further or using standard formatting conventions.
2018-10-25 15:43:05 - The type 'Variable<Dirichlet>' is not compatible with the type 'Dirichlet'
2018-10-25 15:43:05 - This expression was expected to have type
2018-10-25 15:43:05 -     'Dirichlet []'    
2018-10-25 15:43:05 - but here has type
2018-10-25 15:43:05 -     'VariableArray<Dirichlet>'    
2018-10-25 15:43:05 - This expression was expected to have type
2018-10-25 15:43:05 -     'Dirichlet []'    
2018-10-25 15:43:05 - but here has type
2018-10-25 15:43:05 -     'VariableArray<Dirichlet>'    
2018-10-25 15:43:05 - This expression was expected to have type
2018-10-25 15:43:05 -     'Dirichlet [] []'    
2018-10-25 15:43:05 - but here has type
2018-10-25 15:43:05 -     'VariableArray<VariableArray<Dirichlet>,Dirichlet [] []>'    
2018-10-25 15:43:05 - let priors = buildPriors ranges
2018-10-25 15:43:05 - The value or constructor 'buildPriors' is not defined.
2018-10-25 15:43:05 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-25 15:43:05 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-25 15:43:05 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-25 15:43:05 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-25 15:43:05 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-25 15:43:05 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-25 15:43:05 -     probCloudy.SetValueRange(rg.c)
2018-10-25 15:43:05 -     cptSprinkler.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c]))
2018-10-25 15:43:05 -     cptSprinkler.SetValueRange(rg.s)
2018-10-25 15:43:05 -     cptRain.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c]))
2018-10-25 15:43:05 -     cptRain.SetValueRange(rg.r)
2018-10-25 15:43:05 -     cptWetGrass.[rg.s].[rg.r].SetTo(Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r]))
2018-10-25 15:43:05 -     cptWetGrass.SetValueRange(rg.w)
2018-10-25 15:43:05 -     {cloudy = probCloudy; sprinkler =cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-25 15:43:05 - let parameters = buildDistributionParameters ranges priors
2018-10-25 15:43:06 - let cloudy = Variable.Array<int>(n).Named("cloudy")
2018-10-25 15:43:06 - cloudy.[n].SetTo(Variable.Discrete(probCloudy).ForEach(n))
2018-10-25 15:43:06 - The value or constructor 'n' is not defined. Maybe you want one of the following:
2018-10-25 15:43:06 -    C
2018-10-25 15:43:06 -    R
2018-10-25 15:43:06 -    S
2018-10-25 15:43:06 -    W
2018-10-25 15:43:06 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2018-10-25 15:43:06 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-25 15:43:06 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("sprinkler")
2018-10-25 15:43:06 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("rain")
2018-10-25 15:43:06 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("wetGrass")
2018-10-25 15:43:06 - The value or constructor 'cloudy' is not defined.
2018-10-25 15:43:06 - The value or constructor 'cloudy' is not defined.
2018-10-25 15:43:06 - let rvs:RandomVariables =
2018-10-25 15:43:06 -     let c:VariableArray<int> = Variable.Array<int>(n).Named("cloudy")
2018-10-25 15:43:06 -     let s:VariableArray<int> = (AddChildFromOneParent c cptSprinkler).Named("sprinkler")
2018-10-25 15:43:06 -     let r:VariableArray<int> = (AddChildFromOneParent c cptRain).Named("rain")
2018-10-25 15:43:06 -     let w:VariableArray<int> = (AddChildFromTwoParents s r cptWetGrass).Named("wetGrass")
2018-10-25 15:43:06 -     {cloudy = c; sprinkler =s; rain = r; wetGrass = w}
2018-10-25 15:43:06 - The value or constructor 'n' is not defined. Maybe you want one of the following:
2018-10-25 15:43:06 -    C
2018-10-25 15:43:06 -    R
2018-10-25 15:43:06 -    S
2018-10-25 15:43:06 -    W
2018-10-25 15:43:06 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2018-10-25 15:43:07 - let buildRandomVariables (n:Range) (paramz:DistributionParameters) :RandomVariables =
2018-10-25 15:43:07 -     let cloudy: VariableArray<int> = Variable.Array<int>(n).Named("cloudy")
2018-10-25 15:43:07 -     cloudy.[n].SetTo(Variable.Discrete(paramz.cloudy).ForEach(n))
2018-10-25 15:43:07 -     let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy paramz.sprinkler).Named("sprinkler")
2018-10-25 15:43:07 -     let rain:VariableArray<int> = (AddChildFromOneParent cloudy paramz.rain).Named("rain")
2018-10-25 15:43:07 -     let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain paramz.wetGrass).Named("wetGrass")
2018-10-25 15:43:07 -     {cloudy = cloudy; sprinkler =sprinkler; rain = rain; wetGrass = wetGrass}
2018-10-25 15:43:07 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 15:43:07 - let n:Range = Range(NumberOfExamples).Named("N")
2018-10-25 15:43:07 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-25 15:43:07 - let priors = buildPriors ranges
2018-10-25 15:43:07 - let parameters = buildDistributionParameters ranges priors
2018-10-25 15:43:07 - let rvs = buildRandomVariables n parameters
2018-10-25 15:43:07 - The value or constructor 'NumberOfExamples' is not defined. Maybe you want one of the following:
2018-10-25 15:43:07 -    numberOfExamples
2018-10-25 15:43:07 - A unique overload for method 'Range' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Range(N: int) : Range, Range(size: IModelExpression<int>) : Range
2018-10-25 15:43:07 - The value or constructor 'buildPriors' is not defined.
2018-10-25 15:43:07 - type Parent = VariableArray<int>
2018-10-25 15:43:07 - type Child = VariableArray<int>
2018-10-25 15:43:07 - type ParentCase = Variable<int>
2018-10-25 15:43:07 - type ConditionalProbabilityTable = VariableArray<Vector>
2018-10-25 15:43:07 - let AddChildFromOneParent (parent:Parent) (cpt:ConditionalProbabilityTable) =
2018-10-25 15:43:07 -     let r = parent.Range
2018-10-25 15:43:07 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-25 15:43:07 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:ParentCase) ->  
2018-10-25 15:43:07 -                        Variable.Discrete(cpt.[pi])))
2018-10-25 15:43:07 -     child
2018-10-25 15:43:07 - type ConditionalProbabilityTable2D = VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-25 15:43:07 - let AddChildFromTwoParents (parent1:Parent) (parent2:Parent) (cpt:ConditionalProbabilityTable2D) = 
2018-10-25 15:43:07 -     let r = parent1.Range
2018-10-25 15:43:07 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-25 15:43:07 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:ParentCase) ->  
2018-10-25 15:43:07 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:ParentCase) ->  
2018-10-25 15:43:07 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-25 15:43:07 -     child       
2018-10-25 15:43:08 - let engine =  InferenceEngine ()
2018-10-25 15:43:08 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 15:43:08 - let n:Range = Range(NumberOfExamples).Named("N")
2018-10-25 15:43:08 - The value or constructor 'NumberOfExamples' is not defined. Maybe you want one of the following:
2018-10-25 15:43:08 -    numberOfExamples
2018-10-25 15:43:08 - A unique overload for method 'Range' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Range(N: int) : Range, Range(size: IModelExpression<int>) : Range
2018-10-25 15:43:08 - let C = Range(2).Named("C") // Cloudy
2018-10-25 15:43:08 - let S = Range(2).Named("S") // Sprinkler
2018-10-25 15:43:08 - let R = Range(2).Named("R") // Rain
2018-10-25 15:43:08 - let W = Range(2).Named("W") // Wet
2018-10-25 15:43:08 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-25 15:43:08 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-25 15:43:08 - probCloudy.SetValueRange(C)
2018-10-25 15:43:08 - let cptSprinklerPrior = Variable.Array<Dirichlet>(C).Named("cptSprinklerPrior")
2018-10-25 15:43:08 - let cptSprinkler = Variable.Array<Vector>(C).Named("cptSprinkler")
2018-10-25 15:43:08 - cptSprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[C]))
2018-10-25 15:43:08 - cptSprinkler.SetValueRange(S)
2018-10-25 15:43:09 - let cptRainPrior = Variable.Array<Dirichlet>(C).Named("cptRainPrior")
2018-10-25 15:43:09 - let cptRain = Variable.Array<Vector>(C).Named("cptRain")
2018-10-25 15:43:09 - cptRain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(cptRainPrior.[C]))
2018-10-25 15:43:09 - cptRain.SetValueRange(R)
2018-10-25 15:43:09 - let cptWetGrassPrior= 
2018-10-25 15:43:09 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 15:43:09 -         Variable.Array<Dirichlet>(R), S).Named("cptWetGrassPrior")
2018-10-25 15:43:09 - let cptWetGrass = 
2018-10-25 15:43:09 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-25 15:43:09 -         Variable.Array<Vector>(R), S).Named("cptWetGrass")
2018-10-25 15:43:09 - cptWetGrass.[S].[R].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[S].[R]))
2018-10-25 15:43:09 - cptWetGrass.SetValueRange(W)
2018-10-25 15:43:09 - let cloudy = Variable.Array<int>(n).Named("cloudy")
2018-10-25 15:43:09 - cloudy.[n].SetTo(Variable.Discrete(probCloudy).ForEach(n))
2018-10-25 15:43:09 - The value or constructor 'n' is not defined. Maybe you want one of the following:
2018-10-25 15:43:09 -    C
2018-10-25 15:43:09 -    R
2018-10-25 15:43:09 -    S
2018-10-25 15:43:09 -    W
2018-10-25 15:43:09 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2018-10-25 15:43:09 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-25 15:43:09 - #load "Paket.fsx"
2018-10-25 15:43:10 - Paket.Package
2018-10-25 15:43:10 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-25 15:43:10 -       "Microsoft.ML.Probabilistic"
2018-10-25 15:43:10 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-25 15:43:10 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-25 15:43:10 -       "NETStandard.Library"
2018-10-25 15:43:10 -   ]
2018-10-25 15:43:25 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-25 15:43:26 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-25 15:43:34 - //#load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-25 15:43:34 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-25 15:43:34 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-25 15:43:34 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-25 15:43:35 - #r "Microsoft.ML.Probabilistic"
2018-10-25 15:43:35 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-25 15:43:35 - #r "netstandard"
2018-10-25 15:43:35 - open System
2018-10-25 15:43:35 - open Microsoft.ML.Probabilistic  
2018-10-25 15:43:35 - open Microsoft.ML.Probabilistic.Models  
2018-10-25 15:43:35 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-25 15:43:35 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-25 15:43:35 - open Microsoft.ML.Probabilistic.Math
2018-10-25 15:43:35 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-25 15:43:36 - open Microsoft.ML.Probabilistic.FSharp
2018-10-25 15:43:36 - type Parent = VariableArray<int>
2018-10-25 15:43:36 - type Child = VariableArray<int>
2018-10-25 15:43:36 - type ParentCase = Variable<int>
2018-10-25 15:43:36 - type ConditionalProbabilityTable = VariableArray<Vector>
2018-10-25 15:43:36 - let AddChildFromOneParent (parent:Parent) (cpt:ConditionalProbabilityTable) =
2018-10-25 15:43:36 -     let r = parent.Range
2018-10-25 15:43:36 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-25 15:43:36 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:ParentCase) ->  
2018-10-25 15:43:36 -                        Variable.Discrete(cpt.[pi])))
2018-10-25 15:43:36 -     child
2018-10-25 15:43:37 - type ConditionalProbabilityTable2D = VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-25 15:43:37 - let AddChildFromTwoParents (parent1:Parent) (parent2:Parent) (cpt:ConditionalProbabilityTable2D) = 
2018-10-25 15:43:37 -     let r = parent1.Range
2018-10-25 15:43:37 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-25 15:43:37 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:ParentCase) ->  
2018-10-25 15:43:37 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:ParentCase) ->  
2018-10-25 15:43:37 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-25 15:43:37 -     child       
2018-10-25 15:43:37 - type RandomVariables =
2018-10-25 15:43:37 -     {cloudy:VariableArray<int>;
2018-10-25 15:43:37 -     sprinkler:VariableArray<int>;
2018-10-25 15:43:37 -     rain:VariableArray<int>;
2018-10-25 15:43:37 -     wetGrass:VariableArray<int> }
2018-10-25 15:43:37 - type ObservedValues =
2018-10-25 15:43:37 -     {cloudy:array<int>;
2018-10-25 15:43:37 -     sprinkler:array<int>;
2018-10-25 15:43:37 -     rain:array<int>;
2018-10-25 15:43:37 -     wetGrass:array<int> }
2018-10-25 15:43:37 - type DistributionParameters =
2018-10-25 15:43:37 -     {cloudy:Variable<Vector> ;
2018-10-25 15:43:37 -     sprinkler:VariableArray<Vector> ;
2018-10-25 15:43:37 -     rain:VariableArray<Vector> ;
2018-10-25 15:43:37 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-25 15:43:37 - type DistributionParameterValues =  
2018-10-25 15:43:37 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-25 15:43:37 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-25 15:43:37 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-25 15:43:37 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-25 15:43:37 -     }
2018-10-25 15:43:38 - type PriorDistributions =
2018-10-25 15:43:38 -     {cloudy:Variable<Dirichlet> ;
2018-10-25 15:43:38 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-25 15:43:38 -     rain:VariableArray<Dirichlet> ;
2018-10-25 15:43:38 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-25 15:43:38 - type PosteriorDistributions =
2018-10-25 15:43:38 -     {cloudy:Dirichlet ;
2018-10-25 15:43:38 -     sprinkler:Dirichlet[] ;
2018-10-25 15:43:38 -     rain:Dirichlet[] ;
2018-10-25 15:43:38 -     wetGrass:Dirichlet[][] }
2018-10-25 15:43:38 - type Ranges = {c:Range;s:Range;r:Range;w:Range}
2018-10-25 15:43:38 - let engine =  InferenceEngine ()
2018-10-25 15:43:38 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 15:43:38 - let n:Range = Range(NumberOfExamples).Named("N")
2018-10-25 15:43:38 - The value or constructor 'NumberOfExamples' is not defined. Maybe you want one of the following:
2018-10-25 15:43:38 -    numberOfExamples
2018-10-25 15:43:38 - A unique overload for method 'Range' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Range(N: int) : Range, Range(size: IModelExpression<int>) : Range
2018-10-25 15:43:38 - let C = Range(2).Named("C") // Cloudy
2018-10-25 15:43:38 - let S = Range(2).Named("S") // Sprinkler
2018-10-25 15:43:38 - let R = Range(2).Named("R") // Rain
2018-10-25 15:43:38 - let W = Range(2).Named("W") // Wet
2018-10-25 15:43:39 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-25 15:43:39 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-25 15:43:39 - probCloudy.SetValueRange(C)
2018-10-25 15:43:39 - let cptSprinklerPrior = Variable.Array<Dirichlet>(C).Named("cptSprinklerPrior")
2018-10-25 15:43:39 - let cptSprinkler = Variable.Array<Vector>(C).Named("cptSprinkler")
2018-10-25 15:43:39 - cptSprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[C]))
2018-10-25 15:43:39 - cptSprinkler.SetValueRange(S)
2018-10-25 15:43:39 - let cptRainPrior = Variable.Array<Dirichlet>(C).Named("cptRainPrior")
2018-10-25 15:43:39 - let cptRain = Variable.Array<Vector>(C).Named("cptRain")
2018-10-25 15:43:39 - cptRain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(cptRainPrior.[C]))
2018-10-25 15:43:39 - cptRain.SetValueRange(R)
2018-10-25 15:43:39 - let cptWetGrassPrior= 
2018-10-25 15:43:39 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 15:43:39 -         Variable.Array<Dirichlet>(R), S).Named("cptWetGrassPrior")
2018-10-25 15:43:39 - let cptWetGrass = 
2018-10-25 15:43:39 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-25 15:43:39 -         Variable.Array<Vector>(R), S).Named("cptWetGrass")
2018-10-25 15:43:40 - cptWetGrass.[S].[R].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[S].[R]))
2018-10-25 15:43:40 - cptWetGrass.SetValueRange(W)
2018-10-25 15:43:40 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-25 15:43:40 - let priors:PriorDistributions = {
2018-10-25 15:43:40 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-25 15:43:40 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-25 15:43:40 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-25 15:43:40 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 15:43:40 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-25 15:43:40 - let parameters:DistributionParameters = {
2018-10-25 15:43:40 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-25 15:43:40 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-10-25 15:43:40 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-10-25 15:43:40 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-25 15:43:40 -                 Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-10-25 15:43:40 - parameters.cloudy.SetValueRange(ranges.c)
2018-10-25 15:43:40 - parameters.sprinkler.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c]))
2018-10-25 15:43:40 - parameters.sprinkler.SetValueRange(ranges.s)
2018-10-25 15:43:40 - parameters.rain.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c]))
2018-10-25 15:43:40 - parameters.rain.SetValueRange(ranges.r)
2018-10-25 15:43:40 - parameters.wetGrass.[ranges.s].[ranges.r].SetTo(Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[ranges.s].[ranges.r]))
2018-10-25 15:43:40 - parameters.wetGrass.SetValueRange(ranges.w)
2018-10-25 15:43:40 - let buildPriors (rg:Ranges) =
2018-10-25 15:43:40 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-25 15:43:40 -     sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-25 15:43:40 -     rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-25 15:43:40 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 15:43:40 -                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-25 15:43:40 - Possible incorrect indentation: this token is offside of context started at position (5:70). Try indenting this token further or using standard formatting conventions.
2018-10-25 15:43:40 - Possible incorrect indentation: this token is offside of context started at position (5:70). Try indenting this token further or using standard formatting conventions.
2018-10-25 15:43:40 - The type 'Variable<Dirichlet>' is not compatible with the type 'Dirichlet'
2018-10-25 15:43:40 - This expression was expected to have type
2018-10-25 15:43:40 -     'Dirichlet []'    
2018-10-25 15:43:40 - but here has type
2018-10-25 15:43:40 -     'VariableArray<Dirichlet>'    
2018-10-25 15:43:40 - This expression was expected to have type
2018-10-25 15:43:40 -     'Dirichlet []'    
2018-10-25 15:43:40 - but here has type
2018-10-25 15:43:40 -     'VariableArray<Dirichlet>'    
2018-10-25 15:43:40 - This expression was expected to have type
2018-10-25 15:43:40 -     'Dirichlet [] []'    
2018-10-25 15:43:40 - but here has type
2018-10-25 15:43:40 -     'VariableArray<VariableArray<Dirichlet>,Dirichlet [] []>'    
2018-10-25 15:43:41 - let priors = buildPriors ranges
2018-10-25 15:43:41 - The value or constructor 'buildPriors' is not defined.
2018-10-25 15:43:41 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-25 15:43:41 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-25 15:43:41 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-25 15:43:41 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-25 15:43:41 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-25 15:43:41 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-25 15:43:41 -     probCloudy.SetValueRange(rg.c)
2018-10-25 15:43:41 -     cptSprinkler.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c]))
2018-10-25 15:43:41 -     cptSprinkler.SetValueRange(rg.s)
2018-10-25 15:43:41 -     cptRain.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c]))
2018-10-25 15:43:41 -     cptRain.SetValueRange(rg.r)
2018-10-25 15:43:41 -     cptWetGrass.[rg.s].[rg.r].SetTo(Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r]))
2018-10-25 15:43:41 -     cptWetGrass.SetValueRange(rg.w)
2018-10-25 15:43:41 -     {cloudy = probCloudy; sprinkler =cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-25 15:43:41 - let parameters = buildDistributionParameters ranges priors
2018-10-25 15:43:41 - let cloudy = Variable.Array<int>(n).Named("cloudy")
2018-10-25 15:43:41 - cloudy.[n].SetTo(Variable.Discrete(probCloudy).ForEach(n))
2018-10-25 15:43:41 - The value or constructor 'n' is not defined. Maybe you want one of the following:
2018-10-25 15:43:41 -    C
2018-10-25 15:43:41 -    R
2018-10-25 15:43:41 -    S
2018-10-25 15:43:41 -    W
2018-10-25 15:43:41 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2018-10-25 15:43:41 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-25 15:43:41 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("sprinkler")
2018-10-25 15:43:41 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("rain")
2018-10-25 15:43:41 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("wetGrass")
2018-10-25 15:43:42 - The value or constructor 'cloudy' is not defined.
2018-10-25 15:43:42 - The value or constructor 'cloudy' is not defined.
2018-10-25 15:43:42 - let rvs:RandomVariables =
2018-10-25 15:43:42 -     let c:VariableArray<int> = Variable.Array<int>(n).Named("cloudy")
2018-10-25 15:43:42 -     let s:VariableArray<int> = (AddChildFromOneParent c cptSprinkler).Named("sprinkler")
2018-10-25 15:43:42 -     let r:VariableArray<int> = (AddChildFromOneParent c cptRain).Named("rain")
2018-10-25 15:43:42 -     let w:VariableArray<int> = (AddChildFromTwoParents s r cptWetGrass).Named("wetGrass")
2018-10-25 15:43:42 -     {cloudy = c; sprinkler =s; rain = r; wetGrass = w}
2018-10-25 15:43:42 - The value or constructor 'n' is not defined. Maybe you want one of the following:
2018-10-25 15:43:42 -    C
2018-10-25 15:43:42 -    R
2018-10-25 15:43:42 -    S
2018-10-25 15:43:42 -    W
2018-10-25 15:43:42 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2018-10-25 15:43:42 - let buildRandomVariables (n:Range) (paramz:DistributionParameters) :RandomVariables =
2018-10-25 15:43:42 -     let cloudy: VariableArray<int> = Variable.Array<int>(n).Named("cloudy")
2018-10-25 15:43:42 -     cloudy.[n].SetTo(Variable.Discrete(paramz.cloudy).ForEach(n))
2018-10-25 15:43:42 -     let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy paramz.sprinkler).Named("sprinkler")
2018-10-25 15:43:42 -     let rain:VariableArray<int> = (AddChildFromOneParent cloudy paramz.rain).Named("rain")
2018-10-25 15:43:42 -     let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain paramz.wetGrass).Named("wetGrass")
2018-10-25 15:43:42 -     {cloudy = cloudy; sprinkler =sprinkler; rain = rain; wetGrass = wetGrass}
2018-10-25 15:43:42 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 15:43:42 - let n:Range = Range(NumberOfExamples).Named("N")
2018-10-25 15:43:42 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-25 15:43:42 - let priors = buildPriors ranges
2018-10-25 15:43:42 - let parameters = buildDistributionParameters ranges priors
2018-10-25 15:43:42 - let rvs = buildRandomVariables n parameters
2018-10-25 15:43:42 - The value or constructor 'NumberOfExamples' is not defined. Maybe you want one of the following:
2018-10-25 15:43:42 -    numberOfExamples
2018-10-25 15:43:42 - A unique overload for method 'Range' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Range(N: int) : Range, Range(size: IModelExpression<int>) : Range
2018-10-25 15:43:42 - The value or constructor 'buildPriors' is not defined.
2018-10-25 15:43:42 - // type CSRWPosterior = {probCloudyPosterior:Dirichlet;  cptSprinklerPosterior:Dirichlet[];  cptRainPosterior:Dirichlet[];  cptWetGrassPosterior:Dirichlet[][];}
2018-10-25 15:43:43 - (*
2018-10-25 15:43:43 - (cloudyObs:int[])
2018-10-25 15:43:43 - (sprinklerObs:int[] )
2018-10-25 15:43:43 - (rainObs:int[] )
2018-10-25 15:43:43 - (wetgrassObs:int[] )
2018-10-25 15:43:43 - (probCloudyPriorObs:Dirichlet) 
2018-10-25 15:43:43 - (cptSprinklerPriorObs:Dirichlet[] )
2018-10-25 15:43:43 - (cptRainPriorObs:Dirichlet[] )
2018-10-25 15:43:43 - (cptWetGrassPriorObs:Dirichlet[][]) = *)
2018-10-25 15:43:43 - (*
2018-10-25 15:43:43 - //Learns the parameters of the cloud/sprinkler/rain example
2018-10-25 15:43:43 - public void LearnParameters(
2018-10-25 15:43:43 -             int[] cloudy,
2018-10-25 15:43:43 -             int[] sprinkler,
2018-10-25 15:43:43 -             int[] rain,
2018-10-25 15:43:43 -             int[] wetgrass,
2018-10-25 15:43:43 -             Dirichlet probCloudyPrior,
2018-10-25 15:43:43 -             Dirichlet[] cptSprinklerPrior,
2018-10-25 15:43:43 -             Dirichlet[] cptRainPrior,
2018-10-25 15:43:43 -             Dirichlet[][] cptWetGrassPrior)*)
2018-10-25 15:43:43 - let learnParameters (observedRandomVariables:ObservedValues)
2018-10-25 15:43:43 -                     (observedPriors:PriorDistributions) =
2018-10-25 15:43:43 -     NumberOfExamples.ObservedValue <- cloudy.Length
2018-10-25 15:43:43 -     
2018-10-25 15:43:43 -     cloudy.ObservedValue <- cloudyObs
2018-10-25 15:43:43 -     sprinkler.ObservedValue <- sprinklerObs
2018-10-25 15:43:43 -     rain.ObservedValue <- rainObs
2018-10-25 15:43:43 -     wetGrass.ObservedValue <- wetgrassObs
2018-10-25 15:43:43 -     
2018-10-25 15:43:43 -     probCloudyPrior.ObservedValue <- probCloudyPriorObs
2018-10-25 15:43:43 -     cptSprinklerPrior.ObservedValue <- cptSprinklerPriorObs
2018-10-25 15:43:43 -     cptRainPrior.ObservedValue <- cptRainPriorObs
2018-10-25 15:43:43 -     cptWetGrassPrior.ObservedValue <- cptWetGrassPriorObs
2018-10-25 15:43:43 -     // Inference 
2018-10-25 15:43:43 -     {probCloudyPosterior=engine.Infer<Dirichlet>(probCloudy);  
2018-10-25 15:43:43 -         cptSprinklerPosterior=engine.Infer<Dirichlet[]>(cptSprinkler);  
2018-10-25 15:43:43 -         cptRainPosterior=engine.Infer<Dirichlet[]>(cptRain);  
2018-10-25 15:43:43 -         cptWetGrassPosterior=engine.Infer<Dirichlet[][]>(cptWetGrass)}
2018-10-25 15:43:43 - The value, namespace, type or module 'NumberOfExamples' is not defined.
2018-10-25 15:43:43 - The value, namespace, type or module 'cloudy' is not defined.
2018-10-25 15:43:43 - The value, namespace, type or module 'sprinkler' is not defined. Maybe you want one of the following:
2018-10-25 15:43:43 -    sprintf
2018-10-25 15:43:43 -    cptSprinkler
2018-10-25 15:43:43 - The value, namespace, type or module 'rain' is not defined. Maybe you want one of the following:
2018-10-25 15:43:43 -    Rand
2018-10-25 15:43:43 -    Drawing
2018-10-25 15:43:43 -    Tracing
2018-10-25 15:43:43 -    Main
2018-10-25 15:43:43 - The value, namespace, type or module 'wetGrass' is not defined. Maybe you want one of the following:
2018-10-25 15:43:43 -    cptWetGrass
2018-10-25 15:43:43 - The value or constructor 'probCloudyPriorObs' is not defined. Maybe you want one of the following:
2018-10-25 15:43:43 -    probCloudyPrior
2018-10-25 15:43:43 -    probCloudy
2018-10-25 15:43:43 - The value or constructor 'cptSprinklerPriorObs' is not defined. Maybe you want one of the following:
2018-10-25 15:43:43 -    cptSprinklerPrior
2018-10-25 15:43:43 -    cptSprinkler
2018-10-25 15:43:43 - The value or constructor 'cptRainPriorObs' is not defined. Maybe you want one of the following:
2018-10-25 15:43:43 -    cptRainPrior
2018-10-25 15:43:43 -    cptRain
2018-10-25 15:43:43 - The value or constructor 'cptWetGrassPriorObs' is not defined. Maybe you want one of the following:
2018-10-25 15:43:43 -    cptWetGrassPrior
2018-10-25 15:43:43 -    cptWetGrass
2018-10-25 15:43:43 - The record label 'probCloudyPosterior' is not defined.
2018-10-25 15:43:43 - let ProbRain cloudy:Option<int> sprinkler:Option<int> = ()
2018-10-25 15:43:44 - Syntax error in labelled type argument
2018-10-25 15:43:44 -             int? cloudy,
2018-10-25 15:43:44 -             int? sprinkler,
2018-10-25 15:43:44 -             int? wet,
2018-10-25 15:43:44 -             Dirichlet probCloudyPrior,
2018-10-25 15:43:44 -             Dirichlet[] cptSprinklerPrior,
2018-10-25 15:43:44 -             Dirichlet[] cptRainPrior,
2018-10-25 15:43:44 -             Dirichlet[][] cptWetGrassPrior)
2018-10-25 15:43:44 -         {
2018-10-25 15:43:44 -             
2018-10-25 15:43:44 - Unexpected symbol ')' in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2018-10-25 15:43:44 - Possible incorrect indentation: this token is offside of context started at position (8:9). Try indenting this token further or using standard formatting conventions.
2018-10-25 15:43:44 - parse error
2018-10-25 15:43:44 - NumberOfExamples.ObservedValue = 1;
2018-10-25 15:43:44 - The value, namespace, type or module 'NumberOfExamples' is not defined.
2018-10-25 15:43:44 - if (cloudy.HasValue)
2018-10-25 15:43:44 -             {
2018-10-25 15:43:44 -                 Cloudy.ObservedValue = new int[] { cloudy.Value };
2018-10-25 15:43:44 -             }
2018-10-25 15:43:44 -             else
2018-10-25 15:43:44 -             {
2018-10-25 15:43:44 -                 Cloudy.ClearObservedValue();
2018-10-25 15:43:44 -             }
2018-10-25 15:43:44 -             if (sprinkler.HasValue)
2018-10-25 15:43:44 -             {
2018-10-25 15:43:44 -                 Sprinkler.ObservedValue = new int[] { sprinkler.Value };
2018-10-25 15:43:44 -             }
2018-10-25 15:43:44 -             else
2018-10-25 15:43:44 -             {
2018-10-25 15:43:44 -                 Sprinkler.ClearObservedValue();
2018-10-25 15:43:44 -             }
2018-10-25 15:43:44 -             if (wet.HasValue)
2018-10-25 15:43:44 -             {
2018-10-25 15:43:44 -                 WetGrass.ObservedValue = new int[] { wet.Value };
2018-10-25 15:43:44 -             }
2018-10-25 15:43:44 -             else
2018-10-25 15:43:44 -             {
2018-10-25 15:43:44 -                 WetGrass.ClearObservedValue();
2018-10-25 15:43:44 -             }
2018-10-25 15:43:44 -             Rain.ClearObservedValue();
2018-10-25 15:43:44 -             ProbCloudyPrior.ObservedValue = probCloudyPrior;
2018-10-25 15:43:44 -             CPTSprinklerPrior.ObservedValue = cptSprinklerPrior;
2018-10-25 15:43:44 -             CPTRainPrior.ObservedValue = cptRainPrior;
2018-10-25 15:43:44 -             CPTWetGrassPrior.ObservedValue = cptWetGrassPrior;
2018-10-25 15:43:44 -             // Inference
2018-10-25 15:43:44 -             var rainPosterior = Engine.Infer<Discrete[]>(Rain);
2018-10-25 15:43:44 -             // In this example, index 0 is true and index 1 is false
2018-10-25 15:43:44 -             return rainPosterior[0].GetProbs()[0];
2018-10-25 15:43:44 -         }
2018-10-25 15:43:45 - This construct is deprecated: The use of the type syntax 'int C' and 'C  <int>' is not permitted here. Consider adjusting this type to be written in the form 'C<int>'
2018-10-25 15:43:45 - Unexpected keyword 'else' in expression
2018-10-25 15:43:45 - Incomplete conditional. Expected 'if <expr> then <expr>' or 'if <expr> then <expr> else <expr>'.
2018-10-25 15:43:45 - Incomplete structured construct at or before this point in expression
2018-10-25 15:43:45 - Incomplete conditional. Expected 'if <expr> then <expr>' or 'if <expr> then <expr> else <expr>'.
2018-10-25 15:43:45 - This construct is deprecated: The use of the type syntax 'int C' and 'C  <int>' is not permitted here. Consider adjusting this type to be written in the form 'C<int>'
2018-10-25 15:43:45 - Incomplete structured construct at or before this point in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2018-10-25 15:43:45 - parse error
2018-10-25 15:43:45 - let sample numData:int probCloudy:Vector[] cptSprinkler 
2018-10-25 15:43:45 - Syntax error in labelled type argument
2018-10-25 15:43:45 - let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-25 15:43:45 - let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-25 15:43:45 - let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-25 15:43:45 - let cptWetGrass:Vector[][] = 
2018-10-25 15:43:45 -     [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-25 15:43:45 -             [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-25 15:43:45 -         [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-25 15:43:45 -             [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-25 15:43:45 -     |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-25 15:43:45 - let distributionParameterValues:DistributionParameterValues = {
2018-10-25 15:43:45 -     cloudy= probCloudy
2018-10-25 15:43:45 -     sprinkler= cptSprinkler
2018-10-25 15:43:45 -     rain = cptRain
2018-10-25 15:43:45 -     wetGrass =  cptWetGrass 
2018-10-25 15:43:45 - }
2018-10-25 15:43:45 - let setDistributionParameterValues ():DistributionParameterValues =
2018-10-25 15:43:45 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-25 15:43:45 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-25 15:43:45 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-25 15:43:45 -     let cptWetGrass:Vector[][] = 
2018-10-25 15:43:45 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-25 15:43:45 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-25 15:43:45 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-25 15:43:45 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-25 15:43:45 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-25 15:43:45 -     {cloudy= probCloudy;
2018-10-25 15:43:45 -         sprinkler= cptSprinkler;
2018-10-25 15:43:45 -         rain = cptRain;
2018-10-25 15:43:45 -         wetGrass =  cptWetGrass }
2018-10-25 15:43:46 - setDistributionParameterValues()
2018-10-25 15:43:46 - let probRainGivenWetGrass = model.ProbRain(null, null, 0, probCloudy, cptSprinkler, cptRain, cptWetGrass);
2018-10-25 15:43:46 - let probRainGivenWetGrassNotCloudy = model.ProbRain(1, null, 0, probCloudy, cptSprinkler, cptRain, cptWetGrass);
2018-10-25 15:43:46 - printf "P(rain | grass is wet)              = %A" probRainGivenWetGrass
2018-10-25 15:43:46 - printf "P(rain | grass is wet, not cloudy ) = %A" probRainGivenWetGrassNotCloudy
2018-10-25 15:43:46 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-25 15:43:46 -    Model
2018-10-25 15:43:46 -    Models
2018-10-25 15:43:46 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-25 15:43:46 -    Model
2018-10-25 15:43:46 -    Models
2018-10-25 15:43:46 - let sample = WetGlassSprinklerRainModel.Sample(1000, probCloudy, cptSprinkler, cptRain, cptWetGrass)
2018-10-25 15:43:46 - The value, namespace, type or module 'WetGlassSprinklerRainModel' is not defined.
2018-10-25 15:43:46 - model.LearnParameters(sample[0], sample[1], sample[2], sample[3])
2018-10-25 15:43:47 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-25 15:43:47 -    Model
2018-10-25 15:43:47 -    Models
2018-10-25 15:43:47 - printf "Prob. Cloudy:                              Ground truth: %A, Inferred: %A", 0.5, model.ProbCloudyPosterior.GetMean()[0]
2018-10-25 15:43:47 - printf "Prob. Sprinkler | Cloudy:                  Ground truth: %A, Inferred: %A", 0.1, model.CPTSprinklerPosterior[0].GetMean()[0]
2018-10-25 15:43:47 - printf "Prob. Sprinkler | Not Cloudy:              Ground truth: %A, Inferred: %A", 0.5, model.CPTSprinklerPosterior[1].GetMean()[0]
2018-10-25 15:43:47 - printf "Prob. Rain      | Cloudy:                  Ground truth: %A, Inferred: %A", 0.8, model.CPTRainPosterior[0].GetMean()[0]
2018-10-25 15:43:47 - printf "Prob. Rain      | Not Cloudy:              Ground truth: %A, Inferred: %A", 0.2, model.CPTRainPosterior[1].GetMean()[0]
2018-10-25 15:43:47 - printf "Prob. Wet Grass | Sprinkler, Rain:         Ground truth: %A, Inferred: %A", 0.99, model.CPTWetGrassPosterior[0][0].GetMean()[0]
2018-10-25 15:43:47 - printf "Prob. Wet Grass | Sprinkler, Not Rain      Ground truth: %A, Inferred: %A", 0.9, model.CPTWetGrassPosterior[0][1].GetMean()[0]
2018-10-25 15:43:47 - printf "Prob. Wet Grass | Not Sprinkler, Rain:     Ground truth: %A, Inferred: %A", 0.9, model.CPTWetGrassPosterior[1][0].GetMean()[0]
2018-10-25 15:43:47 - printf "Prob. Wet Grass | Not Sprinkler, Not Rain: Ground truth: %A, Inferred: %A", 0.0, model.CPTWetGrassPosterior[1][1].GetMean()[0]
2018-10-25 15:43:47 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-25 15:43:47 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-25 15:43:47 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-25 15:43:47 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-25 15:43:47 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-25 15:43:47 -    Model
2018-10-25 15:43:47 -    Models
2018-10-25 15:43:47 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-25 15:43:47 -    Model
2018-10-25 15:43:47 -    Models
2018-10-25 15:43:47 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-25 15:43:47 -    Model
2018-10-25 15:43:47 -    Models
2018-10-25 15:43:47 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-25 15:43:47 -    Model
2018-10-25 15:43:47 -    Models
2018-10-25 15:43:47 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-25 15:43:47 -    Model
2018-10-25 15:43:47 -    Models
2018-10-25 15:43:47 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-25 15:43:47 -    Model
2018-10-25 15:43:47 -    Models
2018-10-25 15:43:47 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-25 15:43:47 -    Model
2018-10-25 15:43:47 -    Models
2018-10-25 15:43:47 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-25 15:43:47 -    Model
2018-10-25 15:43:47 -    Models
2018-10-25 15:43:47 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-25 15:43:47 -    Model
2018-10-25 15:43:47 -    Models
2018-10-25 15:43:47 - // Use posteriors we have just learnt
2018-10-25 15:43:47 - let probRainGivenWetGrass1 = model.ProbRain(null, null, 0, model.ProbCloudyPosterior, model.CPTSprinklerPosterior, model.CPTRainPosterior, model.CPTWetGrassPosterior)
2018-10-25 15:43:47 - let probRainGivenWetGrassNotCloudy1 = model.ProbRain(1, null, 0, model.ProbCloudyPosterior, model.CPTSprinklerPosterior, model.CPTRainPosterior, model.CPTWetGrassPosterior)
2018-10-25 15:43:47 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-25 15:43:47 -    Model
2018-10-25 15:43:47 -    Models
2018-10-25 15:43:47 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-25 15:43:47 -    Model
2018-10-25 15:43:47 -    Models
2018-10-25 15:43:47 - probRainGivenWetGrass1
2018-10-25 15:43:47 - The value or constructor 'probRainGivenWetGrass1' is not defined.
2018-10-25 15:43:47 - probRainGivenWetGrassNotCloudy1
2018-10-25 15:43:48 - The value or constructor 'probRainGivenWetGrassNotCloudy1' is not defined.
2018-10-25 15:43:48 - //using the Foreach Block  
2018-10-25 15:43:48 - let pixel = Range(10)  
2018-10-25 15:43:48 - let bools = Variable.Array<bool>(pixel)
2018-10-25 15:43:48 - Variable.ForeachBlock pixel ( fun pixel -> bools.[pixel] <- Variable.Bernoulli(0.7) ||| Variable.Bernoulli(0.4))
2018-10-25 15:43:48 - //using the Switch Block - to model a 2 component (scalar) Gaussian mixture
2018-10-25 15:43:48 - let mixtureSize = 2  
2018-10-25 15:43:48 - let k2 = Range(mixtureSize)  
2018-10-25 15:43:48 - let c:Variable<int> = Variable.Discrete(k2, [|0.5;0.5|])  // c is a discrete random variable with values {0,1}
2018-10-25 15:43:48 - let means2:VariableArray<float> = Variable.Observed( [|1.0;2.0|], k2)  // Constant means for each Gaussian
2018-10-25 15:43:48 - let x:Variable<float> = Variable.New<double>()  // x is a univariate Gaussian
2018-10-25 15:43:48 - Variable.SwitchBlock c (fun _ -> 
2018-10-25 15:43:48 -     let _ = x.SetTo(Variable.GaussianFromMeanAndVariance(means2.[c], 1.0))  
2018-10-25 15:43:48 -     ()  
2018-10-25 15:43:48 - )
2018-10-25 15:43:49 - //using the SwitchExpr Block - to model 100 outcomes of a 2-component mixture Wishart distributed variable
2018-10-25 15:43:49 - let k =  Range(2).Named("k")
2018-10-25 15:43:49 - // Loop over mixture components - parameters are constant, so don't vary based on prior distribution, yet
2018-10-25 15:43:49 - let means:VariableArray<Vector> = 
2018-10-25 15:43:49 -     Variable.ArrayInit k (fun k ->  
2018-10-25 15:43:49 -         Variable.VectorGaussianFromMeanAndPrecision( Vector.Constant(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-10-25 15:43:49 - let precs:VariableArray<PositiveDefiniteMatrix> =  
2018-10-25 15:43:49 -     Variable.ArrayInit k (fun k -> 
2018-10-25 15:43:49 -         Variable.WishartFromShapeAndScale(1.0,  
2018-10-25 15:43:49 -             PositiveDefiniteMatrix.Identity(2)))  
2018-10-25 15:43:49 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-10-25 15:43:49 - let n = Range(100).Named("n")
2018-10-25 15:43:49 - let z:VariableArray<int> = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-25 15:43:50 - let data = Variable.ArrayInit n (fun (i:Range)->  
2018-10-25 15:43:50 -                Variable.SwitchExpr (z.[i]) (fun (zi:Variable<int>) ->  
2018-10-25 15:43:50 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-25 15:43:50 - // Data from a clinical trial  
2018-10-25 15:43:50 - let controlGroup = Variable.Observed<bool>([|false; false; true; false; false|])  
2018-10-25 15:43:50 - let treatedGroup = Variable.Observed<bool>([|true; false; true; true; true |])  
2018-10-25 15:43:50 - let i = controlGroup.Range  
2018-10-25 15:43:50 - let j = treatedGroup.Range  
2018-10-25 15:43:50 - // Prior on being an effective treatment  
2018-10-25 15:43:50 - let isEffective = Variable.Bernoulli(0.5).Named("isEffective");  
2018-10-25 15:43:50 - let probIfTreated = ref (Variable.New<float>())  
2018-10-25 15:43:50 - let probIfControl = ref (Variable.New<float>())
2018-10-25 15:43:50 - // If Block function  
2018-10-25 15:43:50 - let f1 (vb1: Variable<bool>) =  
2018-10-25 15:43:50 -     probIfControl := Variable.Beta(1.0, 1.0).Named("probIfControl")  
2018-10-25 15:43:50 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->
2018-10-25 15:43:50 -         Variable.Bernoulli(!probIfControl)) 
2018-10-25 15:43:50 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->
2018-10-25 15:43:50 -         Variable.Bernoulli(!probIfTreated))  
2018-10-25 15:43:50 -     ()  
2018-10-25 15:43:50 - // IfNot Block function  
2018-10-25 15:43:50 - let f2 (vb2: Variable<bool>) =  
2018-10-25 15:43:50 -     let probAll = Variable.Beta(1.0, 1.0).Named("probAll")  
2018-10-25 15:43:50 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->Variable.Bernoulli(probAll))  
2018-10-25 15:43:50 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->Variable.Bernoulli(probAll))  
2018-10-25 15:43:50 -     ()  
2018-10-25 15:43:50 - // Call IfBlock  
2018-10-25 15:43:50 - let _ = Variable.IfBlock isEffective f1 f2
2018-10-25 15:46:11 - let ProbRain cloudy:Option<int> sprinkler:Option<int> = 
2018-10-25 15:46:11 -     match validInt with 
2018-10-25 15:46:11 -     | Some cloudy -> printfn "the valid value is %A" cloudy
2018-10-25 15:46:11 -     | None -> printfn "the value is None" 
2018-10-25 15:46:11 -     ()
2018-10-25 15:46:12 - Syntax error in labelled type argument
2018-10-25 15:46:27 - let ProbRain (cloudy:Option<int>) (sprinkler:Option<int>) = 
2018-10-25 15:46:27 -     match validInt with 
2018-10-25 15:46:27 -     | Some cloudy -> printfn "the valid value is %A" cloudy
2018-10-25 15:46:27 -     | None -> printfn "the value is None" 
2018-10-25 15:46:27 -     ()
2018-10-25 15:46:27 - The value or constructor 'validInt' is not defined.
2018-10-25 15:47:17 - let ProbRain (cloudy:Option<int>) (sprinkler:Option<int>) = 
2018-10-25 15:47:17 -     match cloudy with 
2018-10-25 15:47:17 -     | Some cloudy -> printfn "the valid value is %A" cloudy
2018-10-25 15:47:17 -     | None -> printfn "the value is None" 
2018-10-25 15:47:17 -     ()
2018-10-25 15:47:25 - let probRain (cloudy:Option<int>) (sprinkler:Option<int>) = 
2018-10-25 15:47:25 -     match cloudy with 
2018-10-25 15:47:25 -     | Some cloudy -> printfn "the valid value is %A" cloudy
2018-10-25 15:47:25 -     | None -> printfn "the value is None" 
2018-10-25 15:47:25 -     ()
2018-10-25 15:52:34 - probRain Some 3 None
2018-10-25 15:52:34 - This value is not a function and cannot be applied.
2018-10-25 15:52:40 - let probRain (cloudy:Option<int>) (sprinkler:Option<int>) = 
2018-10-25 15:52:40 -     match cloudy with 
2018-10-25 15:52:40 -     | Some cloudy -> printfn "the valid value is %A" cloudy
2018-10-25 15:52:40 -     | None -> printfn "the value is None" 
2018-10-25 15:52:40 -     ()
2018-10-25 15:52:48 - probRain (Some 3) None
2018-10-25 16:40:57 - let buildPriors (rg:Ranges) =
2018-10-25 16:40:57 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-25 16:40:57 -     sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-25 16:40:57 -     rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-25 16:40:57 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 16:40:57 -                         Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-25 16:40:57 - Possible incorrect indentation: this token is offside of context started at position (5:70). Try indenting this token further or using standard formatting conventions.
2018-10-25 16:40:57 - Possible incorrect indentation: this token is offside of context started at position (5:70). Try indenting this token further or using standard formatting conventions.
2018-10-25 16:40:57 - The type 'Variable<Dirichlet>' is not compatible with the type 'Dirichlet'
2018-10-25 16:40:57 - This expression was expected to have type
2018-10-25 16:40:57 -     'Dirichlet []'    
2018-10-25 16:40:57 - but here has type
2018-10-25 16:40:57 -     'VariableArray<Dirichlet>'    
2018-10-25 16:40:57 - This expression was expected to have type
2018-10-25 16:40:57 -     'Dirichlet []'    
2018-10-25 16:40:57 - but here has type
2018-10-25 16:40:57 -     'VariableArray<Dirichlet>'    
2018-10-25 16:40:57 - This expression was expected to have type
2018-10-25 16:40:57 -     'Dirichlet [] []'    
2018-10-25 16:40:57 - but here has type
2018-10-25 16:40:57 -     'VariableArray<VariableArray<Dirichlet>,Dirichlet [] []>'    
2018-10-25 16:41:06 - let buildPriors (rg:Ranges) =
2018-10-25 16:41:06 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-25 16:41:06 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-25 16:41:06 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-25 16:41:06 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 16:41:06 -                             Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-25 16:41:06 - The type 'Variable<Dirichlet>' is not compatible with the type 'Dirichlet'
2018-10-25 16:41:06 - This expression was expected to have type
2018-10-25 16:41:06 -     'Dirichlet []'    
2018-10-25 16:41:06 - but here has type
2018-10-25 16:41:06 -     'VariableArray<Dirichlet>'    
2018-10-25 16:41:06 - This expression was expected to have type
2018-10-25 16:41:06 -     'Dirichlet []'    
2018-10-25 16:41:06 - but here has type
2018-10-25 16:41:06 -     'VariableArray<Dirichlet>'    
2018-10-25 16:41:06 - This expression was expected to have type
2018-10-25 16:41:06 -     'Dirichlet [] []'    
2018-10-25 16:41:06 - but here has type
2018-10-25 16:41:06 -     'VariableArray<VariableArray<Dirichlet>,Dirichlet [] []>'    
2018-10-25 16:41:25 - let buildPriors (rg:Ranges) =
2018-10-25 16:41:25 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-25 16:41:25 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-25 16:41:25 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-25 16:41:25 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 16:41:25 -             Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-25 16:41:25 - Possible incorrect indentation: this token is offside of context started at position (5:19). Try indenting this token further or using standard formatting conventions.
2018-10-25 16:41:25 - Possible incorrect indentation: this token is offside of context started at position (5:19). Try indenting this token further or using standard formatting conventions.
2018-10-25 16:41:25 - The type 'Variable<Dirichlet>' is not compatible with the type 'Dirichlet'
2018-10-25 16:41:25 - This expression was expected to have type
2018-10-25 16:41:25 -     'Dirichlet []'    
2018-10-25 16:41:25 - but here has type
2018-10-25 16:41:25 -     'VariableArray<Dirichlet>'    
2018-10-25 16:41:25 - This expression was expected to have type
2018-10-25 16:41:25 -     'Dirichlet []'    
2018-10-25 16:41:25 - but here has type
2018-10-25 16:41:25 -     'VariableArray<Dirichlet>'    
2018-10-25 16:41:25 - This expression was expected to have type
2018-10-25 16:41:25 -     'Dirichlet [] []'    
2018-10-25 16:41:25 - but here has type
2018-10-25 16:41:25 -     'VariableArray<VariableArray<Dirichlet>,Dirichlet [] []>'    
2018-10-25 16:41:31 - let buildPriors (rg:Ranges) =
2018-10-25 16:41:31 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-25 16:41:31 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-25 16:41:31 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-25 16:41:31 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 16:41:31 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-25 16:41:31 - The type 'Variable<Dirichlet>' is not compatible with the type 'Dirichlet'
2018-10-25 16:41:31 - This expression was expected to have type
2018-10-25 16:41:31 -     'Dirichlet []'    
2018-10-25 16:41:31 - but here has type
2018-10-25 16:41:31 -     'VariableArray<Dirichlet>'    
2018-10-25 16:41:31 - This expression was expected to have type
2018-10-25 16:41:31 -     'Dirichlet []'    
2018-10-25 16:41:31 - but here has type
2018-10-25 16:41:31 -     'VariableArray<Dirichlet>'    
2018-10-25 16:41:31 - This expression was expected to have type
2018-10-25 16:41:31 -     'Dirichlet [] []'    
2018-10-25 16:41:31 - but here has type
2018-10-25 16:41:31 -     'VariableArray<VariableArray<Dirichlet>,Dirichlet [] []>'    
2018-10-25 16:42:14 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-25 16:42:14 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-25 16:42:14 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-25 16:42:14 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-25 16:42:14 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 16:42:14 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-25 16:42:22 - let priors = buildPriors ranges
2018-10-25 16:42:43 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 16:42:43 - let n:Range = Range(numberOfExamples).Named("N")
2018-10-25 16:43:01 - let cloudy = Variable.Array<int>(n).Named("cloudy")
2018-10-25 16:43:01 - cloudy.[n].SetTo(Variable.Discrete(probCloudy).ForEach(n))
2018-10-25 16:43:03 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("sprinkler")
2018-10-25 16:43:03 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("rain")
2018-10-25 16:43:03 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("wetGrass")
2018-10-25 16:43:04 - The type 'Vector []' is not compatible with the type 'ConditionalProbabilityTable'
2018-10-25 16:43:04 - The type 'Vector []' is not compatible with the type 'ConditionalProbabilityTable'
2018-10-25 16:43:04 - The type 'Vector [] []' is not compatible with the type 'ConditionalProbabilityTable2D'
2018-10-25 16:48:27 - cptSprinkler.GetType()
2018-10-25 16:50:16 - cptSprinkler.GetType()
2018-10-25 16:50:22 - let cptSprinklerPrior = Variable.Array<Dirichlet>(C).Named("cptSprinklerPrior")
2018-10-25 16:50:22 - let cptSprinkler = Variable.Array<Vector>(C).Named("cptSprinkler")
2018-10-25 16:50:25 - cptSprinkler.GetType()
2018-10-25 16:50:36 - cptSprinkler.[C].SetTo(Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[C]))
2018-10-25 16:50:36 - cptSprinkler.SetValueRange(S)
2018-10-25 16:50:42 - let cptRainPrior = Variable.Array<Dirichlet>(C).Named("cptRainPrior")
2018-10-25 16:50:42 - let cptRain = Variable.Array<Vector>(C).Named("cptRain")
2018-10-25 16:50:43 - cptRain.[C].SetTo(Variable<Vector>.Random<Dirichlet>(cptRainPrior.[C]))
2018-10-25 16:50:43 - cptRain.SetValueRange(R)
2018-10-25 16:50:44 - let cptWetGrassPrior= 
2018-10-25 16:50:44 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 16:50:44 -         Variable.Array<Dirichlet>(R), S).Named("cptWetGrassPrior")
2018-10-25 16:50:44 - let cptWetGrass = 
2018-10-25 16:50:44 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-25 16:50:44 -         Variable.Array<Vector>(R), S).Named("cptWetGrass")
2018-10-25 16:50:46 - cptWetGrass.[S].[R].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[S].[R]))
2018-10-25 16:50:46 - cptWetGrass.SetValueRange(W)
2018-10-25 16:50:54 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-25 16:50:55 - let priors:PriorDistributions = {
2018-10-25 16:50:55 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-25 16:50:55 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-25 16:50:55 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-25 16:50:55 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 16:50:55 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-25 16:50:55 - let parameters:DistributionParameters = {
2018-10-25 16:50:55 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-25 16:50:55 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-10-25 16:50:55 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-10-25 16:50:55 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-25 16:50:55 -                 Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-10-25 16:50:56 - parameters.cloudy.SetValueRange(ranges.c)
2018-10-25 16:50:56 - parameters.sprinkler.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c]))
2018-10-25 16:50:56 - parameters.sprinkler.SetValueRange(ranges.s)
2018-10-25 16:50:56 - parameters.rain.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c]))
2018-10-25 16:50:56 - parameters.rain.SetValueRange(ranges.r)
2018-10-25 16:50:56 - parameters.wetGrass.[ranges.s].[ranges.r].SetTo(Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[ranges.s].[ranges.r]))
2018-10-25 16:50:56 - parameters.wetGrass.SetValueRange(ranges.w)
2018-10-25 16:51:10 - let cloudy = Variable.Array<int>(n).Named("cloudy")
2018-10-25 16:51:10 - cloudy.[n].SetTo(Variable.Discrete(probCloudy).ForEach(n))
2018-10-25 16:51:11 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("sprinkler")
2018-10-25 16:51:11 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("rain")
2018-10-25 16:51:11 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("wetGrass")
2018-10-25 16:51:11 - Expression evaluation failed: cloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-25 16:51:11 - ArgumentExceptioncloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-25 16:51:11 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange (System.Boolean throwIfMissing) [0x00022] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 16:51:11 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange () [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 16:51:11 -   at Microsoft.ML.Probabilistic.Models.Variable.Switch (Microsoft.ML.Probabilistic.Models.Variable`1[T] i) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 16:51:11 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x00000] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 16:51:11 -   at FSI_0084+AddChildFromOneParent@3-4.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x00020] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 16:51:11 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 16:51:11 -   at FSI_0084.AddChildFromOneParent (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] cpt) [0x00016] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 16:51:11 -   at <StartupCode$FSI_0195>.$FSI_0195.main@ () [0x0000a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 16:51:11 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 16:51:11 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 16:51:28 - let cloudy = Variable.Array<int>(n).Named("cloudy")
2018-10-25 16:51:28 - cloudy.[n].SetTo(Variable.Discrete(probCloudy).ForEach(n))
2018-10-25 16:51:29 - Expression evaluation failed: Range 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 16:51:29 - InvalidOperationExceptionRange 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 16:51:29 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0008f] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 16:51:29 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 16:51:29 -   at Microsoft.ML.Probabilistic.Models.VariableArray`1[T]..ctor (Microsoft.ML.Probabilistic.Models.Range range) [0x00006] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 16:51:29 -   at Microsoft.ML.Probabilistic.Models.Variable.Array[T] (Microsoft.ML.Probabilistic.Models.Range r) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 16:51:29 -   at <StartupCode$FSI_0196>.$FSI_0196.main@ () [0x00005] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 16:51:29 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 16:51:29 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 16:51:45 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 16:51:45 - let n:Range = Range(numberOfExamples).Named("N")
2018-10-25 16:51:52 - let cloudy = Variable.Array<int>(n).Named("cloudy")
2018-10-25 16:51:52 - cloudy.[n].SetTo(Variable.Discrete(probCloudy).ForEach(n))
2018-10-25 16:51:56 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("sprinkler")
2018-10-25 16:51:56 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("rain")
2018-10-25 16:51:56 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("wetGrass")
2018-10-25 16:51:56 - Expression evaluation failed: cloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-25 16:51:56 - ArgumentExceptioncloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-25 16:51:56 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange (System.Boolean throwIfMissing) [0x00022] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 16:51:56 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange () [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 16:51:56 -   at Microsoft.ML.Probabilistic.Models.Variable.Switch (Microsoft.ML.Probabilistic.Models.Variable`1[T] i) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 16:51:56 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x00000] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 16:51:56 -   at FSI_0084+AddChildFromOneParent@3-4.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x00020] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 16:51:56 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 16:51:56 -   at FSI_0084.AddChildFromOneParent (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] cpt) [0x00016] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 16:51:56 -   at <StartupCode$FSI_0200>.$FSI_0200.main@ () [0x0000a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 16:51:56 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 16:51:56 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 16:53:28 - let cloudy = Variable.Array<int>(n).Named("cloudy")
2018-10-25 16:53:28 - cloudy.SetValueRange(n)
2018-10-25 16:53:28 - cloudy.[n].SetTo(Variable.Discrete(probCloudy).ForEach(n))
2018-10-25 16:53:28 - Expression evaluation failed: Range 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 16:53:28 - InvalidOperationExceptionRange 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 16:53:28 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0008f] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 16:53:28 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 16:53:28 -   at Microsoft.ML.Probabilistic.Models.VariableArray`1[T]..ctor (Microsoft.ML.Probabilistic.Models.Range range) [0x00006] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 16:53:28 -   at Microsoft.ML.Probabilistic.Models.Variable.Array[T] (Microsoft.ML.Probabilistic.Models.Range r) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 16:53:28 -   at <StartupCode$FSI_0201>.$FSI_0201.main@ () [0x00005] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 16:53:28 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 16:53:28 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 16:53:36 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 16:53:36 - let n:Range = Range(numberOfExamples).Named("N")
2018-10-25 16:54:26 - let rC = Range(2).Named("C") // Cloudy
2018-10-25 16:54:26 - let rS = Range(2).Named("S") // Sprinkler
2018-10-25 16:54:26 - let rR = Range(2).Named("R") // Rain
2018-10-25 16:54:26 - let rW = Range(2).Named("W") // Wet
2018-10-25 16:55:35 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 16:55:35 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 16:55:37 - let rC = Range(2).Named("C") // Cloudy
2018-10-25 16:55:37 - let rS = Range(2).Named("S") // Sprinkler
2018-10-25 16:55:37 - let rR = Range(2).Named("R") // Rain
2018-10-25 16:55:37 - let rW = Range(2).Named("W") // Wet
2018-10-25 16:55:45 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-25 16:55:45 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-25 16:55:45 - probCloudy.SetValueRange(rC)
2018-10-25 16:55:49 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-25 16:55:49 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-25 16:55:59 - cptSprinkler.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC]))
2018-10-25 16:55:59 - cptSprinkler.SetValueRange(rS)
2018-10-25 16:56:06 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-25 16:56:06 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-25 16:56:19 - cptRain.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC]))
2018-10-25 16:56:19 - cptRain.SetValueRange(rR)
2018-10-25 16:56:31 - let cptWetGrassPrior= 
2018-10-25 16:56:31 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 16:56:31 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-25 16:56:31 - let cptWetGrass = 
2018-10-25 16:56:31 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-25 16:56:31 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-25 16:56:43 - cptWetGrass.[rS].[rR].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR]))
2018-10-25 16:56:43 - cptWetGrass.SetValueRange(rW)
2018-10-25 16:57:07 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-25 16:57:16 - let priors:PriorDistributions = {
2018-10-25 16:57:16 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-25 16:57:16 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-25 16:57:16 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-25 16:57:16 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 16:57:16 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-25 16:57:22 - let parameters:DistributionParameters = {
2018-10-25 16:57:22 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-25 16:57:22 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-10-25 16:57:22 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-10-25 16:57:22 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-25 16:57:22 -                 Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-10-25 16:57:25 - parameters.cloudy.SetValueRange(ranges.c)
2018-10-25 16:57:25 - parameters.sprinkler.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c]))
2018-10-25 16:57:25 - parameters.sprinkler.SetValueRange(ranges.s)
2018-10-25 16:57:25 - parameters.rain.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c]))
2018-10-25 16:57:25 - parameters.rain.SetValueRange(ranges.r)
2018-10-25 16:57:25 - parameters.wetGrass.[ranges.s].[ranges.r].SetTo(Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[ranges.s].[ranges.r]))
2018-10-25 16:57:25 - parameters.wetGrass.SetValueRange(ranges.w)
2018-10-25 16:57:40 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-25 16:57:40 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-25 16:57:40 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-25 16:57:40 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-25 16:57:40 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 16:57:40 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-25 16:57:41 - let priors = buildPriors ranges
2018-10-25 16:57:45 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-25 16:57:45 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-25 16:57:45 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-25 16:57:45 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-25 16:57:45 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-25 16:57:45 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-25 16:57:45 -     probCloudy.SetValueRange(rg.c)
2018-10-25 16:57:45 -     cptSprinkler.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c]))
2018-10-25 16:57:45 -     cptSprinkler.SetValueRange(rg.s)
2018-10-25 16:57:45 -     cptRain.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c]))
2018-10-25 16:57:45 -     cptRain.SetValueRange(rg.r)
2018-10-25 16:57:45 -     cptWetGrass.[rg.s].[rg.r].SetTo(Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r]))
2018-10-25 16:57:45 -     cptWetGrass.SetValueRange(rg.w)
2018-10-25 16:57:45 -     {cloudy = probCloudy; sprinkler =cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-25 16:57:49 - let parameters = buildDistributionParameters ranges priors
2018-10-25 16:57:58 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 16:57:58 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 16:58:32 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 16:58:32 - //cloudy.SetValueRange(n)
2018-10-25 16:58:32 - cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-25 16:58:41 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("sprinkler")
2018-10-25 16:58:41 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("rain")
2018-10-25 16:58:41 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("wetGrass")
2018-10-25 16:59:31 - let rvs:RandomVariables =
2018-10-25 16:59:31 -     let c:VariableArray<int> = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 16:59:31 -     let s:VariableArray<int> = (AddChildFromOneParent rC cptSprinkler).Named("sprinkler")
2018-10-25 16:59:31 -     let r:VariableArray<int> = (AddChildFromOneParent rC cptRain).Named("rain")
2018-10-25 16:59:31 -     let w:VariableArray<int> = (AddChildFromTwoParents rS rR cptWetGrass).Named("wetGrass")
2018-10-25 16:59:31 -     {cloudy = c; sprinkler =s; rain = r; wetGrass = w}
2018-10-25 16:59:31 - The type 'Range' is not compatible with the type 'Parent'
2018-10-25 16:59:31 - The type 'Range' is not compatible with the type 'Parent'
2018-10-25 16:59:31 - The type 'Range' is not compatible with the type 'Parent'
2018-10-25 16:59:31 - The type 'Range' is not compatible with the type 'Parent'
2018-10-25 17:00:54 - let rvs:RandomVariables =
2018-10-25 17:00:54 -     let vC:VariableArray<int> = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:00:54 -     let vS:VariableArray<int> = (AddChildFromOneParent vC cptSprinkler).Named("sprinkler")
2018-10-25 17:00:54 -     let vR:VariableArray<int> = (AddChildFromOneParent vC cptRain).Named("rain")
2018-10-25 17:00:54 -     let vW:VariableArray<int> = (AddChildFromTwoParents vS vR cptWetGrass).Named("wetGrass")
2018-10-25 17:00:54 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-25 17:00:54 - Expression evaluation failed: cloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-25 17:00:54 - ArgumentExceptioncloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-25 17:00:54 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange (System.Boolean throwIfMissing) [0x00022] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:00:54 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange () [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:00:54 -   at Microsoft.ML.Probabilistic.Models.Variable.Switch (Microsoft.ML.Probabilistic.Models.Variable`1[T] i) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:00:54 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x00000] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:00:54 -   at FSI_0084+AddChildFromOneParent@3-4.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x00020] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:00:54 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:00:54 -   at FSI_0084.AddChildFromOneParent (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] cpt) [0x00016] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:00:54 -   at <StartupCode$FSI_0231>.$FSI_0231.main@ () [0x00023] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:00:54 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:00:54 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:02:31 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 17:02:31 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 17:02:32 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:02:32 - cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-25 17:02:34 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("sprinkler")
2018-10-25 17:02:34 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("rain")
2018-10-25 17:02:34 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("wetGrass")
2018-10-25 17:02:53 - let rvs:RandomVariables =
2018-10-25 17:02:53 -     let vC:VariableArray<int> = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:02:53 -     let vS:VariableArray<int> = (AddChildFromOneParent vC cptSprinkler).Named("sprinkler")
2018-10-25 17:02:53 -     let vR:VariableArray<int> = (AddChildFromOneParent vC cptRain).Named("rain")
2018-10-25 17:02:53 -     let vW:VariableArray<int> = (AddChildFromTwoParents vS vR cptWetGrass).Named("wetGrass")
2018-10-25 17:02:53 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-25 17:02:53 - Expression evaluation failed: cloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-25 17:02:53 - ArgumentExceptioncloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-25 17:02:53 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange (System.Boolean throwIfMissing) [0x00022] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:02:53 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange () [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:02:53 -   at Microsoft.ML.Probabilistic.Models.Variable.Switch (Microsoft.ML.Probabilistic.Models.Variable`1[T] i) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:02:53 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x00000] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:02:53 -   at FSI_0084+AddChildFromOneParent@3-4.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x00020] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:02:53 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:02:53 -   at FSI_0084.AddChildFromOneParent (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] cpt) [0x00016] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:02:53 -   at <StartupCode$FSI_0236>.$FSI_0236.main@ () [0x00023] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:02:53 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:02:53 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:03:41 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-25 17:03:41 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-25 17:03:41 - probCloudy.SetValueRange(rC)
2018-10-25 17:04:18 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:04:18 - cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-25 17:04:18 - cloudy.SetValueRange(rC)
2018-10-25 17:04:18 - Expression evaluation failed: Range 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:04:18 - InvalidOperationExceptionRange 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:04:18 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0008f] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:04:18 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:04:18 -   at Microsoft.ML.Probabilistic.Models.VariableArray`1[T]..ctor (Microsoft.ML.Probabilistic.Models.Range range) [0x00006] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:04:18 -   at Microsoft.ML.Probabilistic.Models.Variable.Array[T] (Microsoft.ML.Probabilistic.Models.Range r) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:04:18 -   at <StartupCode$FSI_0239>.$FSI_0239.main@ () [0x00005] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:04:18 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:04:18 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:04:22 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 17:04:22 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 17:04:23 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:04:23 - cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-25 17:04:23 - cloudy.SetValueRange(rC)
2018-10-25 17:04:45 - let rvs:RandomVariables =
2018-10-25 17:04:45 -     let vC:VariableArray<int> = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:04:45 -     let vS:VariableArray<int> = (AddChildFromOneParent vC cptSprinkler).Named("sprinkler")
2018-10-25 17:04:45 -     let vR:VariableArray<int> = (AddChildFromOneParent vC cptRain).Named("rain")
2018-10-25 17:04:45 -     let vW:VariableArray<int> = (AddChildFromTwoParents vS vR cptWetGrass).Named("wetGrass")
2018-10-25 17:04:45 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-25 17:04:46 - Expression evaluation failed: cloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-25 17:04:46 - ArgumentExceptioncloudy[N] has no ValueRange attribute, which is needed for indexing arrays.  Try adding the range as an argument to the constructor, or attaching it via .SetValueRange(myRange)
2018-10-25 17:04:46 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange (System.Boolean throwIfMissing) [0x00022] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:04:46 -   at Microsoft.ML.Probabilistic.Models.Variable.GetValueRange () [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:04:46 -   at Microsoft.ML.Probabilistic.Models.Variable.Switch (Microsoft.ML.Probabilistic.Models.Variable`1[T] i) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:04:46 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x00000] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:04:46 -   at FSI_0084+AddChildFromOneParent@3-4.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x00020] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:04:46 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:04:46 -   at FSI_0084.AddChildFromOneParent (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] cpt) [0x00016] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:04:46 -   at <StartupCode$FSI_0243>.$FSI_0243.main@ () [0x00023] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:04:46 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:04:46 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:05:50 - let rvs:RandomVariables =
2018-10-25 17:05:50 -     let vC:VariableArray<int> = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:05:50 -     cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-25 17:05:50 -     let vS:VariableArray<int> = (AddChildFromOneParent vC cptSprinkler).Named("sprinkler")
2018-10-25 17:05:50 -     let vR:VariableArray<int> = (AddChildFromOneParent vC cptRain).Named("rain")
2018-10-25 17:05:50 -     let vW:VariableArray<int> = (AddChildFromTwoParents vS vR cptWetGrass).Named("wetGrass")
2018-10-25 17:05:50 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-25 17:05:50 - Expression evaluation failed: Range 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:05:50 - InvalidOperationExceptionRange 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:05:50 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0008f] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:05:50 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:05:50 -   at Microsoft.ML.Probabilistic.Models.VariableArray`1[T]..ctor (Microsoft.ML.Probabilistic.Models.Range range) [0x00006] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:05:50 -   at Microsoft.ML.Probabilistic.Models.Variable.Array[T] (Microsoft.ML.Probabilistic.Models.Range r) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:05:50 -   at <StartupCode$FSI_0244>.$FSI_0244.main@ () [0x00005] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:05:50 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:05:50 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:05:55 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 17:05:55 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 17:05:56 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:05:56 - cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-25 17:05:57 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("sprinkler")
2018-10-25 17:05:57 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("rain")
2018-10-25 17:05:57 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("wetGrass")
2018-10-25 17:06:01 - let rvs:RandomVariables =
2018-10-25 17:06:01 -     let vC:VariableArray<int> = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:06:01 -     cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-25 17:06:01 -     let vS:VariableArray<int> = (AddChildFromOneParent vC cptSprinkler).Named("sprinkler")
2018-10-25 17:06:01 -     let vR:VariableArray<int> = (AddChildFromOneParent vC cptRain).Named("rain")
2018-10-25 17:06:01 -     let vW:VariableArray<int> = (AddChildFromTwoParents vS vR cptWetGrass).Named("wetGrass")
2018-10-25 17:06:01 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-25 17:06:01 - Expression evaluation failed: Cannot define a variable more than once
2018-10-25 17:06:01 - InvalidOperationExceptionCannot define a variable more than once
2018-10-25 17:06:01 -   at Microsoft.ML.Probabilistic.Models.Variable.SetDefinition (Microsoft.ML.Probabilistic.Models.MethodInvoke methodInvoke) [0x00022] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:06:01 -   at Microsoft.ML.Probabilistic.Models.Variable`1[T].SetTo (Microsoft.ML.Probabilistic.Models.MethodInvoke methodInvoke) [0x00019] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:06:01 -   at Microsoft.ML.Probabilistic.Models.Variable`1[T].SetTo (Microsoft.ML.Probabilistic.Models.Variable`1[T] variable) [0x00055] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:06:01 -   at <StartupCode$FSI_0249>.$FSI_0249.main@ () [0x0003c] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:06:01 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:06:01 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:06:17 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 17:06:17 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 17:06:20 - let rvs:RandomVariables =
2018-10-25 17:06:20 -     let vC:VariableArray<int> = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:06:20 -     cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-25 17:06:20 -     let vS:VariableArray<int> = (AddChildFromOneParent vC cptSprinkler).Named("sprinkler")
2018-10-25 17:06:20 -     let vR:VariableArray<int> = (AddChildFromOneParent vC cptRain).Named("rain")
2018-10-25 17:06:20 -     let vW:VariableArray<int> = (AddChildFromTwoParents vS vR cptWetGrass).Named("wetGrass")
2018-10-25 17:06:20 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-25 17:06:20 - Expression evaluation failed: VariableArray<int> cloudy cannot be indexed by N. Perhaps you omitted N as an argument to the constructor?
2018-10-25 17:06:20 - Parameter name: index
2018-10-25 17:06:20 - ArgumentExceptionVariableArray<int> cloudy cannot be indexed by N. Perhaps you omitted N as an argument to the constructor?
2018-10-25 17:06:20 - Parameter name: index
2018-10-25 17:06:20 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:06:20 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:06:20 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:06:20 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:06:20 -   at <StartupCode$FSI_0251>.$FSI_0251.main@ () [0x00023] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:06:20 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:06:20 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:07:11 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 17:07:11 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 17:07:15 - let rvs:RandomVariables =
2018-10-25 17:07:15 -     let vC:VariableArray<int> = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:07:15 -     cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-25 17:07:15 -     let vS:VariableArray<int> = (AddChildFromOneParent vC cptSprinkler).Named("sprinkler")
2018-10-25 17:07:15 -     let vR:VariableArray<int> = (AddChildFromOneParent vC cptRain).Named("rain")
2018-10-25 17:07:15 -     let vW:VariableArray<int> = (AddChildFromTwoParents vS vR cptWetGrass).Named("wetGrass")
2018-10-25 17:07:15 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-25 17:07:15 - Expression evaluation failed: VariableArray<int> cloudy cannot be indexed by N. Perhaps you omitted N as an argument to the constructor?
2018-10-25 17:07:15 - Parameter name: index
2018-10-25 17:07:15 - ArgumentExceptionVariableArray<int> cloudy cannot be indexed by N. Perhaps you omitted N as an argument to the constructor?
2018-10-25 17:07:15 - Parameter name: index
2018-10-25 17:07:15 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:07:15 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:07:15 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:07:15 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:07:15 -   at <StartupCode$FSI_0253>.$FSI_0253.main@ () [0x00023] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:07:15 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:07:15 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:08:25 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 17:08:25 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 17:14:05 - let rvs:RandomVariables =
2018-10-25 17:14:05 -     let vC:VariableArray<int> = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:14:05 -     vC.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-25 17:14:05 -     let vS:VariableArray<int> = (AddChildFromOneParent vC cptSprinkler).Named("sprinkler")
2018-10-25 17:14:05 -     let vR:VariableArray<int> = (AddChildFromOneParent vC cptRain).Named("rain")
2018-10-25 17:14:05 -     let vW:VariableArray<int> = (AddChildFromTwoParents vS vR cptWetGrass).Named("wetGrass")
2018-10-25 17:14:05 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-25 17:16:24 - let buildRandomVariables (rN:Range) (paramz:DistributionParameters) :RandomVariables =
2018-10-25 17:16:24 -     let vC: VariableArray<int> = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:16:24 -     vC.[n].SetTo(Variable.Discrete(paramz.cloudy).ForEach(rN))
2018-10-25 17:16:24 -     let vS:VariableArray<int> = (AddChildFromOneParent vC paramz.sprinkler).Named("sprinkler")
2018-10-25 17:16:24 -     let vR:VariableArray<int> = (AddChildFromOneParent vC paramz.rain).Named("rain")
2018-10-25 17:16:24 -     let vW:VariableArray<int> = (AddChildFromTwoParents sprinkler rain paramz.wetGrass).Named("wetGrass")
2018-10-25 17:16:24 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-25 17:17:18 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 17:17:18 - let rN:Range = Range(NumberOfExamples).Named("N")
2018-10-25 17:17:18 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-25 17:17:18 - let priors = buildPriors ranges
2018-10-25 17:17:18 - let parameters = buildDistributionParameters ranges priors
2018-10-25 17:17:18 - let rvs = buildRandomVariables rN parameters
2018-10-25 17:17:18 - The value or constructor 'NumberOfExamples' is not defined. Maybe you want one of the following:
2018-10-25 17:17:18 -    numberOfExamples
2018-10-25 17:17:18 - A unique overload for method 'Range' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Range(N: int) : Range, Range(size: IModelExpression<int>) : Range
2018-10-25 17:17:33 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 17:17:33 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 17:17:33 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-25 17:17:33 - let priors = buildPriors ranges
2018-10-25 17:17:33 - let parameters = buildDistributionParameters ranges priors
2018-10-25 17:17:33 - let rvs = buildRandomVariables rN parameters
2018-10-25 17:17:34 - Expression evaluation failed: VariableArray<int> cloudy cannot be indexed by N. Perhaps you omitted N as an argument to the constructor?
2018-10-25 17:17:34 - Parameter name: index
2018-10-25 17:17:34 - ArgumentExceptionVariableArray<int> cloudy cannot be indexed by N. Perhaps you omitted N as an argument to the constructor?
2018-10-25 17:17:34 - Parameter name: index
2018-10-25 17:17:34 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:17:34 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:17:34 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:17:34 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:17:34 -   at FSI_0256.buildRandomVariables (Microsoft.ML.Probabilistic.Models.Range rN, FSI_0089+DistributionParameters paramz) [0x00020] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:17:34 -   at <StartupCode$FSI_0258>.$FSI_0258.main@ () [0x000b4] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:17:34 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:17:34 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:17:54 - let buildRandomVariables (rN:Range) (paramz:DistributionParameters) :RandomVariables =
2018-10-25 17:17:54 -     let vC: VariableArray<int> = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:17:54 -     vC.[rN].SetTo(Variable.Discrete(paramz.cloudy).ForEach(rN))
2018-10-25 17:17:54 -     let vS:VariableArray<int> = (AddChildFromOneParent vC paramz.sprinkler).Named("sprinkler")
2018-10-25 17:17:54 -     let vR:VariableArray<int> = (AddChildFromOneParent vC paramz.rain).Named("rain")
2018-10-25 17:17:54 -     let vW:VariableArray<int> = (AddChildFromTwoParents sprinkler rain paramz.wetGrass).Named("wetGrass")
2018-10-25 17:17:54 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-25 17:17:56 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 17:17:56 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 17:17:56 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-25 17:17:56 - let priors = buildPriors ranges
2018-10-25 17:17:56 - let parameters = buildDistributionParameters ranges priors
2018-10-25 17:17:56 - let rvs = buildRandomVariables rN parameters
2018-10-25 17:17:56 - Expression evaluation failed: VariableArray<VariableArray<Vector>, Vector[][]> cptWetGrass cannot be indexed by sprinkler[N].
2018-10-25 17:17:56 - Parameter name: index
2018-10-25 17:17:56 - ArgumentExceptionVariableArray<VariableArray<Vector>, Vector[][]> cptWetGrass cannot be indexed by sprinkler[N].
2018-10-25 17:17:56 - Parameter name: index
2018-10-25 17:17:56 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:17:56 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:17:56 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:17:56 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Variable`1[T] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:17:56 -   at FSI_0086+AddChildFromTwoParents@5-8.Invoke (Microsoft.ML.Probabilistic.Models.Variable`1[T] pi2) [0x00000] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:17:56 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x0000d] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:17:56 -   at FSI_0086+AddChildFromTwoParents@4-7.Invoke (Microsoft.ML.Probabilistic.Models.Variable`1[T] pi1) [0x00029] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:17:56 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.SwitchExpr[0] (Microsoft.ML.Probabilistic.Models.Variable`1[T] r, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] body) [0x0000d] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:17:56 -   at FSI_0086+AddChildFromTwoParents@3-6.Invoke (Microsoft.ML.Probabilistic.Models.Range i) [0x0002d] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:17:56 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x0001a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:17:56 -   at FSI_0086.AddChildFromTwoParents (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent1, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent2, Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray] cpt) [0x0001a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:17:56 -   at FSI_0259.buildRandomVariables (Microsoft.ML.Probabilistic.Models.Range rN, FSI_0089+DistributionParameters paramz) [0x00086] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:17:56 -   at <StartupCode$FSI_0260>.$FSI_0260.main@ () [0x000b4] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:17:56 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:17:56 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:18:29 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 17:18:29 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 17:18:37 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 17:18:37 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 17:18:37 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-25 17:18:37 - let priors = buildPriors ranges
2018-10-25 17:18:37 - let parameters = buildDistributionParameters ranges priors
2018-10-25 17:18:37 - let rvs = buildRandomVariables rN parameters
2018-10-25 17:18:37 - Expression evaluation failed: Range 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:18:37 - InvalidOperationExceptionRange 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:18:37 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0008f] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:18:37 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:18:37 -   at Microsoft.ML.Probabilistic.Models.VariableArray`1[T]..ctor (Microsoft.ML.Probabilistic.Models.Range range) [0x00006] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:18:37 -   at Microsoft.ML.Probabilistic.Models.Variable.Array[T] (Microsoft.ML.Probabilistic.Models.Range r) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:18:37 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00000] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:18:37 -   at FSI_0086.AddChildFromTwoParents (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent1, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent2, Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray] cpt) [0x0001a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:18:37 -   at FSI_0259.buildRandomVariables (Microsoft.ML.Probabilistic.Models.Range rN, FSI_0089+DistributionParameters paramz) [0x00086] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:18:37 -   at <StartupCode$FSI_0262>.$FSI_0262.main@ () [0x000b4] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:18:37 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:18:37 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:18:59 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 17:18:59 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 17:18:59 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-25 17:18:59 - let priors = buildPriors ranges
2018-10-25 17:18:59 - let parameters = buildDistributionParameters ranges priors
2018-10-25 17:18:59 - let rvs = buildRandomVariables rN parameters
2018-10-25 17:18:59 - Expression evaluation failed: Range 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:18:59 - InvalidOperationExceptionRange 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:18:59 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0008f] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:18:59 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:18:59 -   at Microsoft.ML.Probabilistic.Models.VariableArray`1[T]..ctor (Microsoft.ML.Probabilistic.Models.Range range) [0x00006] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:18:59 -   at Microsoft.ML.Probabilistic.Models.Variable.Array[T] (Microsoft.ML.Probabilistic.Models.Range r) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:18:59 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00000] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:18:59 -   at FSI_0086.AddChildFromTwoParents (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent1, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent2, Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray] cpt) [0x0001a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:18:59 -   at FSI_0259.buildRandomVariables (Microsoft.ML.Probabilistic.Models.Range rN, FSI_0089+DistributionParameters paramz) [0x00086] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:18:59 -   at <StartupCode$FSI_0263>.$FSI_0263.main@ () [0x000b4] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:18:59 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:18:59 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:20:07 - let priors = buildPriors ranges
2018-10-25 17:20:10 - let parameters = buildDistributionParameters ranges priors
2018-10-25 17:20:27 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 17:20:27 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 17:20:27 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-25 17:20:27 - let priors = buildPriors ranges
2018-10-25 17:20:27 - let parameters = buildDistributionParameters ranges priors
2018-10-25 17:20:34 - let buildRandomVariables (rN:Range) (paramz:DistributionParameters) :RandomVariables =
2018-10-25 17:20:34 -     let vC: VariableArray<int> = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:20:34 -     vC.[rN].SetTo(Variable.Discrete(paramz.cloudy).ForEach(rN))
2018-10-25 17:20:34 -     let vS:VariableArray<int> = (AddChildFromOneParent vC paramz.sprinkler).Named("sprinkler")
2018-10-25 17:20:34 -     let vR:VariableArray<int> = (AddChildFromOneParent vC paramz.rain).Named("rain")
2018-10-25 17:20:34 -     let vW:VariableArray<int> = (AddChildFromTwoParents sprinkler rain paramz.wetGrass).Named("wetGrass")
2018-10-25 17:20:34 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-25 17:20:36 - let rvs = buildRandomVariables rN parameters
2018-10-25 17:20:36 - Expression evaluation failed: Range 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:20:36 - InvalidOperationExceptionRange 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:20:36 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0008f] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:20:36 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:20:36 -   at Microsoft.ML.Probabilistic.Models.VariableArray`1[T]..ctor (Microsoft.ML.Probabilistic.Models.Range range) [0x00006] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:20:36 -   at Microsoft.ML.Probabilistic.Models.Variable.Array[T] (Microsoft.ML.Probabilistic.Models.Range r) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:20:36 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00000] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:20:36 -   at FSI_0086.AddChildFromTwoParents (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent1, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent2, Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray] cpt) [0x0001a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:20:36 -   at FSI_0267.buildRandomVariables (Microsoft.ML.Probabilistic.Models.Range rN, FSI_0089+DistributionParameters paramz) [0x00086] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:20:36 -   at <StartupCode$FSI_0268>.$FSI_0268.main@ () [0x0000a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:20:36 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:20:36 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:23:07 - let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-25 17:23:07 -     let vC: VariableArray<int> = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:23:07 -     vC.[rN].SetTo(Variable.Discrete(dp.cloudy).ForEach(rN))
2018-10-25 17:23:07 -     let vS:VariableArray<int> = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-25 17:23:07 -     let vR:VariableArray<int> = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-25 17:23:07 -     let vW:VariableArray<int> = (AddChildFromTwoParents sprinkler rain dp.wetGrass).Named("wetGrass")
2018-10-25 17:23:07 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-25 17:23:09 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 17:23:09 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 17:23:09 - let ranges:Ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-25 17:23:09 - let priors = buildPriors ranges
2018-10-25 17:23:09 - let parameters = buildDistributionParameters ranges priors
2018-10-25 17:23:10 - let rvs = buildRandomVariables rN parameters
2018-10-25 17:23:11 - Expression evaluation failed: Range 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:23:11 - InvalidOperationExceptionRange 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:23:11 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0008f] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:23:11 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:23:11 -   at Microsoft.ML.Probabilistic.Models.VariableArray`1[T]..ctor (Microsoft.ML.Probabilistic.Models.Range range) [0x00006] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:23:11 -   at Microsoft.ML.Probabilistic.Models.Variable.Array[T] (Microsoft.ML.Probabilistic.Models.Range r) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:23:11 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00000] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:23:11 -   at FSI_0086.AddChildFromTwoParents (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent1, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent2, Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray] cpt) [0x0001a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:23:11 -   at FSI_0269.buildRandomVariables (Microsoft.ML.Probabilistic.Models.Range rN, FSI_0089+DistributionParameters dp) [0x00086] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:23:11 -   at <StartupCode$FSI_0271>.$FSI_0271.main@ () [0x0000a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:23:11 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:23:11 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:24:20 - let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-25 17:24:20 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:24:20 -     vC.[rN].SetTo(Variable.Discrete(dp.cloudy).ForEach(rN))
2018-10-25 17:24:20 -     let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-25 17:24:20 -     let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-25 17:24:20 -     let vW = (AddChildFromTwoParents sprinkler rain dp.wetGrass).Named("wetGrass")
2018-10-25 17:24:20 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-25 17:24:59 - let rvs = buildRandomVariables rN parameters
2018-10-25 17:25:00 - Expression evaluation failed: Range 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:25:00 - InvalidOperationExceptionRange 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:25:00 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0008f] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:25:00 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:25:00 -   at Microsoft.ML.Probabilistic.Models.VariableArray`1[T]..ctor (Microsoft.ML.Probabilistic.Models.Range range) [0x00006] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:25:00 -   at Microsoft.ML.Probabilistic.Models.Variable.Array[T] (Microsoft.ML.Probabilistic.Models.Range r) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:25:00 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00000] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:25:00 -   at FSI_0086.AddChildFromTwoParents (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent1, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent2, Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray] cpt) [0x0001a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:25:00 -   at FSI_0272.buildRandomVariables (Microsoft.ML.Probabilistic.Models.Range rN, FSI_0089+DistributionParameters dp) [0x00086] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:25:00 -   at <StartupCode$FSI_0273>.$FSI_0273.main@ () [0x0000a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:25:00 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:25:00 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:25:33 - let numberOfExamples = Variable.New<int>().Named("NofE")
2018-10-25 17:25:33 - let rN = Range(numberOfExamples).Named("N")
2018-10-25 17:25:33 - let ranges = {c=Range(2).Named("c"); s=Range(2).Named("s"); r=Range(2).Named("r"); w=Range(2).Named("w")}
2018-10-25 17:25:33 - let priors = buildPriors ranges
2018-10-25 17:25:33 - let parameters = buildDistributionParameters ranges priors
2018-10-25 17:25:52 - ranges.GetType()
2018-10-25 17:26:27 - let numberOfExamples = Variable.New<int>().Named("NofE")
2018-10-25 17:26:27 - let rN = Range(numberOfExamples).Named("N")
2018-10-25 17:26:27 - let ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("W")}
2018-10-25 17:26:27 - let priors = buildPriors ranges
2018-10-25 17:26:27 - let parameters = buildDistributionParameters ranges priors
2018-10-25 17:27:53 - let rN=1
2018-10-25 17:27:57 - let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-25 17:27:57 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:27:57 -     vC.[rN].SetTo(Variable.Discrete(dp.cloudy).ForEach(rN))
2018-10-25 17:27:57 -     let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-25 17:27:57 -     let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-25 17:27:57 -     let vW = (AddChildFromTwoParents sprinkler rain dp.wetGrass).Named("wetGrass")
2018-10-25 17:27:57 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-25 17:28:12 - let numberOfExamples = Variable.New<int>().Named("NofE")
2018-10-25 17:28:12 - let rN = Range(numberOfExamples).Named("N")
2018-10-25 17:28:12 - let ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("W")}
2018-10-25 17:28:12 - let priors = buildPriors ranges
2018-10-25 17:28:12 - let parameters = buildDistributionParameters ranges priors
2018-10-25 17:28:14 - let rvs = buildRandomVariables rN parameters
2018-10-25 17:28:15 - Expression evaluation failed: Range 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:28:15 - InvalidOperationExceptionRange 'N' is already open in a ForEach block.  Use a cloned range instead.
2018-10-25 17:28:15 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range[] ranges) [0x0008f] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:28:15 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray]..ctor (Microsoft.ML.Probabilistic.Models.Variable`1[T] itemPrototype, Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:28:15 -   at Microsoft.ML.Probabilistic.Models.VariableArray`1[T]..ctor (Microsoft.ML.Probabilistic.Models.Range range) [0x00006] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:28:15 -   at Microsoft.ML.Probabilistic.Models.Variable.Array[T] (Microsoft.ML.Probabilistic.Models.Range r) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-25 17:28:15 -   at FSI_0081.Microsoft.ML.Probabilistic.FSharp.Variable.ArrayInit[0] (Microsoft.ML.Probabilistic.Models.Range n, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00000] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:28:15 -   at FSI_0086.AddChildFromTwoParents (Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent1, Microsoft.ML.Probabilistic.Models.VariableArray`1[T] parent2, Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray] cpt) [0x0001a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:28:15 -   at FSI_0279.buildRandomVariables (Microsoft.ML.Probabilistic.Models.Range rN, FSI_0089+DistributionParameters dp) [0x00086] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:28:15 -   at <StartupCode$FSI_0281>.$FSI_0281.main@ () [0x0000a] in <99032f51c2db402ba0f87cdd8d270a64>:0 
2018-10-25 17:28:15 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-25 17:28:15 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-25 17:29:06 - let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-25 17:29:06 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 17:29:06 -     vC.[rN].SetTo(Variable.Discrete(dp.cloudy).ForEach(rN))
2018-10-25 17:29:06 -     let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-25 17:29:06 -     let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-25 17:29:06 -     let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-25 17:29:06 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-25 17:29:08 - let numberOfExamples = Variable.New<int>().Named("NofE")
2018-10-25 17:29:08 - let rN = Range(numberOfExamples).Named("N")
2018-10-25 17:29:08 - let ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("W")}
2018-10-25 17:29:08 - let priors = buildPriors ranges
2018-10-25 17:29:08 - let parameters = buildDistributionParameters ranges priors
2018-10-25 17:29:09 - let rvs = buildRandomVariables rN parameters
2018-10-25 20:32:04 - type Parent = VariableArray<int>
2018-10-25 20:32:04 - type Child = VariableArray<int>
2018-10-25 20:32:04 - type ParentCase = Variable<int>
2018-10-25 20:32:04 - type ConditionalProbabilityTable = VariableArray<Vector>
2018-10-25 20:32:05 - let AddChildFromOneParent (parent:Parent) (cpt:ConditionalProbabilityTable) =
2018-10-25 20:32:05 -     let r = parent.Range
2018-10-25 20:32:05 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-25 20:32:05 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:ParentCase) ->  
2018-10-25 20:32:05 -                        Variable.Discrete(cpt.[pi])))
2018-10-25 20:32:05 -     child
2018-10-25 20:32:05 - type ConditionalProbabilityTable2D = VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-25 20:32:06 - let AddChildFromTwoParents (parent1:Parent) (parent2:Parent) (cpt:ConditionalProbabilityTable2D) = 
2018-10-25 20:32:06 -     let r = parent1.Range
2018-10-25 20:32:06 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-25 20:32:06 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:ParentCase) ->  
2018-10-25 20:32:06 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:ParentCase) ->  
2018-10-25 20:32:06 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-25 20:32:06 -     child       
2018-10-25 20:32:06 - let engine =  InferenceEngine ()
2018-10-25 20:32:07 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 20:32:07 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 20:32:07 - let rC = Range(2).Named("C") // Cloudy
2018-10-25 20:32:07 - let rS = Range(2).Named("S") // Sprinkler
2018-10-25 20:32:07 - let rR = Range(2).Named("R") // Rain
2018-10-25 20:32:07 - let rW = Range(2).Named("W") // Wet
2018-10-25 20:32:07 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-25 20:32:07 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-25 20:32:07 - probCloudy.SetValueRange(rC)
2018-10-25 20:32:08 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-25 20:32:08 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-25 20:32:08 - cptSprinkler.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC]))
2018-10-25 20:32:08 - cptSprinkler.SetValueRange(rS)
2018-10-25 20:32:08 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-25 20:32:08 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-25 20:32:09 - cptRain.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC]))
2018-10-25 20:32:09 - cptRain.SetValueRange(rR)
2018-10-25 20:32:09 - let cptWetGrassPrior= 
2018-10-25 20:32:09 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-25 20:32:09 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-25 20:32:09 - let cptWetGrass = 
2018-10-25 20:32:09 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-25 20:32:09 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-25 20:32:10 - cptWetGrass.[rS].[rR].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR]))
2018-10-25 20:32:10 - cptWetGrass.SetValueRange(rW)
2018-10-25 20:32:10 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-25 20:32:10 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-25 20:32:11 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-25 20:32:11 - cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-25 20:39:36 - let a:array<int> = [|3|]
2018-10-25 20:39:55 - let a:array<int> = [|3|]
2018-10-25 20:39:55 - let b:int[] = = [|3|]
2018-10-25 20:39:55 - Unexpected symbol '=' in binding
2018-10-25 20:39:58 - let a:array<int> = [|3|]
2018-10-25 20:39:58 - let b:int[] =  [|3|]
2018-10-25 20:40:13 - let a:array<int> = [|3|]
2018-10-25 20:40:13 - let b:int[] =  [|3|]
2018-10-25 20:40:13 - let c:int[] = a
2018-10-25 20:41:28 - let a:array<int> = [|3|]
2018-10-25 20:41:28 - let b:int[] =  [|3|]
2018-10-25 20:41:28 - let c:int[] = a
2018-10-25 20:41:28 - let d:Vector[][] = [|[|3|]|]
2018-10-25 20:41:29 - The type 'int' is not compatible with the type 'Vector'
2018-10-25 20:41:40 - let a:array<int> = [|3|]
2018-10-25 20:41:40 - let b:int[] =  [|3|]
2018-10-25 20:41:40 - let c:int[] = a
2018-10-25 20:41:40 - let d:Vector[][] = [|[|Vector(2,3)|]|]
2018-10-25 20:41:40 - This type has no accessible object constructors
2018-10-25 20:42:06 - let a:array<int> = [|3|]
2018-10-25 20:42:06 - let b:int[] =  [|3|]
2018-10-25 20:42:06 - let c:int[] = a
2018-10-25 20:42:06 - let d:Vector[][] = [|[|Vector.FromArray(2,3)|]|]
2018-10-25 20:42:07 - No overloads match for method 'FromArray'. The available overloads are shown below.
2018-10-25 20:42:07 - Possible overload: 'Vector.FromArray([<ParamArray>] data: float []) : Vector'. Type constraint mismatch. The type 
2018-10-25 20:42:07 -     'int'    
2018-10-25 20:42:07 - is not compatible with type
2018-10-25 20:42:07 -     'float'    
2018-10-25 20:42:07 - .
2018-10-25 20:42:07 - Possible overload: 'Vector.FromArray(data: float [], sparsity: Sparsity) : Vector'. Type constraint mismatch. The type 
2018-10-25 20:42:07 -     'int'    
2018-10-25 20:42:07 - is not compatible with type
2018-10-25 20:42:07 -     'float []'    
2018-10-25 20:42:07 - .
2018-10-25 20:42:32 - let a:array<int> = [|3|]
2018-10-25 20:42:32 - let b:int[] =  [|3|]
2018-10-25 20:42:32 - let c:int[] = a
2018-10-25 20:42:32 - let d:Vector[][] = [|[|Vector.FromArray(2.,3.)|]|]
2018-10-25 20:42:56 - let a:array<int> = [|3|]
2018-10-25 20:42:56 - let b:int[] =  [|3|]
2018-10-25 20:42:56 - let c:int[] = a
2018-10-25 20:42:56 - let d:Vector[][] = [|[|Vector.FromArray(2.,3.)|]|]
2018-10-25 20:42:56 - let e:array<array<Vector>> = [|[|Vector.FromArray(2.,3.)|]|]
2018-10-25 20:43:13 - let a:array<int> = [|3|]
2018-10-25 20:43:13 - let b:int[] =  [|3|]
2018-10-25 20:43:13 - let c:int[] = a
2018-10-25 20:43:13 - let d:Vector[][] = [|[|Vector.FromArray(2.,3.)|]|]
2018-10-25 20:43:13 - let e:array<array<Vector>> = [|[|Vector.FromArray(2.,3.)|]|]
2018-10-25 20:43:13 - let f:array<array<Vector>> = d
2018-10-27 13:56:30 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-27 13:56:30 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-27 13:56:30 - For help type #help;;
2018-10-27 13:56:30 - > val it :
2018-10-27 13:56:30 -   ResizeArray<System.Type *
2018-10-27 13:56:30 -               (obj ->
2018-10-27 13:56:30 -                  seq<string *
2018-10-27 13:56:30 -                      string> *
2018-10-27 13:56:30 -                  string)>
2018-10-27 13:56:30 - = seq []
2018-10-27 13:56:30 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-27 13:56:30 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-27 13:56:30 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-27 13:56:31 - Reporting 0 opened comms
2018-10-27 13:56:31 - type Parent = VariableArray<int>
2018-10-27 13:56:31 - type Child = VariableArray<int>
2018-10-27 13:56:31 - type ParentCase = Variable<int>
2018-10-27 13:56:31 - type ConditionalProbabilityTable = VariableArray<Vector>
2018-10-27 13:56:33 - The type 'VariableArray' is not defined.
2018-10-27 13:56:33 - The type 'VariableArray' is not defined.
2018-10-27 13:56:33 - The type 'VariableArray' is not defined.
2018-10-27 13:56:33 - The type 'VariableArray' is not defined.
2018-10-27 13:56:33 - The type 'Variable' is not defined.
2018-10-27 13:56:33 - The type 'Variable' is not defined.
2018-10-27 13:56:33 - The type 'VariableArray' is not defined.
2018-10-27 13:56:33 - The type 'VariableArray' is not defined.
2018-10-27 13:56:33 - let AddChildFromOneParent (parent:Parent) (cpt:ConditionalProbabilityTable) =
2018-10-27 13:56:33 -     let r = parent.Range
2018-10-27 13:56:33 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 13:56:33 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:ParentCase) ->  
2018-10-27 13:56:33 -                        Variable.Discrete(cpt.[pi])))
2018-10-27 13:56:33 -     child
2018-10-27 13:56:34 - The type 'Parent' is not defined.
2018-10-27 13:56:34 - The type 'ConditionalProbabilityTable' is not defined.
2018-10-27 13:56:34 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-27 13:56:34 - The type 'Child' is not defined.
2018-10-27 13:56:34 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 13:56:34 - type ConditionalProbabilityTable2D = VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-27 13:56:34 - The type 'VariableArray' is not defined.
2018-10-27 13:56:34 - The type 'VariableArray' is not defined.
2018-10-27 13:56:35 - let AddChildFromTwoParents (parent1:Parent) (parent2:Parent) (cpt:ConditionalProbabilityTable2D) = 
2018-10-27 13:56:35 -     let r = parent1.Range
2018-10-27 13:56:35 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 13:56:35 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:ParentCase) ->  
2018-10-27 13:56:35 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:ParentCase) ->  
2018-10-27 13:56:35 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-27 13:56:35 -     child       
2018-10-27 13:56:35 - The type 'Parent' is not defined.
2018-10-27 13:56:35 - The type 'Parent' is not defined.
2018-10-27 13:56:35 - The type 'ConditionalProbabilityTable2D' is not defined.
2018-10-27 13:56:35 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-27 13:56:35 - The type 'Child' is not defined.
2018-10-27 13:56:35 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 13:56:35 - let engine =  InferenceEngine ()
2018-10-27 13:56:35 - The value or constructor 'InferenceEngine' is not defined.
2018-10-27 13:56:36 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 13:56:36 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 13:56:36 - The type 'Variable' is not defined.
2018-10-27 13:56:36 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 13:56:36 - The type 'Range' is not defined.
2018-10-27 13:56:36 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 13:56:36 -    raise
2018-10-27 13:56:36 - let rC = Range(2).Named("C") // Cloudy
2018-10-27 13:56:36 - let rS = Range(2).Named("S") // Sprinkler
2018-10-27 13:56:36 - let rR = Range(2).Named("R") // Rain
2018-10-27 13:56:36 - let rW = Range(2).Named("W") // Wet
2018-10-27 13:56:37 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 13:56:37 -    raise
2018-10-27 13:56:37 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 13:56:37 -    raise
2018-10-27 13:56:37 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 13:56:37 -    raise
2018-10-27 13:56:37 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 13:56:37 -    raise
2018-10-27 13:56:37 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-27 13:56:37 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-27 13:56:37 - probCloudy.SetValueRange(rC)
2018-10-27 13:56:37 - The type 'Variable' is not defined.
2018-10-27 13:56:37 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 13:56:37 - The type 'Variable' is not defined.
2018-10-27 13:56:37 - The value or constructor 'Variable' is not defined.
2018-10-27 13:56:37 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-27 13:56:37 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-27 13:56:37 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-27 13:56:38 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 13:56:38 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 13:56:38 - cptSprinkler.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC]))
2018-10-27 13:56:38 - cptSprinkler.SetValueRange(rS)
2018-10-27 13:56:38 - The value or constructor 'cptSprinkler' is not defined.
2018-10-27 13:56:38 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 13:56:38 - The value, namespace, type or module 'cptSprinkler' is not defined.
2018-10-27 13:56:39 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-27 13:56:39 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-27 13:56:39 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 13:56:39 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 13:56:39 - cptRain.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC]))
2018-10-27 13:56:39 - cptRain.SetValueRange(rR)
2018-10-27 13:56:39 - The value or constructor 'cptRain' is not defined.
2018-10-27 13:56:39 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 13:56:39 - The value, namespace, type or module 'cptRain' is not defined.
2018-10-27 13:56:40 - let cptWetGrassPrior= 
2018-10-27 13:56:40 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 13:56:40 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-27 13:56:40 - let cptWetGrass = 
2018-10-27 13:56:40 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 13:56:40 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-27 13:56:40 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 13:56:40 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 13:56:41 - cptWetGrass.[rS].[rR].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR]))
2018-10-27 13:56:41 - cptWetGrass.SetValueRange(rW)
2018-10-27 13:56:41 - The value or constructor 'cptWetGrass' is not defined.
2018-10-27 13:56:41 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 13:56:41 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 13:56:41 - The value, namespace, type or module 'cptWetGrass' is not defined.
2018-10-27 13:56:41 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 13:56:41 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 13:56:42 - The type 'Variable' is not defined.
2018-10-27 13:56:42 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 13:56:42 - The type 'Range' is not defined.
2018-10-27 13:56:42 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 13:56:42 -    raise
2018-10-27 13:56:42 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 13:56:42 - cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-27 13:56:42 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 13:56:42 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 14:02:07 - Note that each of the four main parts of the model require multiple types:
2018-10-27 14:02:07 - * Dirichlet distribution for the probabilities that are the parameters of the
2018-10-27 14:02:07 - * Discrete (actually Bernouilli) distribution 
2018-10-27 14:02:08 - Unexpected keyword 'of' in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2018-10-27 14:02:08 - parse error
2018-10-27 14:21:30 - #load "Paket.fsx"
2018-10-27 14:21:59 - shutdown request
2018-10-27 14:22:27 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-27 14:22:27 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-27 14:22:27 - For help type #help;;
2018-10-27 14:22:27 - > val it :
2018-10-27 14:22:27 -   ResizeArray<System.Type *
2018-10-27 14:22:27 -               (obj ->
2018-10-27 14:22:27 -                  seq<string *
2018-10-27 14:22:27 -                      string> *
2018-10-27 14:22:27 -                  string)>
2018-10-27 14:22:27 - = seq []
2018-10-27 14:22:27 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-27 14:22:27 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-27 14:22:27 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-27 14:22:28 - type Parent = VariableArray<int>
2018-10-27 14:22:28 - type Child = VariableArray<int>
2018-10-27 14:22:28 - type ParentCase = Variable<int>
2018-10-27 14:22:28 - type ConditionalProbabilityTable = VariableArray<Vector>
2018-10-27 14:22:30 - The type 'VariableArray' is not defined.
2018-10-27 14:22:30 - The type 'VariableArray' is not defined.
2018-10-27 14:22:30 - The type 'VariableArray' is not defined.
2018-10-27 14:22:30 - The type 'VariableArray' is not defined.
2018-10-27 14:22:30 - The type 'Variable' is not defined.
2018-10-27 14:22:30 - The type 'Variable' is not defined.
2018-10-27 14:22:30 - The type 'VariableArray' is not defined.
2018-10-27 14:22:30 - The type 'VariableArray' is not defined.
2018-10-27 14:22:30 - let AddChildFromOneParent (parent:Parent) (cpt:ConditionalProbabilityTable) =
2018-10-27 14:22:30 -     let r = parent.Range
2018-10-27 14:22:30 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 14:22:30 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:ParentCase) ->  
2018-10-27 14:22:30 -                        Variable.Discrete(cpt.[pi])))
2018-10-27 14:22:30 -     child
2018-10-27 14:22:31 - The type 'Parent' is not defined.
2018-10-27 14:22:31 - The type 'ConditionalProbabilityTable' is not defined.
2018-10-27 14:22:31 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-27 14:22:31 - The type 'Child' is not defined.
2018-10-27 14:22:31 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 14:22:31 - type ConditionalProbabilityTable2D = VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-27 14:22:31 - The type 'VariableArray' is not defined.
2018-10-27 14:22:31 - The type 'VariableArray' is not defined.
2018-10-27 14:22:31 - let AddChildFromTwoParents (parent1:Parent) (parent2:Parent) (cpt:ConditionalProbabilityTable2D) = 
2018-10-27 14:22:31 -     let r = parent1.Range
2018-10-27 14:22:31 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 14:22:31 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:ParentCase) ->  
2018-10-27 14:22:31 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:ParentCase) ->  
2018-10-27 14:22:31 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-27 14:22:31 -     child       
2018-10-27 14:22:32 - The type 'Parent' is not defined.
2018-10-27 14:22:32 - The type 'Parent' is not defined.
2018-10-27 14:22:32 - The type 'ConditionalProbabilityTable2D' is not defined.
2018-10-27 14:22:32 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-27 14:22:32 - The type 'Child' is not defined.
2018-10-27 14:22:32 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 14:22:32 - let engine =  InferenceEngine ()
2018-10-27 14:22:32 - The value or constructor 'InferenceEngine' is not defined.
2018-10-27 14:22:32 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 14:22:32 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 14:22:33 - The type 'Variable' is not defined.
2018-10-27 14:22:33 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 14:22:33 - The type 'Range' is not defined.
2018-10-27 14:22:33 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 14:22:33 -    raise
2018-10-27 14:22:33 - let rC = Range(2).Named("C") // Cloudy
2018-10-27 14:22:33 - let rS = Range(2).Named("S") // Sprinkler
2018-10-27 14:22:33 - let rR = Range(2).Named("R") // Rain
2018-10-27 14:22:33 - let rW = Range(2).Named("W") // Wet
2018-10-27 14:22:33 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 14:22:33 -    raise
2018-10-27 14:22:33 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 14:22:33 -    raise
2018-10-27 14:22:33 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 14:22:33 -    raise
2018-10-27 14:22:33 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 14:22:33 -    raise
2018-10-27 14:22:33 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-27 14:22:33 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-27 14:22:33 - probCloudy.SetValueRange(rC)
2018-10-27 14:22:34 - The type 'Variable' is not defined.
2018-10-27 14:22:34 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 14:22:34 - The type 'Variable' is not defined.
2018-10-27 14:22:34 - The value or constructor 'Variable' is not defined.
2018-10-27 14:22:34 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-27 14:22:34 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-27 14:22:34 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-27 14:22:34 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 14:22:34 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 14:22:35 - cptSprinkler.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC]))
2018-10-27 14:22:35 - cptSprinkler.SetValueRange(rS)
2018-10-27 14:22:35 - The value or constructor 'cptSprinkler' is not defined.
2018-10-27 14:22:35 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 14:22:35 - The value, namespace, type or module 'cptSprinkler' is not defined.
2018-10-27 14:22:35 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-27 14:22:35 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-27 14:22:36 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 14:22:36 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 14:22:36 - cptRain.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC]))
2018-10-27 14:22:36 - cptRain.SetValueRange(rR)
2018-10-27 14:22:36 - The value or constructor 'cptRain' is not defined.
2018-10-27 14:22:36 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 14:22:36 - The value, namespace, type or module 'cptRain' is not defined.
2018-10-27 14:22:36 - let cptWetGrassPrior= 
2018-10-27 14:22:36 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 14:22:36 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-27 14:22:36 - let cptWetGrass = 
2018-10-27 14:22:36 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 14:22:36 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-27 14:22:37 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 14:22:37 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 14:22:37 - cptWetGrass.[rS].[rR].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR]))
2018-10-27 14:22:37 - cptWetGrass.SetValueRange(rW)
2018-10-27 14:22:38 - The value or constructor 'cptWetGrass' is not defined.
2018-10-27 14:22:38 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 14:22:38 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 14:22:38 - The value, namespace, type or module 'cptWetGrass' is not defined.
2018-10-27 14:22:38 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 14:22:38 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 14:22:38 - The type 'Variable' is not defined.
2018-10-27 14:22:38 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 14:22:38 - The type 'Range' is not defined.
2018-10-27 14:22:38 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 14:22:38 -    raise
2018-10-27 14:22:38 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 14:22:38 - cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-27 14:22:39 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 14:22:39 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 14:22:39 - #load "Paket.fsx"
2018-10-27 14:22:45 - Paket.Package
2018-10-27 14:22:45 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-27 14:22:45 -       "Microsoft.ML.Probabilistic"
2018-10-27 14:22:45 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-27 14:22:45 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-27 14:22:45 -       "NETStandard.Library"
2018-10-27 14:22:45 -   ]
2018-10-27 14:24:49 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-27 14:24:57 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-27 14:25:52 - //#load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-27 14:25:52 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-27 14:25:52 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-27 14:25:52 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-27 14:25:52 - #r "Microsoft.ML.Probabilistic"
2018-10-27 14:25:52 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-27 14:25:52 - #r "netstandard"
2018-10-27 14:25:53 - open System
2018-10-27 14:25:55 - open Microsoft.ML.Probabilistic  
2018-10-27 14:25:55 - open Microsoft.ML.Probabilistic.Models  
2018-10-27 14:25:55 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-27 14:25:55 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-27 14:25:55 - open Microsoft.ML.Probabilistic.Math
2018-10-27 14:25:56 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-27 14:26:02 - open Microsoft.ML.Probabilistic.FSharp
2018-10-27 14:26:03 - type Parent = VariableArray<int>
2018-10-27 14:26:03 - type Child = VariableArray<int>
2018-10-27 14:26:03 - type ParentCase = Variable<int>
2018-10-27 14:26:03 - type ConditionalProbabilityTable = VariableArray<Vector>
2018-10-27 14:26:03 - let AddChildFromOneParent (parent:Parent) (cpt:ConditionalProbabilityTable) =
2018-10-27 14:26:03 -     let r = parent.Range
2018-10-27 14:26:03 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 14:26:03 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:ParentCase) ->  
2018-10-27 14:26:03 -                        Variable.Discrete(cpt.[pi])))
2018-10-27 14:26:03 -     child
2018-10-27 14:26:03 - type ConditionalProbabilityTable2D = VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-27 14:26:04 - let AddChildFromTwoParents (parent1:Parent) (parent2:Parent) (cpt:ConditionalProbabilityTable2D) = 
2018-10-27 14:26:04 -     let r = parent1.Range
2018-10-27 14:26:04 -     let (child:Child) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 14:26:04 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:ParentCase) ->  
2018-10-27 14:26:04 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:ParentCase) ->  
2018-10-27 14:26:04 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-27 14:26:04 -     child       
2018-10-27 14:26:04 - type RandomVariables =
2018-10-27 14:26:04 -     {cloudy:VariableArray<int>;
2018-10-27 14:26:04 -     sprinkler:VariableArray<int>;
2018-10-27 14:26:04 -     rain:VariableArray<int>;
2018-10-27 14:26:04 -     wetGrass:VariableArray<int> }
2018-10-27 14:26:05 - type ObservedValues =
2018-10-27 14:26:05 -     {cloudy:array<int>;
2018-10-27 14:26:05 -     sprinkler:array<int>;
2018-10-27 14:26:05 -     rain:array<int>;
2018-10-27 14:26:05 -     wetGrass:array<int> }
2018-10-27 14:26:06 - type DistributionParameters =
2018-10-27 14:26:06 -     {cloudy:Variable<Vector> ;
2018-10-27 14:26:06 -     sprinkler:VariableArray<Vector> ;
2018-10-27 14:26:06 -     rain:VariableArray<Vector> ;
2018-10-27 14:26:06 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-27 14:26:07 - type DistributionParameterValues =  
2018-10-27 14:26:07 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-27 14:26:07 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-27 14:26:07 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-27 14:26:07 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-27 14:26:07 -     }
2018-10-27 14:26:08 - type PriorDistributions =
2018-10-27 14:26:08 -     {cloudy:Variable<Dirichlet> ;
2018-10-27 14:26:08 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-27 14:26:08 -     rain:VariableArray<Dirichlet> ;
2018-10-27 14:26:08 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-27 14:26:08 - type PosteriorDistributions =
2018-10-27 14:26:08 -     {cloudy:Dirichlet ;
2018-10-27 14:26:08 -     sprinkler:Dirichlet[] ;
2018-10-27 14:26:08 -     rain:Dirichlet[] ;
2018-10-27 14:26:08 -     wetGrass:Dirichlet[][] }
2018-10-27 14:26:09 - type Ranges = {c:Range;s:Range;r:Range;w:Range}
2018-10-27 14:26:09 - let engine =  InferenceEngine ()
2018-10-27 14:26:10 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 14:26:10 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 14:26:11 - let rC = Range(2).Named("C") // Cloudy
2018-10-27 14:26:11 - let rS = Range(2).Named("S") // Sprinkler
2018-10-27 14:26:11 - let rR = Range(2).Named("R") // Rain
2018-10-27 14:26:11 - let rW = Range(2).Named("W") // Wet
2018-10-27 14:26:11 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-27 14:26:11 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-27 14:26:11 - probCloudy.SetValueRange(rC)
2018-10-27 14:26:12 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-27 14:26:12 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-27 14:26:13 - cptSprinkler.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC]))
2018-10-27 14:26:13 - cptSprinkler.SetValueRange(rS)
2018-10-27 14:26:14 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-27 14:26:14 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-27 14:26:14 - cptRain.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC]))
2018-10-27 14:26:14 - cptRain.SetValueRange(rR)
2018-10-27 14:26:15 - let cptWetGrassPrior= 
2018-10-27 14:26:15 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 14:26:15 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-27 14:26:15 - let cptWetGrass = 
2018-10-27 14:26:15 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 14:26:15 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-27 14:26:15 - cptWetGrass.[rS].[rR].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR]))
2018-10-27 14:26:15 - cptWetGrass.SetValueRange(rW)
2018-10-27 14:26:16 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-27 14:26:16 - let priors:PriorDistributions = {
2018-10-27 14:26:16 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-27 14:26:16 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-27 14:26:16 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-27 14:26:16 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 14:26:16 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-27 14:26:17 - let parameters:DistributionParameters = {
2018-10-27 14:26:17 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-27 14:26:17 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-10-27 14:26:17 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-10-27 14:26:17 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 14:26:17 -                 Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-10-27 14:26:18 - parameters.cloudy.SetValueRange(ranges.c)
2018-10-27 14:26:18 - parameters.sprinkler.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c]))
2018-10-27 14:26:18 - parameters.sprinkler.SetValueRange(ranges.s)
2018-10-27 14:26:18 - parameters.rain.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c]))
2018-10-27 14:26:18 - parameters.rain.SetValueRange(ranges.r)
2018-10-27 14:26:18 - parameters.wetGrass.[ranges.s].[ranges.r].SetTo(Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[ranges.s].[ranges.r]))
2018-10-27 14:26:18 - parameters.wetGrass.SetValueRange(ranges.w)
2018-10-27 14:26:18 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-27 14:26:18 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-27 14:26:18 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-27 14:26:18 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-27 14:26:18 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 14:26:18 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-27 14:26:19 - let priors = buildPriors ranges
2018-10-27 14:26:19 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-27 14:26:19 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-27 14:26:19 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-27 14:26:19 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-27 14:26:19 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 14:26:19 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-27 14:26:19 -     probCloudy.SetValueRange(rg.c)
2018-10-27 14:26:19 -     cptSprinkler.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c]))
2018-10-27 14:26:19 -     cptSprinkler.SetValueRange(rg.s)
2018-10-27 14:26:19 -     cptRain.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c]))
2018-10-27 14:26:19 -     cptRain.SetValueRange(rg.r)
2018-10-27 14:26:19 -     cptWetGrass.[rg.s].[rg.r].SetTo(Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r]))
2018-10-27 14:26:19 -     cptWetGrass.SetValueRange(rg.w)
2018-10-27 14:26:19 -     {cloudy = probCloudy; sprinkler =cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-27 14:26:20 - let parameters = buildDistributionParameters ranges priors
2018-10-27 14:26:20 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 14:26:20 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 14:26:21 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 14:26:21 - cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-27 14:26:21 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("sprinkler")
2018-10-27 14:26:21 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("rain")
2018-10-27 14:26:21 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("wetGrass")
2018-10-27 14:26:22 - let rvs:RandomVariables =
2018-10-27 14:26:22 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 14:26:22 -     vC.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-27 14:26:22 -     let vS = (AddChildFromOneParent vC cptSprinkler).Named("sprinkler")
2018-10-27 14:26:22 -     let vR = (AddChildFromOneParent vC cptRain).Named("rain")
2018-10-27 14:26:22 -     let vW = (AddChildFromTwoParents vS vR cptWetGrass).Named("wetGrass")
2018-10-27 14:26:22 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-27 14:26:22 - let rN=1
2018-10-27 14:26:23 - let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-27 14:26:23 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 14:26:23 -     vC.[rN].SetTo(Variable.Discrete(dp.cloudy).ForEach(rN))
2018-10-27 14:26:23 -     let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-27 14:26:23 -     let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-27 14:26:23 -     let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-27 14:26:23 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-27 14:26:23 - let numberOfExamples = Variable.New<int>().Named("NofE")
2018-10-27 14:26:23 - let rN = Range(numberOfExamples).Named("N")
2018-10-27 14:26:23 - let ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("W")}
2018-10-27 14:26:23 - let priors = buildPriors ranges
2018-10-27 14:26:23 - let parameters = buildDistributionParameters ranges priors
2018-10-27 14:26:24 - let rvs = buildRandomVariables rN parameters
2018-10-27 14:26:24 - let a:array<int> = [|3|]
2018-10-27 14:26:24 - let b:int[] =  [|3|]
2018-10-27 14:26:24 - let c:int[] = a
2018-10-27 14:26:24 - let d:Vector[][] = [|[|Vector.FromArray(2.,3.)|]|]
2018-10-27 14:26:24 - let e:array<array<Vector>> = [|[|Vector.FromArray(2.,3.)|]|]
2018-10-27 14:26:24 - let f:array<array<Vector>> = d
2018-10-27 14:26:24 - let learnParameters (numberOfExamples:Variable<int>)
2018-10-27 14:26:24 -                     (rvs:RandomVariables)
2018-10-27 14:26:24 -                     (prs:PriorDistributions)
2018-10-27 14:26:24 -                     (obs:ObservedValues)
2018-10-27 14:26:24 -                     (obsPriors:PriorDistributions) =
2018-10-27 14:26:24 -     numberOfExamples.ObservedValue <- rvs.cloudy.Length
2018-10-27 14:26:24 -     
2018-10-27 14:26:24 -     rvs.cloudy.ObservedValue <- obs.cloudy
2018-10-27 14:26:24 -     rvs.sprinkler.ObservedValue <- obs.sprinkler
2018-10-27 14:26:24 -     rvs.rain.ObservedValue <- obs.rain
2018-10-27 14:26:24 -     rvs.wetGrass.ObservedValue <- obs.wetGrass
2018-10-27 14:26:24 -     
2018-10-27 14:26:24 -     probCloudyPrior.ObservedValue <- probCloudyPriorObs
2018-10-27 14:26:24 -     cptSprinklerPrior.ObservedValue <- cptSprinklerPriorObs
2018-10-27 14:26:24 -     cptRainPrior.ObservedValue <- cptRainPriorObs
2018-10-27 14:26:24 -     cptWetGrassPrior.ObservedValue <- cptWetGrassPriorObs
2018-10-27 14:26:24 -     // Inference 
2018-10-27 14:26:24 -     {probCloudyPosterior=engine.Infer<Dirichlet>(probCloudy);  
2018-10-27 14:26:24 -         cptSprinklerPosterior=engine.Infer<Dirichlet[]>(cptSprinkler);  
2018-10-27 14:26:24 -         cptRainPosterior=engine.Infer<Dirichlet[]>(cptRain);  
2018-10-27 14:26:24 -         cptWetGrassPosterior=engine.Infer<Dirichlet[][]>(cptWetGrass)}
2018-10-27 14:26:25 - The field, constructor or member 'Length' is not defined.
2018-10-27 14:26:25 - The value or constructor 'probCloudyPriorObs' is not defined. Maybe you want one of the following:
2018-10-27 14:26:25 -    probCloudyPrior
2018-10-27 14:26:25 -    probCloudy
2018-10-27 14:26:25 - The value or constructor 'cptSprinklerPriorObs' is not defined. Maybe you want one of the following:
2018-10-27 14:26:25 -    cptSprinklerPrior
2018-10-27 14:26:25 -    cptSprinkler
2018-10-27 14:26:25 - The value or constructor 'cptRainPriorObs' is not defined. Maybe you want one of the following:
2018-10-27 14:26:25 -    cptRainPrior
2018-10-27 14:26:25 -    cptRain
2018-10-27 14:26:25 - The value or constructor 'cptWetGrassPriorObs' is not defined. Maybe you want one of the following:
2018-10-27 14:26:25 -    cptWetGrassPrior
2018-10-27 14:26:25 -    cptWetGrass
2018-10-27 14:26:25 - The record label 'probCloudyPosterior' is not defined.
2018-10-27 14:26:26 - let probRain (cloudy:Option<int>) (sprinkler:Option<int>) = 
2018-10-27 14:26:26 -     match cloudy with 
2018-10-27 14:26:26 -     | Some cloudy -> printfn "the valid value is %A" cloudy
2018-10-27 14:26:26 -     | None -> printfn "the value is None" 
2018-10-27 14:26:26 -     ()
2018-10-27 14:26:26 - probRain (Some 3) None
2018-10-27 14:26:27 - NumberOfExamples.ObservedValue = 1;
2018-10-27 14:26:27 - The value, namespace, type or module 'NumberOfExamples' is not defined. Maybe you want one of the following:
2018-10-27 14:26:27 -    numberOfExamples
2018-10-27 14:26:27 - if (cloudy.HasValue)
2018-10-27 14:26:27 -             {
2018-10-27 14:26:27 -                 Cloudy.ObservedValue = new int[] { cloudy.Value };
2018-10-27 14:26:27 -             }
2018-10-27 14:26:27 -             else
2018-10-27 14:26:27 -             {
2018-10-27 14:26:27 -                 Cloudy.ClearObservedValue();
2018-10-27 14:26:27 -             }
2018-10-27 14:26:27 -             if (sprinkler.HasValue)
2018-10-27 14:26:27 -             {
2018-10-27 14:26:27 -                 Sprinkler.ObservedValue = new int[] { sprinkler.Value };
2018-10-27 14:26:27 -             }
2018-10-27 14:26:27 -             else
2018-10-27 14:26:27 -             {
2018-10-27 14:26:27 -                 Sprinkler.ClearObservedValue();
2018-10-27 14:26:27 -             }
2018-10-27 14:26:27 -             if (wet.HasValue)
2018-10-27 14:26:27 -             {
2018-10-27 14:26:27 -                 WetGrass.ObservedValue = new int[] { wet.Value };
2018-10-27 14:26:27 -             }
2018-10-27 14:26:27 -             else
2018-10-27 14:26:27 -             {
2018-10-27 14:26:27 -                 WetGrass.ClearObservedValue();
2018-10-27 14:26:27 -             }
2018-10-27 14:26:27 -             Rain.ClearObservedValue();
2018-10-27 14:26:27 -             ProbCloudyPrior.ObservedValue = probCloudyPrior;
2018-10-27 14:26:27 -             CPTSprinklerPrior.ObservedValue = cptSprinklerPrior;
2018-10-27 14:26:27 -             CPTRainPrior.ObservedValue = cptRainPrior;
2018-10-27 14:26:27 -             CPTWetGrassPrior.ObservedValue = cptWetGrassPrior;
2018-10-27 14:26:27 -             // Inference
2018-10-27 14:26:27 -             var rainPosterior = Engine.Infer<Discrete[]>(Rain);
2018-10-27 14:26:27 -             // In this example, index 0 is true and index 1 is false
2018-10-27 14:26:27 -             return rainPosterior[0].GetProbs()[0];
2018-10-27 14:26:27 -         }
2018-10-27 14:26:29 - This construct is deprecated: The use of the type syntax 'int C' and 'C  <int>' is not permitted here. Consider adjusting this type to be written in the form 'C<int>'
2018-10-27 14:26:29 - Unexpected keyword 'else' in expression
2018-10-27 14:26:29 - Incomplete conditional. Expected 'if <expr> then <expr>' or 'if <expr> then <expr> else <expr>'.
2018-10-27 14:26:29 - Incomplete structured construct at or before this point in expression
2018-10-27 14:26:29 - Incomplete conditional. Expected 'if <expr> then <expr>' or 'if <expr> then <expr> else <expr>'.
2018-10-27 14:26:29 - This construct is deprecated: The use of the type syntax 'int C' and 'C  <int>' is not permitted here. Consider adjusting this type to be written in the form 'C<int>'
2018-10-27 14:26:29 - Incomplete structured construct at or before this point in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2018-10-27 14:26:29 - parse error
2018-10-27 14:26:29 - let sample numData:int probCloudy:Vector[] cptSprinkler 
2018-10-27 14:26:29 - Syntax error in labelled type argument
2018-10-27 14:26:29 - let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-27 14:26:29 - let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-27 14:26:29 - let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-27 14:26:30 - let cptWetGrass:Vector[][] = 
2018-10-27 14:26:30 -     [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-27 14:26:30 -             [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-27 14:26:30 -         [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-27 14:26:30 -             [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-27 14:26:30 -     |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-27 14:26:31 - let distributionParameterValues:DistributionParameterValues = {
2018-10-27 14:26:31 -     cloudy= probCloudy
2018-10-27 14:26:31 -     sprinkler= cptSprinkler
2018-10-27 14:26:31 -     rain = cptRain
2018-10-27 14:26:31 -     wetGrass =  cptWetGrass 
2018-10-27 14:26:31 - }
2018-10-27 14:26:32 - let setDistributionParameterValues ():DistributionParameterValues =
2018-10-27 14:26:32 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-27 14:26:32 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-27 14:26:32 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-27 14:26:32 -     let cptWetGrass:Vector[][] = 
2018-10-27 14:26:32 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-27 14:26:32 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-27 14:26:32 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-27 14:26:32 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-27 14:26:32 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-27 14:26:32 -     {cloudy= probCloudy;
2018-10-27 14:26:32 -         sprinkler= cptSprinkler;
2018-10-27 14:26:32 -         rain = cptRain;
2018-10-27 14:26:32 -         wetGrass =  cptWetGrass }
2018-10-27 14:26:32 - setDistributionParameterValues()
2018-10-27 14:26:33 - let probRainGivenWetGrass = model.ProbRain(null, null, 0, probCloudy, cptSprinkler, cptRain, cptWetGrass);
2018-10-27 14:26:33 - let probRainGivenWetGrassNotCloudy = model.ProbRain(1, null, 0, probCloudy, cptSprinkler, cptRain, cptWetGrass);
2018-10-27 14:26:33 - printf "P(rain | grass is wet)              = %A" probRainGivenWetGrass
2018-10-27 14:26:33 - printf "P(rain | grass is wet, not cloudy ) = %A" probRainGivenWetGrassNotCloudy
2018-10-27 14:26:33 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-27 14:26:33 -    Model
2018-10-27 14:26:33 -    Models
2018-10-27 14:26:33 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-27 14:26:33 -    Model
2018-10-27 14:26:33 -    Models
2018-10-27 14:26:34 - let sample = WetGlassSprinklerRainModel.Sample(1000, probCloudy, cptSprinkler, cptRain, cptWetGrass)
2018-10-27 14:26:34 - The value, namespace, type or module 'WetGlassSprinklerRainModel' is not defined.
2018-10-27 14:26:34 - model.LearnParameters(sample[0], sample[1], sample[2], sample[3])
2018-10-27 14:26:35 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-27 14:26:35 -    Model
2018-10-27 14:26:35 -    Models
2018-10-27 14:26:35 - printf "Prob. Cloudy:                              Ground truth: %A, Inferred: %A", 0.5, model.ProbCloudyPosterior.GetMean()[0]
2018-10-27 14:26:35 - printf "Prob. Sprinkler | Cloudy:                  Ground truth: %A, Inferred: %A", 0.1, model.CPTSprinklerPosterior[0].GetMean()[0]
2018-10-27 14:26:35 - printf "Prob. Sprinkler | Not Cloudy:              Ground truth: %A, Inferred: %A", 0.5, model.CPTSprinklerPosterior[1].GetMean()[0]
2018-10-27 14:26:35 - printf "Prob. Rain      | Cloudy:                  Ground truth: %A, Inferred: %A", 0.8, model.CPTRainPosterior[0].GetMean()[0]
2018-10-27 14:26:35 - printf "Prob. Rain      | Not Cloudy:              Ground truth: %A, Inferred: %A", 0.2, model.CPTRainPosterior[1].GetMean()[0]
2018-10-27 14:26:35 - printf "Prob. Wet Grass | Sprinkler, Rain:         Ground truth: %A, Inferred: %A", 0.99, model.CPTWetGrassPosterior[0][0].GetMean()[0]
2018-10-27 14:26:35 - printf "Prob. Wet Grass | Sprinkler, Not Rain      Ground truth: %A, Inferred: %A", 0.9, model.CPTWetGrassPosterior[0][1].GetMean()[0]
2018-10-27 14:26:35 - printf "Prob. Wet Grass | Not Sprinkler, Rain:     Ground truth: %A, Inferred: %A", 0.9, model.CPTWetGrassPosterior[1][0].GetMean()[0]
2018-10-27 14:26:35 - printf "Prob. Wet Grass | Not Sprinkler, Not Rain: Ground truth: %A, Inferred: %A", 0.0, model.CPTWetGrassPosterior[1][1].GetMean()[0]
2018-10-27 14:26:36 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-27 14:26:36 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-27 14:26:36 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-27 14:26:36 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-27 14:26:36 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-27 14:26:36 -    Model
2018-10-27 14:26:36 -    Models
2018-10-27 14:26:36 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-27 14:26:36 -    Model
2018-10-27 14:26:36 -    Models
2018-10-27 14:26:36 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-27 14:26:36 -    Model
2018-10-27 14:26:36 -    Models
2018-10-27 14:26:36 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-27 14:26:36 -    Model
2018-10-27 14:26:36 -    Models
2018-10-27 14:26:36 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-27 14:26:36 -    Model
2018-10-27 14:26:36 -    Models
2018-10-27 14:26:36 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-27 14:26:36 -    Model
2018-10-27 14:26:36 -    Models
2018-10-27 14:26:36 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-27 14:26:36 -    Model
2018-10-27 14:26:36 -    Models
2018-10-27 14:26:36 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-27 14:26:36 -    Model
2018-10-27 14:26:36 -    Models
2018-10-27 14:26:36 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-27 14:26:36 -    Model
2018-10-27 14:26:36 -    Models
2018-10-27 14:26:36 - // Use posteriors we have just learnt
2018-10-27 14:26:36 - let probRainGivenWetGrass1 = model.ProbRain(null, null, 0, model.ProbCloudyPosterior, model.CPTSprinklerPosterior, model.CPTRainPosterior, model.CPTWetGrassPosterior)
2018-10-27 14:26:36 - let probRainGivenWetGrassNotCloudy1 = model.ProbRain(1, null, 0, model.ProbCloudyPosterior, model.CPTSprinklerPosterior, model.CPTRainPosterior, model.CPTWetGrassPosterior)
2018-10-27 14:26:37 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-27 14:26:37 -    Model
2018-10-27 14:26:37 -    Models
2018-10-27 14:26:37 - The value, namespace, type or module 'model' is not defined. Maybe you want one of the following:
2018-10-27 14:26:37 -    Model
2018-10-27 14:26:37 -    Models
2018-10-27 14:26:37 - probRainGivenWetGrass1
2018-10-27 14:26:38 - The value or constructor 'probRainGivenWetGrass1' is not defined. Maybe you want one of the following:
2018-10-27 14:26:38 -    probRain
2018-10-27 14:26:38 - probRainGivenWetGrassNotCloudy1
2018-10-27 14:26:39 - The value or constructor 'probRainGivenWetGrassNotCloudy1' is not defined.
2018-10-27 14:26:39 - //using the Foreach Block  
2018-10-27 14:26:39 - let pixel = Range(10)  
2018-10-27 14:26:39 - let bools = Variable.Array<bool>(pixel)
2018-10-27 14:26:39 - Variable.ForeachBlock pixel ( fun pixel -> bools.[pixel] <- Variable.Bernoulli(0.7) ||| Variable.Bernoulli(0.4))
2018-10-27 14:26:39 - //using the Switch Block - to model a 2 component (scalar) Gaussian mixture
2018-10-27 14:26:39 - let mixtureSize = 2  
2018-10-27 14:26:39 - let k2 = Range(mixtureSize)  
2018-10-27 14:26:39 - let c:Variable<int> = Variable.Discrete(k2, [|0.5;0.5|])  // c is a discrete random variable with values {0,1}
2018-10-27 14:26:39 - let means2:VariableArray<float> = Variable.Observed( [|1.0;2.0|], k2)  // Constant means for each Gaussian
2018-10-27 14:26:39 - let x:Variable<float> = Variable.New<double>()  // x is a univariate Gaussian
2018-10-27 14:26:40 - Variable.SwitchBlock c (fun _ -> 
2018-10-27 14:26:40 -     let _ = x.SetTo(Variable.GaussianFromMeanAndVariance(means2.[c], 1.0))  
2018-10-27 14:26:40 -     ()  
2018-10-27 14:26:40 - )
2018-10-27 14:26:41 - //using the SwitchExpr Block - to model 100 outcomes of a 2-component mixture Wishart distributed variable
2018-10-27 14:26:41 - let k =  Range(2).Named("k")
2018-10-27 14:26:41 - // Loop over mixture components - parameters are constant, so don't vary based on prior distribution, yet
2018-10-27 14:26:41 - let means:VariableArray<Vector> = 
2018-10-27 14:26:41 -     Variable.ArrayInit k (fun k ->  
2018-10-27 14:26:41 -         Variable.VectorGaussianFromMeanAndPrecision( Vector.Constant(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-10-27 14:26:42 - let precs:VariableArray<PositiveDefiniteMatrix> =  
2018-10-27 14:26:42 -     Variable.ArrayInit k (fun k -> 
2018-10-27 14:26:42 -         Variable.WishartFromShapeAndScale(1.0,  
2018-10-27 14:26:42 -             PositiveDefiniteMatrix.Identity(2)))  
2018-10-27 14:26:42 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-10-27 14:26:43 - let n = Range(100).Named("n")
2018-10-27 14:26:43 - let z:VariableArray<int> = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-27 14:26:43 - let data = Variable.ArrayInit n (fun (i:Range)->  
2018-10-27 14:26:43 -                Variable.SwitchExpr (z.[i]) (fun (zi:Variable<int>) ->  
2018-10-27 14:26:43 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-27 14:26:44 - // Data from a clinical trial  
2018-10-27 14:26:44 - let controlGroup = Variable.Observed<bool>([|false; false; true; false; false|])  
2018-10-27 14:26:44 - let treatedGroup = Variable.Observed<bool>([|true; false; true; true; true |])  
2018-10-27 14:26:44 - let i = controlGroup.Range  
2018-10-27 14:26:44 - let j = treatedGroup.Range  
2018-10-27 14:26:44 - // Prior on being an effective treatment  
2018-10-27 14:26:44 - let isEffective = Variable.Bernoulli(0.5).Named("isEffective");  
2018-10-27 14:26:44 - let probIfTreated = ref (Variable.New<float>())  
2018-10-27 14:26:44 - let probIfControl = ref (Variable.New<float>())
2018-10-27 14:26:44 - // If Block function  
2018-10-27 14:26:44 - let f1 (vb1: Variable<bool>) =  
2018-10-27 14:26:44 -     probIfControl := Variable.Beta(1.0, 1.0).Named("probIfControl")  
2018-10-27 14:26:44 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->
2018-10-27 14:26:44 -         Variable.Bernoulli(!probIfControl)) 
2018-10-27 14:26:44 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->
2018-10-27 14:26:44 -         Variable.Bernoulli(!probIfTreated))  
2018-10-27 14:26:44 -     ()  
2018-10-27 14:26:45 - // IfNot Block function  
2018-10-27 14:26:45 - let f2 (vb2: Variable<bool>) =  
2018-10-27 14:26:45 -     let probAll = Variable.Beta(1.0, 1.0).Named("probAll")  
2018-10-27 14:26:45 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->Variable.Bernoulli(probAll))  
2018-10-27 14:26:45 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->Variable.Bernoulli(probAll))  
2018-10-27 14:26:45 -     ()  
2018-10-27 14:26:45 - // Call IfBlock  
2018-10-27 14:26:45 - let _ = Variable.IfBlock isEffective f1 f2
2018-10-27 14:28:52 - type ConditionalVariable = VariableArray<int>
2018-10-27 14:28:52 - type ConditionalVariableCase = Variable<int>
2018-10-27 14:28:52 - type ConditionalProbabilityTable = VariableArray<Vector>
2018-10-27 14:28:55 - let AddChildFromOneParent (parent:ConditionalVariable) (cpt:ConditionalProbabilityTable) =
2018-10-27 14:28:55 -     let r = parent.Range
2018-10-27 14:28:55 -     let (child:ConditionalVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 14:28:55 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:ConditionalVariableCase) ->  
2018-10-27 14:28:55 -                        Variable.Discrete(cpt.[pi])))
2018-10-27 14:28:55 -     child
2018-10-27 14:29:34 - type ConditionalVariable = VariableArray<int>
2018-10-27 14:29:34 - type ConditionalVariableCase = Variable<int>
2018-10-27 14:29:34 - type ConditionalProbabilityTable = VariableArray<Vector>
2018-10-27 14:29:35 - let AddChildFromOneParent (parent:ConditionalVariable) (cpt:ConditionalProbabilityTable) =
2018-10-27 14:29:35 -     let r = parent.Range
2018-10-27 14:29:35 -     let (child:ConditionalVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 14:29:35 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:ConditionalVariableCase) ->  
2018-10-27 14:29:35 -                        Variable.Discrete(cpt.[pi])))
2018-10-27 14:29:35 -     child
2018-10-27 14:29:39 - type ConditionalProbabilityTable2D = VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-27 14:29:56 - let AddChildFromTwoParents 
2018-10-27 14:29:56 -         (parent1:ConditionalVariable) (parent2:ConditionalVariable) (cpt:ConditionalProbabilityTable2D) = 
2018-10-27 14:29:56 -     let r = parent1.Range
2018-10-27 14:29:56 -     let (child:ConditionalVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 14:29:56 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:ConditionalVariableCase) ->  
2018-10-27 14:29:56 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:ConditionalVariableCase) ->  
2018-10-27 14:29:56 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-27 14:29:56 -     child       
2018-10-27 14:30:07 - let AddChildFromTwoParents 
2018-10-27 14:30:07 -         (parent1:ConditionalVariable) 
2018-10-27 14:30:07 -         (parent2:ConditionalVariable) 
2018-10-27 14:30:07 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-27 14:30:07 -     let r = parent1.Range
2018-10-27 14:30:07 -     let (child:ConditionalVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 14:30:07 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:ConditionalVariableCase) ->  
2018-10-27 14:30:07 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:ConditionalVariableCase) ->  
2018-10-27 14:30:07 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-27 14:30:07 -     child       
2018-10-27 14:30:31 - let AddChildFromOneParent 
2018-10-27 14:30:31 -         (parent:ConditionalVariable) 
2018-10-27 14:30:31 -         (cpt:ConditionalProbabilityTable) =
2018-10-27 14:30:31 -     let r = parent.Range
2018-10-27 14:30:31 -     let (child:ConditionalVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 14:30:31 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:ConditionalVariableCase) ->  
2018-10-27 14:30:31 -                        Variable.Discrete(cpt.[pi])))
2018-10-27 14:30:31 -     child
2018-10-27 15:18:26 - let AddChildFromOneParent 
2018-10-27 15:18:26 -         (parent:RandomVariable) 
2018-10-27 15:18:26 -         (cpt:ConditionalProbabilityTable) =
2018-10-27 15:18:26 -     let r = parent.Range
2018-10-27 15:18:26 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 15:18:26 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-27 15:18:26 -                        Variable.Discrete(cpt.[pi])))
2018-10-27 15:18:26 -     child
2018-10-27 15:18:29 - The type 'RandomVariable' is not defined. Maybe you want one of the following:
2018-10-27 15:18:29 -    RandomVariables
2018-10-27 15:18:29 -    Random
2018-10-27 15:18:29 -    Rand
2018-10-27 15:18:29 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-27 15:18:29 - The type 'RandomVariable' is not defined. Maybe you want one of the following:
2018-10-27 15:18:29 -    RandomVariables
2018-10-27 15:18:29 -    Random
2018-10-27 15:18:29 -    Rand
2018-10-27 15:18:29 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 15:18:29 - The type 'RandomVariableCase' is not defined. Maybe you want one of the following:
2018-10-27 15:18:29 -    RandomVariables
2018-10-27 15:18:29 -    Random
2018-10-27 15:18:35 - type RandomVariable = VariableArray<int> // Random variable for C,S,R,W
2018-10-27 15:18:35 - type RandomVariableCase = Variable<int>
2018-10-27 15:18:38 - let AddChildFromOneParent 
2018-10-27 15:18:38 -         (parent:RandomVariable) 
2018-10-27 15:18:38 -         (cpt:ConditionalProbabilityTable) =
2018-10-27 15:18:38 -     let r = parent.Range
2018-10-27 15:18:38 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 15:18:38 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-27 15:18:38 -                        Variable.Discrete(cpt.[pi])))
2018-10-27 15:18:38 -     child
2018-10-27 15:19:11 - let AddChildFromTwoParents 
2018-10-27 15:19:11 -         (parent1:RandomVariable) 
2018-10-27 15:19:11 -         (parent2:RandomVariable) 
2018-10-27 15:19:11 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-27 15:19:11 -     let r = parent1.Range
2018-10-27 15:19:11 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 15:19:11 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-27 15:19:11 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-27 15:19:11 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-27 15:19:11 -     child       
2018-10-27 15:36:39 - type RandomVariable = VariableArray<int> // Random variable for C,S,R,W
2018-10-27 15:36:39 - type RandomVariableCase = Variable<int> // Could be for single experiment or outcome of driving variable
2018-10-27 18:47:26 - Reporting 0 opened comms
2018-10-27 18:47:26 - type RandomVariable = VariableArray<int> // Random variable for C,S,R,W
2018-10-27 18:47:26 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-10-27 18:47:27 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-10-27 18:47:27 - let AddChildFromOneParent 
2018-10-27 18:47:27 -         (parent:RandomVariable) 
2018-10-27 18:47:27 -         (cpt:ConditionalProbabilityTable) =
2018-10-27 18:47:27 -     let r = parent.Range
2018-10-27 18:47:27 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 18:47:27 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-27 18:47:27 -                        Variable.Discrete(cpt.[pi])))
2018-10-27 18:47:27 -     child
2018-10-27 18:47:28 - type ConditionalProbabilityTable2D = 
2018-10-27 18:47:28 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-27 18:47:28 - let AddChildFromTwoParents 
2018-10-27 18:47:28 -         (parent1:RandomVariable) 
2018-10-27 18:47:28 -         (parent2:RandomVariable) 
2018-10-27 18:47:28 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-27 18:47:28 -     let r = parent1.Range
2018-10-27 18:47:28 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 18:47:28 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-27 18:47:28 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-27 18:47:28 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-27 18:47:28 -     child       
2018-10-27 18:47:29 - let engine =  InferenceEngine ()
2018-10-27 18:47:29 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 18:47:29 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 18:47:30 - let rC = Range(2).Named("C") // Cloudy
2018-10-27 18:47:30 - let rS = Range(2).Named("S") // Sprinkler
2018-10-27 18:47:30 - let rR = Range(2).Named("R") // Rain
2018-10-27 18:47:30 - let rW = Range(2).Named("W") // Wet
2018-10-27 18:47:30 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-27 18:47:30 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-27 18:47:30 - probCloudy.SetValueRange(rC)
2018-10-27 18:47:31 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-27 18:47:31 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-27 18:47:31 - cptSprinkler.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC]))
2018-10-27 18:47:31 - cptSprinkler.SetValueRange(rS)
2018-10-27 18:47:32 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-27 18:47:32 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-27 18:47:32 - cptRain.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC]))
2018-10-27 18:47:32 - cptRain.SetValueRange(rR)
2018-10-27 18:47:33 - let cptWetGrassPrior= 
2018-10-27 18:47:33 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 18:47:33 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-27 18:47:33 - let cptWetGrass = 
2018-10-27 18:47:33 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 18:47:33 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-27 18:47:33 - cptWetGrass.[rS].[rR].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR]))
2018-10-27 18:47:33 - cptWetGrass.SetValueRange(rW)
2018-10-27 18:47:34 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 18:47:34 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 18:47:34 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 18:47:34 - cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-27 18:48:22 - shutdown request
2018-10-27 18:48:58 - shutdown request
2018-10-27 18:49:35 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-27 18:49:35 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-27 18:49:35 - For help type #help;;
2018-10-27 18:49:35 - > val it :
2018-10-27 18:49:35 -   ResizeArray<System.Type *
2018-10-27 18:49:35 -               (obj ->
2018-10-27 18:49:35 -                  seq<string *
2018-10-27 18:49:35 -                      string> *
2018-10-27 18:49:35 -                  string)>
2018-10-27 18:49:35 - = seq []
2018-10-27 18:49:35 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-27 18:49:35 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-27 18:49:35 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-27 18:49:36 - type RandomVariable = VariableArray<int> // Random variable for C,S,R,W
2018-10-27 18:49:36 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-10-27 18:49:38 - The type 'VariableArray' is not defined.
2018-10-27 18:49:38 - The type 'VariableArray' is not defined.
2018-10-27 18:49:38 - The type 'Variable' is not defined.
2018-10-27 18:49:38 - The type 'Variable' is not defined.
2018-10-27 18:49:38 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-10-27 18:49:38 - The type 'VariableArray' is not defined.
2018-10-27 18:49:38 - The type 'VariableArray' is not defined.
2018-10-27 18:49:38 - let AddChildFromOneParent 
2018-10-27 18:49:38 -         (parent:RandomVariable) 
2018-10-27 18:49:38 -         (cpt:ConditionalProbabilityTable) =
2018-10-27 18:49:38 -     let r = parent.Range
2018-10-27 18:49:38 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 18:49:38 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-27 18:49:38 -                        Variable.Discrete(cpt.[pi])))
2018-10-27 18:49:38 -     child
2018-10-27 18:49:39 - The type 'RandomVariable' is not defined.
2018-10-27 18:49:39 - The type 'ConditionalProbabilityTable' is not defined.
2018-10-27 18:49:39 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-27 18:49:39 - The type 'RandomVariable' is not defined.
2018-10-27 18:49:39 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 18:49:39 - type ConditionalProbabilityTable2D = 
2018-10-27 18:49:39 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-27 18:49:40 - The type 'VariableArray' is not defined.
2018-10-27 18:49:40 - The type 'VariableArray' is not defined.
2018-10-27 18:49:40 - let AddChildFromTwoParents 
2018-10-27 18:49:40 -         (parent1:RandomVariable) 
2018-10-27 18:49:40 -         (parent2:RandomVariable) 
2018-10-27 18:49:40 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-27 18:49:40 -     let r = parent1.Range
2018-10-27 18:49:40 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 18:49:40 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-27 18:49:40 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-27 18:49:40 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-27 18:49:40 -     child       
2018-10-27 18:49:41 - The type 'RandomVariable' is not defined.
2018-10-27 18:49:41 - The type 'RandomVariable' is not defined.
2018-10-27 18:49:41 - The type 'ConditionalProbabilityTable2D' is not defined.
2018-10-27 18:49:41 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-27 18:49:41 - The type 'RandomVariable' is not defined.
2018-10-27 18:49:41 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 18:49:41 - let engine =  InferenceEngine ()
2018-10-27 18:49:41 - The value or constructor 'InferenceEngine' is not defined.
2018-10-27 18:49:41 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 18:49:41 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 18:49:42 - The type 'Variable' is not defined.
2018-10-27 18:49:42 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 18:49:42 - The type 'Range' is not defined.
2018-10-27 18:49:42 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 18:49:42 -    raise
2018-10-27 18:49:42 - let rC = Range(2).Named("C") // Cloudy
2018-10-27 18:49:42 - let rS = Range(2).Named("S") // Sprinkler
2018-10-27 18:49:42 - let rR = Range(2).Named("R") // Rain
2018-10-27 18:49:42 - let rW = Range(2).Named("W") // Wet
2018-10-27 18:49:42 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 18:49:42 -    raise
2018-10-27 18:49:42 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 18:49:42 -    raise
2018-10-27 18:49:42 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 18:49:42 -    raise
2018-10-27 18:49:42 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 18:49:42 -    raise
2018-10-27 18:49:43 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-27 18:49:43 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-27 18:49:43 - probCloudy.SetValueRange(rC)
2018-10-27 18:49:43 - The type 'Variable' is not defined.
2018-10-27 18:49:43 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 18:49:43 - The type 'Variable' is not defined.
2018-10-27 18:49:43 - The value or constructor 'Variable' is not defined.
2018-10-27 18:49:43 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-27 18:49:44 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-27 18:49:44 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-27 18:49:44 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 18:49:44 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 18:49:44 - cptSprinkler.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC]))
2018-10-27 18:49:44 - cptSprinkler.SetValueRange(rS)
2018-10-27 18:49:45 - The value or constructor 'cptSprinkler' is not defined.
2018-10-27 18:49:45 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 18:49:45 - The value, namespace, type or module 'cptSprinkler' is not defined.
2018-10-27 18:49:45 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-27 18:49:45 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-27 18:49:45 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 18:49:45 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 18:49:46 - cptRain.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC]))
2018-10-27 18:49:46 - cptRain.SetValueRange(rR)
2018-10-27 18:49:46 - The value or constructor 'cptRain' is not defined.
2018-10-27 18:49:46 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 18:49:46 - The value, namespace, type or module 'cptRain' is not defined.
2018-10-27 18:49:46 - let cptWetGrassPrior= 
2018-10-27 18:49:46 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 18:49:46 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-27 18:49:46 - let cptWetGrass = 
2018-10-27 18:49:46 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 18:49:46 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-27 18:49:47 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 18:49:47 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 18:49:47 - cptWetGrass.[rS].[rR].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR]))
2018-10-27 18:49:47 - cptWetGrass.SetValueRange(rW)
2018-10-27 18:49:47 - The value or constructor 'cptWetGrass' is not defined.
2018-10-27 18:49:47 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 18:49:47 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 18:49:47 - The value, namespace, type or module 'cptWetGrass' is not defined.
2018-10-27 18:49:47 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 18:49:47 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 18:49:48 - The type 'Variable' is not defined.
2018-10-27 18:49:48 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 18:49:48 - The type 'Range' is not defined.
2018-10-27 18:49:48 - The value or constructor 'Range' is not defined. Maybe you want one of the following:
2018-10-27 18:49:48 -    raise
2018-10-27 18:49:48 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 18:49:48 - cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-27 18:49:48 - The value, namespace, type or module 'Variable' is not defined.
2018-10-27 18:49:48 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 18:50:05 - shutdown request
2018-10-27 18:50:38 - shutdown request
2018-10-27 18:50:58 - shutdown request
2018-10-27 18:51:30 - shutdown request
2018-10-27 18:52:07 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-27 18:52:07 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-27 18:52:07 - For help type #help;;
2018-10-27 18:52:07 - > val it :
2018-10-27 18:52:07 -   ResizeArray<System.Type *
2018-10-27 18:52:07 -               (obj ->
2018-10-27 18:52:07 -                  seq<string *
2018-10-27 18:52:07 -                      string> *
2018-10-27 18:52:07 -                  string)>
2018-10-27 18:52:07 - = seq []
2018-10-27 18:52:07 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-27 18:52:07 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-27 18:52:07 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-27 18:52:08 - #load "Paket.fsx"
2018-10-27 18:52:50 - Paket.Package
2018-10-27 18:52:50 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-27 18:52:50 -       "Microsoft.ML.Probabilistic"
2018-10-27 18:52:50 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-27 18:52:50 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-27 18:52:50 -       "NETStandard.Library"
2018-10-27 18:52:50 -   ]
2018-10-27 18:54:15 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-27 18:54:23 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-27 18:55:26 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-27 18:55:26 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-27 18:55:26 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-27 18:55:26 - #r "Microsoft.ML.Probabilistic"
2018-10-27 18:55:26 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-27 18:55:26 - #r "netstandard"
2018-10-27 18:55:28 - open System
2018-10-27 18:55:29 - open Microsoft.ML.Probabilistic  
2018-10-27 18:55:29 - open Microsoft.ML.Probabilistic.Models  
2018-10-27 18:55:29 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-27 18:55:29 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-27 18:55:29 - open Microsoft.ML.Probabilistic.Math
2018-10-27 18:55:30 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-27 18:55:39 - open Microsoft.ML.Probabilistic.FSharp
2018-10-27 18:55:39 - type RandomVariable = VariableArray<int> // Random variable for C,S,R,W
2018-10-27 18:55:39 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-10-27 18:55:39 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-10-27 18:55:40 - let AddChildFromOneParent 
2018-10-27 18:55:40 -         (parent:RandomVariable) 
2018-10-27 18:55:40 -         (cpt:ConditionalProbabilityTable) =
2018-10-27 18:55:40 -     let r = parent.Range
2018-10-27 18:55:40 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 18:55:40 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-27 18:55:40 -                        Variable.Discrete(cpt.[pi])))
2018-10-27 18:55:40 -     child
2018-10-27 18:55:40 - type ConditionalProbabilityTable2D = 
2018-10-27 18:55:40 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-27 18:55:41 - let AddChildFromTwoParents 
2018-10-27 18:55:41 -         (parent1:RandomVariable) 
2018-10-27 18:55:41 -         (parent2:RandomVariable) 
2018-10-27 18:55:41 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-27 18:55:41 -     let r = parent1.Range
2018-10-27 18:55:41 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-27 18:55:41 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-27 18:55:41 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-27 18:55:41 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-27 18:55:41 -     child       
2018-10-27 18:55:42 - let engine =  InferenceEngine ()
2018-10-27 18:55:43 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 18:55:43 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 18:55:43 - let rC = Range(2).Named("C") // Cloudy
2018-10-27 18:55:43 - let rS = Range(2).Named("S") // Sprinkler
2018-10-27 18:55:43 - let rR = Range(2).Named("R") // Rain
2018-10-27 18:55:43 - let rW = Range(2).Named("W") // Wet
2018-10-27 18:55:44 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-27 18:55:44 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-27 18:55:44 - probCloudy.SetValueRange(rC)
2018-10-27 18:55:45 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-27 18:55:45 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-27 18:55:45 - cptSprinkler.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC]))
2018-10-27 18:55:45 - cptSprinkler.SetValueRange(rS)
2018-10-27 18:55:46 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-27 18:55:46 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-27 18:55:47 - cptRain.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC]))
2018-10-27 18:55:47 - cptRain.SetValueRange(rR)
2018-10-27 18:55:47 - let cptWetGrassPrior= 
2018-10-27 18:55:47 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 18:55:47 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-27 18:55:47 - let cptWetGrass = 
2018-10-27 18:55:47 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 18:55:47 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-27 18:55:48 - cptWetGrass.[rS].[rR].SetTo(Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR]))
2018-10-27 18:55:48 - cptWetGrass.SetValueRange(rW)
2018-10-27 18:55:49 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 18:55:49 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 18:55:49 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 18:55:49 - cloudy.[rN].SetTo(Variable.Discrete(probCloudy).ForEach(rN))
2018-10-27 19:23:40 - let sizes:array<int> = [| 2; 3 |]  
2018-10-27 19:23:40 - let item:Range = Range(sizes.Length).Named("item")
2018-10-27 19:23:40 - let sizesVar:VariableArray<int> = Variable.Constant(sizes, item).Named("sizes");  
2018-10-27 19:23:40 - let feature:Range =  Range(sizesVar.[item]).Named("feature");  
2018-10-27 19:23:40 - let x:VariableArray<VariableArray<double>,double[][]>
2018-10-27 19:23:40 -         = Variable.Array(Variable.Array<double>(feature), item).Named("x");
2018-10-27 19:23:41 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(array: VariableArray<'T>, r: Range) : VariableArray<VariableArray<'T>,'T [] []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(array: VariableArray<'TItem,'TArray>, r: Range) : VariableArray<VariableArray<'TItem,'TArray>,'TArray []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(itemPrototype: 'TItem, r: Range) : VariableArray<'TItem,'TArray>
2018-10-27 19:24:53 - let sizes:array<int> = [| 2; 3 |]  
2018-10-27 19:24:53 - let item:Range = Range(sizes.Length).Named("item")
2018-10-27 19:24:53 - let sizesVar:VariableArray<int> = Variable.Constant(sizes, item).Named("sizes")  
2018-10-27 19:24:53 - let feature:Range =  Range(sizesVar.[item]).Named("feature")  
2018-10-27 19:24:53 - let x:VariableArray<VariableArray<float>,float[][]>
2018-10-27 19:24:53 -         = Variable.Array(Variable.Array<float>(feature), item).Named("x");
2018-10-27 19:24:54 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(array: VariableArray<'T>, r: Range) : VariableArray<VariableArray<'T>,'T [] []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(array: VariableArray<'TItem,'TArray>, r: Range) : VariableArray<VariableArray<'TItem,'TArray>,'TArray []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(itemPrototype: 'TItem, r: Range) : VariableArray<'TItem,'TArray>
2018-10-27 19:25:27 - let sizes:array<int> = [| 2; 3 |]  
2018-10-27 19:25:27 - let item:Range = Range(sizes.Length).Named("item")
2018-10-27 19:25:27 - let sizesVar:VariableArray<int> = Variable.Constant(sizes, item).Named("sizes")  
2018-10-27 19:25:27 - let feature:Range =  Range(sizesVar.[item]).Named("feature")  
2018-10-27 19:25:54 - let x:VariableArray<VariableArray<float>,float[][]>
2018-10-27 19:25:54 -         = Variable.Array(Variable.Array<float>(feature), item).Named("x");
2018-10-27 19:25:54 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(array: VariableArray<'T>, r: Range) : VariableArray<VariableArray<'T>,'T [] []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(array: VariableArray<'TItem,'TArray>, r: Range) : VariableArray<VariableArray<'TItem,'TArray>,'TArray []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(itemPrototype: 'TItem, r: Range) : VariableArray<'TItem,'TArray>
2018-10-27 19:51:21 - let x:VariableArray<VariableArray<float>,float[][]>
2018-10-27 19:51:21 -         = Variable.Array<VariableArray<float>,float[][]>(Variable.Array<float>(feature), item).Named("x");
2018-10-27 19:58:38 - let xPrior:Gaussian = Gaussian(1.2, 3.4) 
2018-10-27 19:58:38 - x.[item].[feature] = Variable.Random(xPrior).ForEach(item, feature)  
2018-10-27 19:58:38 - Variable.ConstrainPositive(x.[item].[feature])
2018-10-27 19:59:41 - parameters.sprinkler.[ranges.c]=Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c])
2018-10-27 19:59:43 - The value, namespace, type or module 'parameters' is not defined.
2018-10-27 19:59:43 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 19:59:43 - The value, namespace, type or module 'priors' is not defined. Maybe you want one of the following:
2018-10-27 19:59:43 -    xPrior
2018-10-27 19:59:43 -    Printers
2018-10-27 19:59:43 -    Progress
2018-10-27 19:59:43 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 19:59:43 - A unique overload for method 'Random' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Random<'T>(dist: IDistribution<'T>) : Variable<'T>, Variable.Random<'TDist when 'TDist :> IDistribution<Vector>>(dist: Variable<'TDist>) : Variable<Vector>
2018-10-27 19:59:56 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-27 19:59:58 - The type 'Ranges' is not defined. Maybe you want one of the following:
2018-10-27 19:59:58 -    Range
2018-10-27 19:59:58 - The record label 'c' is not defined.
2018-10-27 19:59:59 - let priors:PriorDistributions = {
2018-10-27 19:59:59 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-27 19:59:59 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-27 19:59:59 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-27 19:59:59 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 19:59:59 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-27 19:59:59 - The type 'PriorDistributions' is not defined. Maybe you want one of the following:
2018-10-27 19:59:59 -    ListDistribution
2018-10-27 19:59:59 -    SparseDistributionList
2018-10-27 19:59:59 -    ListDistribution`2
2018-10-27 19:59:59 -    ListDistribution`3
2018-10-27 19:59:59 -    ListDistribution`4
2018-10-27 19:59:59 - The record label 'cloudy' is not defined.
2018-10-27 19:59:59 - let parameters:DistributionParameters = {
2018-10-27 19:59:59 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-27 19:59:59 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-10-27 19:59:59 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-10-27 19:59:59 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 19:59:59 -                 Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-10-27 20:00:00 - The type 'DistributionParameters' is not defined. Maybe you want one of the following:
2018-10-27 20:00:00 -    DistributionArray
2018-10-27 20:00:00 -    DistributionRefArray
2018-10-27 20:00:00 -    DistributionFileArray
2018-10-27 20:00:00 -    Distribution
2018-10-27 20:00:00 -    DistributionArray`1
2018-10-27 20:00:00 - The record label 'cloudy' is not defined.
2018-10-27 20:00:00 - parameters.cloudy.SetValueRange(ranges.c)
2018-10-27 20:00:00 - parameters.sprinkler.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c]))
2018-10-27 20:00:00 - parameters.sprinkler.SetValueRange(ranges.s)
2018-10-27 20:00:00 - parameters.rain.[ranges.c].SetTo(Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c]))
2018-10-27 20:00:00 - parameters.rain.SetValueRange(ranges.r)
2018-10-27 20:00:00 - parameters.wetGrass.[ranges.s].[ranges.r].SetTo(Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[ranges.s].[ranges.r]))
2018-10-27 20:00:00 - parameters.wetGrass.SetValueRange(ranges.w)
2018-10-27 20:00:01 - The value, namespace, type or module 'parameters' is not defined.
2018-10-27 20:00:01 - The value, namespace, type or module 'parameters' is not defined.
2018-10-27 20:00:01 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 20:00:01 - The value, namespace, type or module 'parameters' is not defined.
2018-10-27 20:00:01 - The value, namespace, type or module 'parameters' is not defined.
2018-10-27 20:00:01 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 20:00:01 - The value, namespace, type or module 'parameters' is not defined.
2018-10-27 20:00:01 - The value, namespace, type or module 'parameters' is not defined.
2018-10-27 20:00:01 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 20:00:01 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-27 20:00:01 - The value, namespace, type or module 'parameters' is not defined.
2018-10-27 20:00:29 - type RandomVariables =
2018-10-27 20:00:29 -     {cloudy:VariableArray<int>;
2018-10-27 20:00:29 -     sprinkler:VariableArray<int>;
2018-10-27 20:00:29 -     rain:VariableArray<int>;
2018-10-27 20:00:29 -     wetGrass:VariableArray<int> }
2018-10-27 20:00:32 - type ObservedValues =
2018-10-27 20:00:32 -     {cloudy:array<int>;
2018-10-27 20:00:32 -     sprinkler:array<int>;
2018-10-27 20:00:32 -     rain:array<int>;
2018-10-27 20:00:32 -     wetGrass:array<int> }
2018-10-27 20:00:35 - type DistributionParameters =
2018-10-27 20:00:35 -     {cloudy:Variable<Vector> ;
2018-10-27 20:00:35 -     sprinkler:VariableArray<Vector> ;
2018-10-27 20:00:35 -     rain:VariableArray<Vector> ;
2018-10-27 20:00:35 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-27 20:00:36 - type DistributionParameterValues =  
2018-10-27 20:00:36 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-27 20:00:36 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-27 20:00:36 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-27 20:00:36 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-27 20:00:36 -     }
2018-10-27 20:00:40 - type PriorDistributions =
2018-10-27 20:00:40 -     {cloudy:Variable<Dirichlet> ;
2018-10-27 20:00:40 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-27 20:00:40 -     rain:VariableArray<Dirichlet> ;
2018-10-27 20:00:40 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-27 20:00:42 - type PosteriorDistributions =
2018-10-27 20:00:42 -     {cloudy:Dirichlet ;
2018-10-27 20:00:42 -     sprinkler:Dirichlet[] ;
2018-10-27 20:00:42 -     rain:Dirichlet[] ;
2018-10-27 20:00:42 -     wetGrass:Dirichlet[][] }
2018-10-27 20:00:46 - type Ranges = {c:Range;s:Range;r:Range;w:Range}
2018-10-27 20:00:49 - let engine =  InferenceEngine ()
2018-10-27 20:00:50 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 20:00:50 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 20:00:53 - let rC = Range(2).Named("C") // Cloudy
2018-10-27 20:00:53 - let rS = Range(2).Named("S") // Sprinkler
2018-10-27 20:00:53 - let rR = Range(2).Named("R") // Rain
2018-10-27 20:00:53 - let rW = Range(2).Named("W") // Wet
2018-10-27 20:00:55 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-27 20:00:55 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-27 20:00:55 - probCloudy.SetValueRange(rC)
2018-10-27 20:00:59 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-27 20:00:59 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-27 20:01:00 - cptSprinkler.[rC].SetTo(Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC]))
2018-10-27 20:01:00 - cptSprinkler.SetValueRange(rS)
2018-10-27 20:01:09 - cptSprinkler.[rC] = (Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC]))
2018-10-27 20:01:09 - cptSprinkler.SetValueRange(rS)
2018-10-27 20:01:29 - cptRain.[rC] = Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-27 20:01:29 - cptRain.SetValueRange(rR)
2018-10-27 20:01:30 - Expression evaluation failed: VariableArray<Vector> cptRain cannot be indexed by C. Perhaps you omitted C as an argument to the constructor?
2018-10-27 20:01:30 - Parameter name: index
2018-10-27 20:01:30 - ArgumentExceptionVariableArray<Vector> cptRain cannot be indexed by C. Perhaps you omitted C as an argument to the constructor?
2018-10-27 20:01:30 - Parameter name: index
2018-10-27 20:01:30 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:01:30 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:01:30 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:01:30 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:01:30 -   at <StartupCode$FSI_0065>.$FSI_0065.main@ () [0x0000a] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-27 20:01:30 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-27 20:01:30 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-27 20:02:30 - cptRain.[rC] = Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-27 20:02:30 - cptRain.SetValueRange(rR)
2018-10-27 20:02:30 - Expression evaluation failed: VariableArray<Vector> cptRain cannot be indexed by C. Perhaps you omitted C as an argument to the constructor?
2018-10-27 20:02:30 - Parameter name: index
2018-10-27 20:02:30 - ArgumentExceptionVariableArray<Vector> cptRain cannot be indexed by C. Perhaps you omitted C as an argument to the constructor?
2018-10-27 20:02:30 - Parameter name: index
2018-10-27 20:02:30 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:02:30 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:02:30 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:02:30 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:02:30 -   at <StartupCode$FSI_0066>.$FSI_0066.main@ () [0x0000a] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-27 20:02:30 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-27 20:02:30 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-27 20:02:37 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-27 20:02:37 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-27 20:02:38 - cptRain.[rC] = Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-27 20:02:38 - cptRain.SetValueRange(rR)
2018-10-27 20:02:43 - let cptWetGrassPrior= 
2018-10-27 20:02:43 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 20:02:43 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-27 20:02:43 - let cptWetGrass = 
2018-10-27 20:02:43 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 20:02:43 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-27 20:02:55 - cptWetGrass.[rS].[rR] = Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-10-27 20:02:55 - cptWetGrass.SetValueRange(rW)
2018-10-27 20:03:01 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-27 20:03:04 - let priors:PriorDistributions = {
2018-10-27 20:03:04 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-27 20:03:04 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-27 20:03:04 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-27 20:03:04 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 20:03:04 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-27 20:03:05 - let parameters:DistributionParameters = {
2018-10-27 20:03:05 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-27 20:03:05 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-10-27 20:03:05 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-10-27 20:03:05 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 20:03:05 -                 Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-10-27 20:03:33 - parameters.cloudy.SetValueRange(ranges.c)
2018-10-27 20:03:33 - parameters.sprinkler.[ranges.c] = Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c])
2018-10-27 20:03:33 - parameters.sprinkler.SetValueRange(ranges.s)
2018-10-27 20:03:33 - parameters.rain.[ranges.c] = Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c])
2018-10-27 20:03:33 - parameters.rain.SetValueRange(ranges.r)
2018-10-27 20:03:33 - parameters.wetGrass.[ranges.s].[ranges.r] = Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[ranges.s].[ranges.r])
2018-10-27 20:03:33 - parameters.wetGrass.SetValueRange(ranges.w)
2018-10-27 20:04:13 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-27 20:04:13 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-27 20:04:13 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-27 20:04:13 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-27 20:04:13 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 20:04:13 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-27 20:04:13 -     probCloudy.SetValueRange(rg.c)
2018-10-27 20:04:13 -     cptSprinkler.[rg.c].SetTo(Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c]))
2018-10-27 20:04:13 -     cptSprinkler.SetValueRange(rg.s)
2018-10-27 20:04:13 -     cptRain.[rg.c] = Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-27 20:04:13 -     cptRain.SetValueRange(rg.r)
2018-10-27 20:04:13 -     cptWetGrass.[rg.s].[rg.r] = Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-27 20:04:13 -     cptWetGrass.SetValueRange(rg.w)
2018-10-27 20:04:13 -     {cloudy = probCloudy; sprinkler =cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-27 20:04:14 - The result of this equality expression has type 'bool' and is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to set a value to a property, then use the '<-' operator e.g. 'cptRain.Item <- expression'.
2018-10-27 20:04:14 - The result of this equality expression has type 'bool' and is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'.
2018-10-27 20:05:28 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-27 20:05:28 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-27 20:05:28 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-27 20:05:28 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-27 20:05:28 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 20:05:28 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-27 20:05:28 -     probCloudy.SetValueRange(rg.c)
2018-10-27 20:05:28 -     cptSprinkler.[rg.c] = Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-27 20:05:28 -     cptSprinkler.SetValueRange(rg.s)
2018-10-27 20:05:28 -     cptRain.[rg.c] = Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-27 20:05:28 -     cptRain.SetValueRange(rg.r)
2018-10-27 20:05:28 -     cptWetGrass.[rg.s].[rg.r] = Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-27 20:05:28 -     cptWetGrass.SetValueRange(rg.w)
2018-10-27 20:05:28 -     {cloudy = probCloudy; sprinkler =cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-27 20:05:29 - The result of this equality expression has type 'bool' and is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to set a value to a property, then use the '<-' operator e.g. 'cptSprinkler.Item <- expression'.
2018-10-27 20:05:29 - The result of this equality expression has type 'bool' and is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to set a value to a property, then use the '<-' operator e.g. 'cptRain.Item <- expression'.
2018-10-27 20:05:29 - The result of this equality expression has type 'bool' and is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'.
2018-10-27 20:06:04 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-27 20:06:04 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-27 20:06:04 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-27 20:06:04 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-27 20:06:04 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 20:06:04 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-27 20:06:04 -     probCloudy.SetValueRange(rg.c)
2018-10-27 20:06:04 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-27 20:06:04 -     cptSprinkler.SetValueRange(rg.s)
2018-10-27 20:06:04 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-27 20:06:04 -     cptRain.SetValueRange(rg.r)
2018-10-27 20:06:04 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-27 20:06:04 -     cptWetGrass.SetValueRange(rg.w)
2018-10-27 20:06:04 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-27 20:06:32 - parameters.cloudy.SetValueRange(ranges.c)
2018-10-27 20:06:32 - parameters.sprinkler.[ranges.c] <- Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c])
2018-10-27 20:06:32 - parameters.sprinkler.SetValueRange(ranges.s)
2018-10-27 20:06:32 - parameters.rain.[ranges.c] <- Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c])
2018-10-27 20:06:32 - parameters.rain.SetValueRange(ranges.r)
2018-10-27 20:06:32 - parameters.wetGrass.[ranges.s].[ranges.r] <- Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[ranges.s].[ranges.r])
2018-10-27 20:06:32 - parameters.wetGrass.SetValueRange(ranges.w)
2018-10-27 20:06:48 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2018-10-27 20:06:48 - cptSprinkler.SetValueRange(rS)
2018-10-27 20:06:49 - Expression evaluation failed: Cannot assign to array more than once.
2018-10-27 20:06:49 - InvalidOperationExceptionCannot assign to array more than once.
2018-10-27 20:06:49 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].set_Item (Microsoft.ML.Probabilistic.Models.Range[] index, TItem value) [0x00008] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:06:49 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].set_Item (Microsoft.ML.Probabilistic.Models.Range range, TItem value) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:06:49 -   at <StartupCode$FSI_0083>.$FSI_0083.main@ () [0x0001e] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-27 20:06:49 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-27 20:06:49 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-27 20:06:58 - let rC = Range(2).Named("C") // Cloudy
2018-10-27 20:06:58 - let rS = Range(2).Named("S") // Sprinkler
2018-10-27 20:06:58 - let rR = Range(2).Named("R") // Rain
2018-10-27 20:06:58 - let rW = Range(2).Named("W") // Wet
2018-10-27 20:07:03 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-27 20:07:03 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-27 20:07:03 - probCloudy.SetValueRange(rC)
2018-10-27 20:07:08 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-27 20:07:08 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-27 20:07:10 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2018-10-27 20:07:10 - cptSprinkler.SetValueRange(rS)
2018-10-27 20:07:17 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-27 20:07:17 - cptRain.SetValueRange(rR)
2018-10-27 20:07:17 - Expression evaluation failed: VariableArray<Dirichlet> cptRainPrior cannot be indexed by C. Perhaps you omitted C as an argument to the constructor?
2018-10-27 20:07:17 - Parameter name: index
2018-10-27 20:07:17 - ArgumentExceptionVariableArray<Dirichlet> cptRainPrior cannot be indexed by C. Perhaps you omitted C as an argument to the constructor?
2018-10-27 20:07:17 - Parameter name: index
2018-10-27 20:07:17 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:07:17 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:07:17 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:07:17 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:07:17 -   at <StartupCode$FSI_0090>.$FSI_0090.main@ () [0x00014] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-27 20:07:17 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-27 20:07:17 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-27 20:07:25 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-27 20:07:25 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-27 20:07:28 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-27 20:07:28 - cptRain.SetValueRange(rR)
2018-10-27 20:07:41 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-10-27 20:07:41 - cptWetGrass.SetValueRange(rW)
2018-10-27 20:07:42 - Expression evaluation failed: VariableArray<VariableArray<Vector>, Vector[][]> cptWetGrass cannot be indexed by S. Perhaps you omitted S as an argument to the constructor?
2018-10-27 20:07:42 - Parameter name: index
2018-10-27 20:07:42 - ArgumentExceptionVariableArray<VariableArray<Vector>, Vector[][]> cptWetGrass cannot be indexed by S. Perhaps you omitted S as an argument to the constructor?
2018-10-27 20:07:42 - Parameter name: index
2018-10-27 20:07:42 -   at Microsoft.ML.Probabilistic.Models.Range.CheckCompatible (Microsoft.ML.Probabilistic.Models.IModelExpression index, Microsoft.ML.Probabilistic.Models.IVariableArray array) [0x00082] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:07:42 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].GetItem (Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray] array, TItem itemPrototype, Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00060] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:07:42 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.IModelExpression[] index) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:07:42 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].get_Item (Microsoft.ML.Probabilistic.Models.Range range) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:07:42 -   at <StartupCode$FSI_0094>.$FSI_0094.main@ () [0x0000a] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-27 20:07:42 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-27 20:07:42 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-27 20:07:50 - let cptWetGrassPrior= 
2018-10-27 20:07:50 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 20:07:50 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-27 20:07:50 - let cptWetGrass = 
2018-10-27 20:07:50 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 20:07:50 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-27 20:07:51 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-10-27 20:07:51 - cptWetGrass.SetValueRange(rW)
2018-10-27 20:08:49 - let rvs:RandomVariables =
2018-10-27 20:08:49 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 20:08:49 -     vC.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-10-27 20:08:49 -     let vS = (AddChildFromOneParent vC cptSprinkler).Named("sprinkler")
2018-10-27 20:08:49 -     let vR = (AddChildFromOneParent vC cptRain).Named("rain")
2018-10-27 20:08:49 -     let vW = (AddChildFromTwoParents vS vR cptWetGrass).Named("wetGrass")
2018-10-27 20:08:49 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-27 20:09:22 - let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-27 20:09:22 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 20:09:22 -     vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-27 20:09:22 -     let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-27 20:09:22 -     let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-27 20:09:22 -     let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-27 20:09:22 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-27 20:10:36 - let xPrior:Gaussian = Gaussian(1.2, 3.4) 
2018-10-27 20:10:36 - x.[item].[feature] <- Variable.Random(xPrior).ForEach(item, feature)  
2018-10-27 20:10:36 - Variable.ConstrainPositive(x.[item].[feature])
2018-10-27 20:17:25 - The size of `x` is $2+3$. We say `x` has two items, of which, one has 2 features & one has 3 features?!
2018-10-27 20:17:27 - Unexpected keyword 'of' in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2018-10-27 20:17:27 - This construct is deprecated: '$' is not permitted as a character in operator names and is reserved for future use
2018-10-27 20:17:27 - parse error
2018-10-27 20:19:49 - let xPrior:Gaussian = Gaussian(1.2, 3.4) 
2018-10-27 20:19:49 - x.[item].[feature] <- Variable.Random(xPrior).ForEach(item, feature)  // Assign all 5 item-features (!)
2018-10-27 20:19:49 - Variable.ConstrainPositive(x.[item].[feature])   // Constrain all 5 item-features (!)
2018-10-27 20:19:50 - Expression evaluation failed: Cannot assign to array more than once.
2018-10-27 20:19:50 - InvalidOperationExceptionCannot assign to array more than once.
2018-10-27 20:19:50 -   at Microsoft.ML.Probabilistic.Models.VariableArrayBase`2[TItem,TArray].set_Item (Microsoft.ML.Probabilistic.Models.Range[] index, TItem value) [0x00008] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:19:50 -   at Microsoft.ML.Probabilistic.Models.VariableArray`2[TItem,TArray].set_Item (Microsoft.ML.Probabilistic.Models.Range range, TItem value) [0x00000] in <55cc3893047549ad844d212223dec9ef>:0 
2018-10-27 20:19:50 -   at <StartupCode$FSI_0102>.$FSI_0102.main@ () [0x00073] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-27 20:19:50 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-27 20:19:50 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-27 20:19:55 - let sizes:array<int> = [| 2; 3 |]  
2018-10-27 20:19:55 - let item:Range = Range(sizes.Length).Named("item")  // Standard range of 2 items is outer loop
2018-10-27 20:19:55 - let sizesVar:VariableArray<int> = Variable.Constant(sizes, item).Named("sizes")  
2018-10-27 20:19:55 - let feature:Range =  Range(sizesVar.[item]).Named("feature")  // Inner range "feature" is variable in size
2018-10-27 20:19:55 - let x:VariableArray<VariableArray<float>,float[][]>
2018-10-27 20:19:55 -         = Variable.Array<VariableArray<float>,float[][]>(Variable.Array<float>(feature), item).Named("x");
2018-10-27 20:19:58 - let xPrior:Gaussian = Gaussian(1.2, 3.4) 
2018-10-27 20:19:58 - x.[item].[feature] <- Variable.Random(xPrior).ForEach(item, feature)  // Assign all 5 item-features (!)
2018-10-27 20:19:58 - Variable.ConstrainPositive(x.[item].[feature])   // Constrain all 5 item-features (!)
2018-10-27 20:21:22 - (*
2018-10-27 20:21:22 - if (cloudy.HasValue)
2018-10-27 20:21:22 -             {
2018-10-27 20:21:22 -                 Cloudy.ObservedValue = new int[] { cloudy.Value };
2018-10-27 20:21:22 -             }
2018-10-27 20:21:22 -             else
2018-10-27 20:21:22 -             {
2018-10-27 20:21:22 -                 Cloudy.ClearObservedValue();
2018-10-27 20:21:22 -             }
2018-10-27 20:21:22 -             if (sprinkler.HasValue)
2018-10-27 20:21:22 -             {
2018-10-27 20:21:22 -                 Sprinkler.ObservedValue = new int[] { sprinkler.Value };
2018-10-27 20:21:22 -             }
2018-10-27 20:21:22 -             else
2018-10-27 20:21:22 -             {
2018-10-27 20:21:22 -                 Sprinkler.ClearObservedValue();
2018-10-27 20:21:22 -             }
2018-10-27 20:21:22 -             if (wet.HasValue)
2018-10-27 20:21:22 -             {
2018-10-27 20:21:22 -                 WetGrass.ObservedValue = new int[] { wet.Value };
2018-10-27 20:21:22 -             }
2018-10-27 20:21:22 -             else
2018-10-27 20:21:22 -             {
2018-10-27 20:21:22 -                 WetGrass.ClearObservedValue();
2018-10-27 20:21:22 -             }
2018-10-27 20:21:22 -             Rain.ClearObservedValue();
2018-10-27 20:21:22 -             ProbCloudyPrior.ObservedValue = probCloudyPrior;
2018-10-27 20:21:22 -             CPTSprinklerPrior.ObservedValue = cptSprinklerPrior;
2018-10-27 20:21:22 -             CPTRainPrior.ObservedValue = cptRainPrior;
2018-10-27 20:21:22 -             CPTWetGrassPrior.ObservedValue = cptWetGrassPrior;
2018-10-27 20:21:22 -             // Inference
2018-10-27 20:21:22 -             var rainPosterior = Engine.Infer<Discrete[]>(Rain);
2018-10-27 20:21:22 -             // In this example, index 0 is true and index 1 is false
2018-10-27 20:21:22 -             return rainPosterior[0].GetProbs()[0];
2018-10-27 20:21:22 -         } *)
2018-10-27 20:42:27 - ### `WetGlassSprinklerRainModel`
2018-10-27 20:42:28 - Unexpected symbol # in directive. Expected identifier or other token.
2018-10-27 20:42:28 - parse error
2018-10-27 20:42:41 - type WetGlassSprinklerRainModel() =
2018-10-27 20:42:41 -    do printfn "Test"
2018-10-27 20:43:35 - let model = WetGrassSprinklerRainModel()
2018-10-27 20:43:35 - The value or constructor 'WetGrassSprinklerRainModel' is not defined. Maybe you want one of the following:
2018-10-27 20:43:35 -    WetGlassSprinklerRainModel
2018-10-27 20:44:16 - type WetGrassSprinklerRainModel () =
2018-10-27 20:44:16 -     do printfn "Test"
2018-10-27 20:44:21 - let model = WetGrassSprinklerRainModel()
2018-10-27 20:49:07 - type WetGrassSprinklerRainModel () =
2018-10-27 20:49:07 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-27 20:49:07 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 20:49:07 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 20:49:07 -     let priors = buildPriors ranges
2018-10-27 20:49:07 -     let parameters = buildDistributionParameters ranges priors
2018-10-27 20:49:07 -     let rvs = buildRandomVariables rN parameters
2018-10-27 20:49:07 -     do printfn "Test"
2018-10-27 20:49:08 - The value or constructor 'buildPriors' is not defined.
2018-10-27 20:49:18 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-27 20:49:18 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-27 20:49:18 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-27 20:49:18 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-27 20:49:18 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 20:49:18 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-27 20:49:23 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-27 20:49:23 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-27 20:49:23 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-27 20:49:23 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-27 20:49:23 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 20:49:23 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-27 20:49:23 -     probCloudy.SetValueRange(rg.c)
2018-10-27 20:49:23 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-27 20:49:23 -     cptSprinkler.SetValueRange(rg.s)
2018-10-27 20:49:23 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-27 20:49:23 -     cptRain.SetValueRange(rg.r)
2018-10-27 20:49:23 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-27 20:49:23 -     cptWetGrass.SetValueRange(rg.w)
2018-10-27 20:49:23 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-27 21:01:37 - type WetGrassSprinklerRainModel () =
2018-10-27 21:01:37 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-27 21:01:37 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 21:01:37 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 21:01:37 -     let priors = buildPriors ranges
2018-10-27 21:01:37 -     let parameters = buildDistributionParameters ranges priors
2018-10-27 21:01:37 -     let rvs = buildRandomVariables rN parameters
2018-10-27 21:01:37 -     do printfn "Test"
2018-10-27 21:01:37 -     member this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-27 21:01:37 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-27 21:01:37 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-27 21:01:37 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-27 21:01:37 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 21:01:37 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-27 21:01:37 -     member this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-27 21:01:37 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-27 21:01:37 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-27 21:01:37 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-27 21:01:37 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 21:01:37 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-27 21:01:37 -         probCloudy.SetValueRange(rg.c)
2018-10-27 21:01:37 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-27 21:01:37 -         cptSprinkler.SetValueRange(rg.s)
2018-10-27 21:01:37 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-27 21:01:37 -         cptRain.SetValueRange(rg.r)
2018-10-27 21:01:37 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-27 21:01:37 -         cptWetGrass.SetValueRange(rg.w)
2018-10-27 21:01:37 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-27 21:01:37 -     member this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-27 21:01:37 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 21:01:37 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-27 21:01:37 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-27 21:01:37 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-27 21:01:37 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-27 21:01:37 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-27 21:03:05 - type WetGrassSprinklerRainModel () =
2018-10-27 21:03:05 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-27 21:03:05 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 21:03:05 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 21:03:05 -     let priors = buildPriors ranges
2018-10-27 21:03:05 -     let parameters = buildDistributionParameters ranges priors
2018-10-27 21:03:05 -     let rvs = buildRandomVariables rN parameters
2018-10-27 21:03:05 -     do printfn "Test"
2018-10-27 21:03:05 -     member private this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-27 21:03:05 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-27 21:03:05 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-27 21:03:05 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-27 21:03:05 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 21:03:05 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-27 21:03:05 -     member private  this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-27 21:03:05 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-27 21:03:05 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-27 21:03:05 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-27 21:03:05 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 21:03:05 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-27 21:03:05 -         probCloudy.SetValueRange(rg.c)
2018-10-27 21:03:05 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-27 21:03:05 -         cptSprinkler.SetValueRange(rg.s)
2018-10-27 21:03:05 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-27 21:03:05 -         cptRain.SetValueRange(rg.r)
2018-10-27 21:03:05 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-27 21:03:05 -         cptWetGrass.SetValueRange(rg.w)
2018-10-27 21:03:05 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-27 21:03:05 -     member private  this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-27 21:03:05 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 21:03:05 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-27 21:03:05 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-27 21:03:05 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-27 21:03:05 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-27 21:03:05 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-27 21:03:28 - type WetGrassSprinklerRainModel () =
2018-10-27 21:03:28 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-27 21:03:28 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 21:03:28 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 21:03:28 -     let priors = BuildPriors ranges
2018-10-27 21:03:28 -     let parameters = BuildDistributionParameters ranges priors
2018-10-27 21:03:28 -     let rvs = BuildRandomVariables rN parameters
2018-10-27 21:03:28 -     do printfn "Test"
2018-10-27 21:03:28 -     member private this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-27 21:03:28 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-27 21:03:28 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-27 21:03:28 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-27 21:03:28 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 21:03:28 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-27 21:03:28 -     member private  this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-27 21:03:28 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-27 21:03:28 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-27 21:03:28 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-27 21:03:28 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 21:03:28 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-27 21:03:28 -         probCloudy.SetValueRange(rg.c)
2018-10-27 21:03:28 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-27 21:03:28 -         cptSprinkler.SetValueRange(rg.s)
2018-10-27 21:03:28 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-27 21:03:28 -         cptRain.SetValueRange(rg.r)
2018-10-27 21:03:28 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-27 21:03:28 -         cptWetGrass.SetValueRange(rg.w)
2018-10-27 21:03:28 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-27 21:03:28 -     member private  this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-27 21:03:28 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 21:03:28 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-27 21:03:28 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-27 21:03:28 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-27 21:03:28 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-27 21:03:28 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-27 21:03:30 - The value or constructor 'BuildPriors' is not defined. Maybe you want one of the following:
2018-10-27 21:03:30 -    buildPriors
2018-10-27 21:03:30 - The value or constructor 'BuildDistributionParameters' is not defined. Maybe you want one of the following:
2018-10-27 21:03:30 -    buildDistributionParameters
2018-10-27 21:03:30 -    DistributionParameters
2018-10-27 21:03:30 - The value or constructor 'BuildRandomVariables' is not defined. Maybe you want one of the following:
2018-10-27 21:03:30 -    buildRandomVariables
2018-10-27 21:03:30 -    buildFormatElement
2018-10-27 21:03:30 -    buildFormatComment
2018-10-27 21:03:30 -    RandomVariables
2018-10-27 21:03:30 -    RandomVariable
2018-10-27 21:04:07 - type WetGrassSprinklerRainModel () =
2018-10-27 21:04:07 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-27 21:04:07 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 21:04:07 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 21:04:07 -     let priors = this.BuildPriors ranges
2018-10-27 21:04:07 -     let parameters = this.BuildDistributionParameters ranges priors
2018-10-27 21:04:07 -     let rvs = this.BuildRandomVariables rN parameters
2018-10-27 21:04:07 -     do printfn "Test"
2018-10-27 21:04:07 -     member private this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-27 21:04:07 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-27 21:04:07 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-27 21:04:07 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-27 21:04:07 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 21:04:07 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-27 21:04:07 -     member private  this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-27 21:04:07 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-27 21:04:07 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-27 21:04:07 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-27 21:04:07 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 21:04:07 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-27 21:04:07 -         probCloudy.SetValueRange(rg.c)
2018-10-27 21:04:07 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-27 21:04:07 -         cptSprinkler.SetValueRange(rg.s)
2018-10-27 21:04:07 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-27 21:04:07 -         cptRain.SetValueRange(rg.r)
2018-10-27 21:04:07 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-27 21:04:07 -         cptWetGrass.SetValueRange(rg.w)
2018-10-27 21:04:07 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-27 21:04:07 -     member private  this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-27 21:04:07 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 21:04:07 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-27 21:04:07 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-27 21:04:07 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-27 21:04:07 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-27 21:04:07 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-27 21:04:09 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-27 21:04:09 -    ThisAssembly
2018-10-27 21:04:09 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-27 21:04:09 -    ThisAssembly
2018-10-27 21:04:09 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-27 21:04:09 -    ThisAssembly
2018-10-27 21:05:03 - type WetGrassSprinklerRainModel () =
2018-10-27 21:05:03 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-27 21:05:03 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 21:05:03 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 21:05:03 -     let priors = this.BuildPriors ranges
2018-10-27 21:05:03 -     let parameters = this.BuildDistributionParameters ranges priors
2018-10-27 21:05:03 -     let rvs = this.BuildRandomVariables rN parameters
2018-10-27 21:05:03 -     do printfn "Test"
2018-10-27 21:05:03 -     member private this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-27 21:05:03 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-27 21:05:03 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-27 21:05:03 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-27 21:05:03 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 21:05:03 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-27 21:05:03 -     member private  this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-27 21:05:03 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-27 21:05:03 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-27 21:05:03 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-27 21:05:03 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 21:05:03 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-27 21:05:03 -         probCloudy.SetValueRange(rg.c)
2018-10-27 21:05:03 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-27 21:05:03 -         cptSprinkler.SetValueRange(rg.s)
2018-10-27 21:05:03 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-27 21:05:03 -         cptRain.SetValueRange(rg.r)
2018-10-27 21:05:03 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-27 21:05:03 -         cptWetGrass.SetValueRange(rg.w)
2018-10-27 21:05:03 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-27 21:05:03 -     member private  this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-27 21:05:03 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 21:05:03 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-27 21:05:03 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-27 21:05:03 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-27 21:05:03 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-27 21:05:03 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-27 21:05:04 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-27 21:05:04 -    ThisAssembly
2018-10-27 21:05:04 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-27 21:05:04 -    ThisAssembly
2018-10-27 21:05:04 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-27 21:05:04 -    ThisAssembly
2018-10-27 21:06:46 - type WetGrassSprinklerRainModel () =
2018-10-27 21:06:46 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-27 21:06:46 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-27 21:06:46 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-27 21:06:46 -     let priors = this.BuildPriors ranges
2018-10-27 21:06:46 -     let parameters = this.BuildDistributionParameters ranges priors
2018-10-27 21:06:46 -     let rvs = this.BuildRandomVariables rN parameters
2018-10-27 21:06:46 -     do printfn "Test"
2018-10-27 21:06:46 -     member  this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-27 21:06:46 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-27 21:06:46 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-27 21:06:46 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-27 21:06:46 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-27 21:06:46 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-27 21:06:46 -     member   this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-27 21:06:46 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-27 21:06:46 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-27 21:06:46 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-27 21:06:46 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-27 21:06:46 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-27 21:06:46 -         probCloudy.SetValueRange(rg.c)
2018-10-27 21:06:46 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-27 21:06:46 -         cptSprinkler.SetValueRange(rg.s)
2018-10-27 21:06:46 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-27 21:06:46 -         cptRain.SetValueRange(rg.r)
2018-10-27 21:06:46 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-27 21:06:46 -         cptWetGrass.SetValueRange(rg.w)
2018-10-27 21:06:46 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-27 21:06:46 -     member   this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-27 21:06:46 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-27 21:06:46 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-27 21:06:46 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-27 21:06:46 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-27 21:06:46 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-27 21:06:46 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-27 21:06:48 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-27 21:06:48 -    ThisAssembly
2018-10-27 21:06:48 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-27 21:06:48 -    ThisAssembly
2018-10-27 21:06:48 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-27 21:06:48 -    ThisAssembly
2018-10-29 13:55:46 - Reporting 0 opened comms
2018-10-29 13:55:48 - #load "Paket.fsx"
2018-10-29 13:55:55 - Paket.Package
2018-10-29 13:55:55 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-29 13:55:55 -       "Microsoft.ML.Probabilistic"
2018-10-29 13:55:55 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-29 13:55:55 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-29 13:55:55 -       "NETStandard.Library"
2018-10-29 13:55:55 -   ]
2018-10-29 13:57:27 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-29 13:57:34 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-29 13:58:42 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-29 13:58:42 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-29 13:58:42 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-29 13:58:43 - #r "Microsoft.ML.Probabilistic"
2018-10-29 13:58:43 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-29 13:58:43 - #r "netstandard"
2018-10-29 13:58:44 - open System
2018-10-29 13:58:44 - open Microsoft.ML.Probabilistic  
2018-10-29 13:58:44 - open Microsoft.ML.Probabilistic.Models  
2018-10-29 13:58:44 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-29 13:58:44 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-29 13:58:44 - open Microsoft.ML.Probabilistic.Math
2018-10-29 13:58:46 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-29 13:58:52 - open Microsoft.ML.Probabilistic.FSharp
2018-10-29 13:58:53 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2018-10-29 13:58:53 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-10-29 13:58:53 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-10-29 13:58:54 - let AddChildFromOneParent 
2018-10-29 13:58:54 -         (parent:RandomVariable) 
2018-10-29 13:58:54 -         (cpt:ConditionalProbabilityTable) =
2018-10-29 13:58:54 -     let r = parent.Range
2018-10-29 13:58:54 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 13:58:54 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 13:58:54 -                        Variable.Discrete(cpt.[pi])))
2018-10-29 13:58:54 -     child
2018-10-29 13:58:54 - type ConditionalProbabilityTable2D = 
2018-10-29 13:58:54 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-29 13:58:55 - let AddChildFromTwoParents 
2018-10-29 13:58:55 -         (parent1:RandomVariable) 
2018-10-29 13:58:55 -         (parent2:RandomVariable) 
2018-10-29 13:58:55 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 13:58:55 -     let r = parent1.Range
2018-10-29 13:58:55 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 13:58:55 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 13:58:55 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 13:58:55 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 13:58:55 -     child       
2018-10-29 13:58:56 - type RandomVariables =
2018-10-29 13:58:56 -     {cloudy:VariableArray<int>;
2018-10-29 13:58:56 -     sprinkler:VariableArray<int>;
2018-10-29 13:58:56 -     rain:VariableArray<int>;
2018-10-29 13:58:56 -     wetGrass:VariableArray<int> }
2018-10-29 13:58:56 - type ObservedValues =
2018-10-29 13:58:56 -     {cloudy:array<int>;
2018-10-29 13:58:56 -     sprinkler:array<int>;
2018-10-29 13:58:56 -     rain:array<int>;
2018-10-29 13:58:56 -     wetGrass:array<int> }
2018-10-29 13:58:57 - type DistributionParameters =
2018-10-29 13:58:57 -     {cloudy:Variable<Vector> ;
2018-10-29 13:58:57 -     sprinkler:VariableArray<Vector> ;
2018-10-29 13:58:57 -     rain:VariableArray<Vector> ;
2018-10-29 13:58:57 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-29 13:58:58 - type DistributionParameterValues =  
2018-10-29 13:58:58 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-29 13:58:58 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-29 13:58:58 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-29 13:58:58 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-29 13:58:58 -     }
2018-10-29 13:58:59 - type PriorDistributions =
2018-10-29 13:58:59 -     {cloudy:Variable<Dirichlet> ;
2018-10-29 13:58:59 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-29 13:58:59 -     rain:VariableArray<Dirichlet> ;
2018-10-29 13:58:59 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-29 13:58:59 - type PosteriorDistributions =
2018-10-29 13:58:59 -     {cloudy:Dirichlet ;
2018-10-29 13:58:59 -     sprinkler:Dirichlet[] ;
2018-10-29 13:58:59 -     rain:Dirichlet[] ;
2018-10-29 13:58:59 -     wetGrass:Dirichlet[][] }
2018-10-29 13:59:00 - let engine =  InferenceEngine ()
2018-10-29 13:59:01 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 13:59:01 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 13:59:01 - let rC = Range(2).Named("C") // Cloudy
2018-10-29 13:59:01 - let rS = Range(2).Named("S") // Sprinkler
2018-10-29 13:59:01 - let rR = Range(2).Named("R") // Rain
2018-10-29 13:59:01 - let rW = Range(2).Named("W") // Wet
2018-10-29 13:59:02 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-29 13:59:02 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-29 13:59:02 - probCloudy.SetValueRange(rC)
2018-10-29 13:59:02 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-29 13:59:02 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-29 13:59:03 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2018-10-29 13:59:03 - cptSprinkler.SetValueRange(rS)
2018-10-29 13:59:04 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-29 13:59:04 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-29 13:59:04 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-29 13:59:04 - cptRain.SetValueRange(rR)
2018-10-29 13:59:05 - let cptWetGrassPrior= 
2018-10-29 13:59:05 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 13:59:05 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-29 13:59:05 - let cptWetGrass = 
2018-10-29 13:59:05 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 13:59:05 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-29 13:59:06 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-10-29 13:59:06 - cptWetGrass.SetValueRange(rW)
2018-10-29 13:59:07 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 13:59:07 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 13:59:07 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 13:59:07 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 13:59:07 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 13:59:07 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 13:59:07 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 13:59:08 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 13:59:08 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 13:59:08 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 13:59:08 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 13:59:08 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 13:59:08 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 13:59:08 -     probCloudy.SetValueRange(rg.c)
2018-10-29 13:59:08 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 13:59:08 -     cptSprinkler.SetValueRange(rg.s)
2018-10-29 13:59:08 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 13:59:08 -     cptRain.SetValueRange(rg.r)
2018-10-29 13:59:08 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 13:59:08 -     cptWetGrass.SetValueRange(rg.w)
2018-10-29 13:59:08 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 13:59:09 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 13:59:09 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 13:59:09 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 13:59:09 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-10-29 14:22:54 - #load "Paket.fsx"
2018-10-29 14:22:57 - Paket.Package
2018-10-29 14:22:57 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-29 14:22:57 -       "Microsoft.ML.Probabilistic"
2018-10-29 14:22:57 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-29 14:22:57 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-29 14:22:57 -       "NETStandard.Library"
2018-10-29 14:22:57 -   ]
2018-10-29 14:24:21 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-29 14:24:27 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-29 14:25:33 - //#load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-29 14:25:33 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-29 14:25:33 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-29 14:25:33 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-29 14:25:34 - #r "Microsoft.ML.Probabilistic"
2018-10-29 14:25:34 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-29 14:25:34 - #r "netstandard"
2018-10-29 14:25:35 - open System
2018-10-29 14:25:35 - open Microsoft.ML.Probabilistic  
2018-10-29 14:25:35 - open Microsoft.ML.Probabilistic.Models  
2018-10-29 14:25:35 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-29 14:25:35 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-29 14:25:35 - open Microsoft.ML.Probabilistic.Math
2018-10-29 14:25:37 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-29 14:25:44 - open Microsoft.ML.Probabilistic.FSharp
2018-10-29 14:25:45 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2018-10-29 14:25:45 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-10-29 14:25:45 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-10-29 14:25:46 - let AddChildFromOneParent 
2018-10-29 14:25:46 -         (parent:RandomVariable) 
2018-10-29 14:25:46 -         (cpt:ConditionalProbabilityTable) =
2018-10-29 14:25:46 -     let r = parent.Range
2018-10-29 14:25:46 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 14:25:46 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 14:25:46 -                        Variable.Discrete(cpt.[pi])))
2018-10-29 14:25:46 -     child
2018-10-29 14:25:46 - type ConditionalProbabilityTable2D = 
2018-10-29 14:25:46 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-29 14:25:47 - let AddChildFromTwoParents 
2018-10-29 14:25:47 -         (parent1:RandomVariable) 
2018-10-29 14:25:47 -         (parent2:RandomVariable) 
2018-10-29 14:25:47 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 14:25:47 -     let r = parent1.Range
2018-10-29 14:25:47 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 14:25:47 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 14:25:47 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 14:25:47 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 14:25:47 -     child       
2018-10-29 14:25:47 - type RandomVariables =
2018-10-29 14:25:47 -     {cloudy:VariableArray<int>;
2018-10-29 14:25:47 -     sprinkler:VariableArray<int>;
2018-10-29 14:25:47 -     rain:VariableArray<int>;
2018-10-29 14:25:47 -     wetGrass:VariableArray<int> }
2018-10-29 14:25:48 - type ObservedValues =
2018-10-29 14:25:48 -     {cloudy:array<int>;
2018-10-29 14:25:48 -     sprinkler:array<int>;
2018-10-29 14:25:48 -     rain:array<int>;
2018-10-29 14:25:48 -     wetGrass:array<int> }
2018-10-29 14:25:49 - type DistributionParameters =
2018-10-29 14:25:49 -     {cloudy:Variable<Vector> ;
2018-10-29 14:25:49 -     sprinkler:VariableArray<Vector> ;
2018-10-29 14:25:49 -     rain:VariableArray<Vector> ;
2018-10-29 14:25:49 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-29 14:25:49 - type DistributionParameterValues =  
2018-10-29 14:25:49 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-29 14:25:49 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-29 14:25:49 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-29 14:25:49 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-29 14:25:49 -     }
2018-10-29 14:25:50 - type PriorDistributions =
2018-10-29 14:25:50 -     {cloudy:Variable<Dirichlet> ;
2018-10-29 14:25:50 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-29 14:25:50 -     rain:VariableArray<Dirichlet> ;
2018-10-29 14:25:50 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-29 14:25:51 - type PosteriorDistributions =
2018-10-29 14:25:51 -     {cloudy:Dirichlet ;
2018-10-29 14:25:51 -     sprinkler:Dirichlet[] ;
2018-10-29 14:25:51 -     rain:Dirichlet[] ;
2018-10-29 14:25:51 -     wetGrass:Dirichlet[][] }
2018-10-29 14:25:52 - type Ranges = {c:Range;s:Range;r:Range;w:Range}
2018-10-29 14:25:52 - let engine =  InferenceEngine ()
2018-10-29 14:25:53 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 14:25:53 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 14:25:53 - let rC = Range(2).Named("C") // Cloudy
2018-10-29 14:25:53 - let rS = Range(2).Named("S") // Sprinkler
2018-10-29 14:25:53 - let rR = Range(2).Named("R") // Rain
2018-10-29 14:25:53 - let rW = Range(2).Named("W") // Wet
2018-10-29 14:25:54 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-29 14:25:54 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-29 14:25:54 - probCloudy.SetValueRange(rC)
2018-10-29 14:25:54 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-29 14:25:54 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-29 14:25:55 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2018-10-29 14:25:55 - cptSprinkler.SetValueRange(rS)
2018-10-29 14:25:56 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-29 14:25:56 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-29 14:25:56 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-29 14:25:56 - cptRain.SetValueRange(rR)
2018-10-29 14:25:57 - let cptWetGrassPrior= 
2018-10-29 14:25:57 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 14:25:57 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-29 14:25:57 - let cptWetGrass = 
2018-10-29 14:25:57 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 14:25:57 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-29 14:25:57 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-10-29 14:25:57 - cptWetGrass.SetValueRange(rW)
2018-10-29 14:25:58 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 14:25:59 - let priors:PriorDistributions = {
2018-10-29 14:25:59 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 14:25:59 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-29 14:25:59 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-29 14:25:59 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 14:25:59 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-29 14:25:59 - let parameters:DistributionParameters = {
2018-10-29 14:25:59 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-29 14:25:59 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-10-29 14:25:59 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-10-29 14:25:59 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 14:25:59 -                 Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-10-29 14:26:00 - parameters.cloudy.SetValueRange(ranges.c)
2018-10-29 14:26:00 - parameters.sprinkler.[ranges.c] <- Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c])
2018-10-29 14:26:00 - parameters.sprinkler.SetValueRange(ranges.s)
2018-10-29 14:26:00 - parameters.rain.[ranges.c] <- Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c])
2018-10-29 14:26:00 - parameters.rain.SetValueRange(ranges.r)
2018-10-29 14:26:00 - parameters.wetGrass.[ranges.s].[ranges.r] <- Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[ranges.s].[ranges.r])
2018-10-29 14:26:00 - parameters.wetGrass.SetValueRange(ranges.w)
2018-10-29 14:26:01 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 14:26:01 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 14:26:01 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 14:26:01 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 14:26:01 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 14:26:01 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 14:26:02 - let priors = buildPriors ranges
2018-10-29 14:26:02 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 14:26:02 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 14:26:02 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 14:26:02 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 14:26:02 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 14:26:02 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 14:26:02 -     probCloudy.SetValueRange(rg.c)
2018-10-29 14:26:02 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 14:26:02 -     cptSprinkler.SetValueRange(rg.s)
2018-10-29 14:26:02 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 14:26:02 -     cptRain.SetValueRange(rg.r)
2018-10-29 14:26:02 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 14:26:02 -     cptWetGrass.SetValueRange(rg.w)
2018-10-29 14:26:02 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 14:26:03 - let parameters = buildDistributionParameters ranges priors
2018-10-29 14:26:04 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 14:26:04 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 14:26:04 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 14:26:04 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-10-29 14:26:05 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("sprinkler")
2018-10-29 14:26:05 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("rain")
2018-10-29 14:26:05 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("wetGrass")
2018-10-29 14:26:06 - let rvs:RandomVariables =
2018-10-29 14:26:06 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 14:26:06 -     vC.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-10-29 14:26:06 -     let vS = (AddChildFromOneParent vC cptSprinkler).Named("sprinkler")
2018-10-29 14:26:06 -     let vR = (AddChildFromOneParent vC cptRain).Named("rain")
2018-10-29 14:26:06 -     let vW = (AddChildFromTwoParents vS vR cptWetGrass).Named("wetGrass")
2018-10-29 14:26:06 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 14:26:06 - let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 14:26:06 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 14:26:06 -     vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 14:26:06 -     let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 14:26:06 -     let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 14:26:06 -     let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 14:26:06 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 14:26:07 - let numberOfExamples = Variable.New<int>().Named("NofE")
2018-10-29 14:26:07 - let rN = Range(numberOfExamples).Named("N")
2018-10-29 14:26:07 - let ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("W")}
2018-10-29 14:26:07 - let priors = buildPriors ranges
2018-10-29 14:26:07 - let parameters = buildDistributionParameters ranges priors
2018-10-29 14:26:08 - let rvs = buildRandomVariables rN parameters
2018-10-29 14:26:08 - let a:array<int> = [|3|]
2018-10-29 14:26:08 - let b:int[] =  [|3|]
2018-10-29 14:26:08 - let c:int[] = a
2018-10-29 14:26:08 - let d:Vector[][] = [|[|Vector.FromArray(2.,3.)|]|]
2018-10-29 14:26:08 - let e:array<array<Vector>> = [|[|Vector.FromArray(2.,3.)|]|]
2018-10-29 14:26:08 - let f:array<array<Vector>> = d
2018-10-29 14:26:13 - type WetGrassSprinklerRainModel () =
2018-10-29 14:26:13 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 14:26:13 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 14:26:13 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 14:26:13 -     let priors = this.BuildPriors ranges
2018-10-29 14:26:13 -     let parameters = this.BuildDistributionParameters ranges priors
2018-10-29 14:26:13 -     let rvs = this.BuildRandomVariables rN parameters
2018-10-29 14:26:13 -     do printfn "Test"
2018-10-29 14:26:13 -     // Methods
2018-10-29 14:26:13 -     member  this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 14:26:13 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 14:26:13 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 14:26:13 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 14:26:13 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 14:26:13 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 14:26:13 -     member   this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 14:26:13 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 14:26:13 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 14:26:13 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 14:26:13 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 14:26:13 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 14:26:13 -         probCloudy.SetValueRange(rg.c)
2018-10-29 14:26:13 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 14:26:13 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 14:26:13 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 14:26:13 -         cptRain.SetValueRange(rg.r)
2018-10-29 14:26:13 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 14:26:13 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 14:26:13 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 14:26:13 -     member   this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 14:26:13 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 14:26:13 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 14:26:13 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 14:26:13 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 14:26:13 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 14:26:13 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 14:26:15 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-29 14:26:15 -    ThisAssembly
2018-10-29 14:26:15 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-29 14:26:15 -    ThisAssembly
2018-10-29 14:26:15 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-29 14:26:15 -    ThisAssembly
2018-10-29 14:27:43 - type WetGrassSprinklerRainModel() =
2018-10-29 14:27:43 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 14:27:43 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 14:27:43 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 14:27:43 -     let priors = this.BuildPriors ranges
2018-10-29 14:27:43 -     let parameters = this.BuildDistributionParameters ranges priors
2018-10-29 14:27:43 -     let rvs = this.BuildRandomVariables rN parameters
2018-10-29 14:27:43 -     do printfn "Test"
2018-10-29 14:27:43 -     // Methods
2018-10-29 14:27:43 -     member  this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 14:27:43 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 14:27:43 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 14:27:43 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 14:27:43 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 14:27:43 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 14:27:43 -     member   this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 14:27:43 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 14:27:43 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 14:27:43 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 14:27:43 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 14:27:43 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 14:27:43 -         probCloudy.SetValueRange(rg.c)
2018-10-29 14:27:43 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 14:27:43 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 14:27:43 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 14:27:43 -         cptRain.SetValueRange(rg.r)
2018-10-29 14:27:43 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 14:27:43 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 14:27:43 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 14:27:43 -     member   this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 14:27:43 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 14:27:43 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 14:27:43 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 14:27:43 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 14:27:43 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 14:27:43 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 14:27:45 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-29 14:27:45 -    ThisAssembly
2018-10-29 14:27:45 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-29 14:27:45 -    ThisAssembly
2018-10-29 14:27:45 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-29 14:27:45 -    ThisAssembly
2018-10-29 14:29:16 - type WetGrassSprinklerRainModel() =
2018-10-29 14:29:16 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 14:29:16 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 14:29:16 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 14:29:16 -     let priors = this.BuildPriors ranges
2018-10-29 14:29:16 -     let parameters = this.BuildDistributionParameters ranges priors
2018-10-29 14:29:16 -     let rvs = this.BuildRandomVariables rN parameters
2018-10-29 14:29:16 -     // Methods
2018-10-29 14:29:16 -     member this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 14:29:16 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 14:29:16 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 14:29:16 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 14:29:16 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 14:29:16 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 14:29:16 -     
2018-10-29 14:29:17 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-29 14:29:17 -    ThisAssembly
2018-10-29 14:29:17 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-29 14:29:17 -    ThisAssembly
2018-10-29 14:29:17 - The value, namespace, type or module 'this' is not defined. Maybe you want one of the following:
2018-10-29 14:29:17 -    ThisAssembly
2018-10-29 14:30:55 - type MyClass(intParam:int, strParam:string) = 
2018-10-29 14:30:55 -     member this.Two = 2
2018-10-29 14:30:55 -     member this.Square x = x * x
2018-10-29 14:31:23 - type MyClass() = 
2018-10-29 14:31:23 -     member this.Two = 2
2018-10-29 14:31:23 -     member this.Square x = x * x
2018-10-29 14:32:59 - type WetGrassSprinklerRainModel() =
2018-10-29 14:32:59 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 14:32:59 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 14:32:59 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 14:32:59 -     let priors = BuildPriors ranges
2018-10-29 14:32:59 -     let parameters = BuildDistributionParameters ranges priors
2018-10-29 14:32:59 -     let rvs = BuildRandomVariables rN parameters
2018-10-29 14:32:59 -     // Methods
2018-10-29 14:32:59 -     member this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 14:32:59 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 14:32:59 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 14:32:59 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 14:32:59 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 14:32:59 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 14:32:59 -     member   this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 14:32:59 -             let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 14:32:59 -             let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 14:32:59 -             let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 14:32:59 -             let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 14:32:59 -                                     Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 14:32:59 -             probCloudy.SetValueRange(rg.c)
2018-10-29 14:32:59 -             cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 14:32:59 -             cptSprinkler.SetValueRange(rg.s)
2018-10-29 14:32:59 -             cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 14:32:59 -             cptRain.SetValueRange(rg.r)
2018-10-29 14:32:59 -             cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 14:32:59 -             cptWetGrass.SetValueRange(rg.w)
2018-10-29 14:32:59 -             {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 14:32:59 -         member   this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 14:32:59 -             let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 14:32:59 -             vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 14:32:59 -             let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 14:32:59 -             let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 14:32:59 -             let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 14:32:59 -             {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 14:33:00 - Unexpected symbol '{' in member definition
2018-10-29 14:33:00 - parse error
2018-10-29 14:34:07 - type WetGrassSprinklerRainModel() =
2018-10-29 14:34:07 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 14:34:07 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 14:34:07 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 14:34:07 -     let priors = BuildPriors ranges
2018-10-29 14:34:07 -     let parameters = BuildDistributionParameters ranges priors
2018-10-29 14:34:07 -     let rvs = BuildRandomVariables rN parameters
2018-10-29 14:34:07 -     // Methods
2018-10-29 14:34:07 -     member this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 14:34:07 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 14:34:07 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 14:34:07 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 14:34:07 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 14:34:07 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 14:34:07 -     member   this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 14:34:07 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 14:34:07 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 14:34:07 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 14:34:07 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 14:34:07 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 14:34:07 -         probCloudy.SetValueRange(rg.c)
2018-10-29 14:34:07 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 14:34:07 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 14:34:07 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 14:34:07 -         cptRain.SetValueRange(rg.r)
2018-10-29 14:34:07 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 14:34:07 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 14:34:07 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 14:34:07 -     member   this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 14:34:07 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 14:34:07 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 14:34:07 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 14:34:07 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 14:34:07 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 14:34:07 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 14:34:09 - Possible incorrect indentation: this token is offside of context started at position (14:74). Try indenting this token further or using standard formatting conventions.
2018-10-29 14:34:09 - Possible incorrect indentation: this token is offside of context started at position (14:74). Try indenting this token further or using standard formatting conventions.
2018-10-29 14:34:09 - The value or constructor 'BuildPriors' is not defined. Maybe you want one of the following:
2018-10-29 14:34:09 -    buildPriors
2018-10-29 14:34:09 - The value or constructor 'BuildDistributionParameters' is not defined. Maybe you want one of the following:
2018-10-29 14:34:09 -    buildDistributionParameters
2018-10-29 14:34:09 -    DistributionParameters
2018-10-29 14:34:09 - The value or constructor 'BuildRandomVariables' is not defined. Maybe you want one of the following:
2018-10-29 14:34:09 -    buildRandomVariables
2018-10-29 14:34:09 -    buildFormatElement
2018-10-29 14:34:09 -    buildFormatComment
2018-10-29 14:34:09 -    RandomVariables
2018-10-29 14:34:09 -    RandomVariable
2018-10-29 14:34:28 - type WetGrassSprinklerRainModel() =
2018-10-29 14:34:28 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 14:34:28 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 14:34:28 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 14:34:28 -     let priors = BuildPriors ranges
2018-10-29 14:34:28 -     let parameters = BuildDistributionParameters ranges priors
2018-10-29 14:34:28 -     let rvs = BuildRandomVariables rN parameters
2018-10-29 14:34:28 -     // Methods
2018-10-29 14:34:28 -     member this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 14:34:28 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 14:34:28 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 14:34:28 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 14:34:28 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 14:34:28 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 14:34:28 -     member   this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 14:34:28 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 14:34:28 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 14:34:28 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 14:34:28 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 14:34:28 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 14:34:28 -         probCloudy.SetValueRange(rg.c)
2018-10-29 14:34:28 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 14:34:28 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 14:34:28 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 14:34:28 -         cptRain.SetValueRange(rg.r)
2018-10-29 14:34:28 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 14:34:28 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 14:34:28 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 14:34:28 -     member   this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 14:34:28 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 14:34:28 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 14:34:28 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 14:34:28 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 14:34:28 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 14:34:28 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 14:34:29 - The value or constructor 'BuildPriors' is not defined. Maybe you want one of the following:
2018-10-29 14:34:29 -    buildPriors
2018-10-29 14:34:29 - The value or constructor 'BuildDistributionParameters' is not defined. Maybe you want one of the following:
2018-10-29 14:34:29 -    buildDistributionParameters
2018-10-29 14:34:29 -    DistributionParameters
2018-10-29 14:34:29 - The value or constructor 'BuildRandomVariables' is not defined. Maybe you want one of the following:
2018-10-29 14:34:29 -    buildRandomVariables
2018-10-29 14:34:29 -    buildFormatElement
2018-10-29 14:34:29 -    buildFormatComment
2018-10-29 14:34:29 -    RandomVariables
2018-10-29 14:34:29 -    RandomVariable
2018-10-29 14:36:26 - type WetGrassSprinklerRainModel() as this =
2018-10-29 14:36:26 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 14:36:26 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 14:36:26 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 14:36:26 -     let priors = this.BuildPriors ranges
2018-10-29 14:36:26 -     let parameters = this.BuildDistributionParameters ranges priors
2018-10-29 14:36:26 -     let rvs = this.BuildRandomVariables rN parameters
2018-10-29 14:36:26 -     // Methods
2018-10-29 14:36:26 -     member this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 14:36:26 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 14:36:26 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 14:36:26 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 14:36:26 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 14:36:26 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 14:36:26 -     member   this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 14:36:26 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 14:36:26 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 14:36:26 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 14:36:26 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 14:36:26 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 14:36:26 -         probCloudy.SetValueRange(rg.c)
2018-10-29 14:36:26 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 14:36:26 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 14:36:26 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 14:36:26 -         cptRain.SetValueRange(rg.r)
2018-10-29 14:36:26 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 14:36:26 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 14:36:26 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 14:36:26 -     member   this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 14:36:26 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 14:36:26 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 14:36:26 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 14:36:26 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 14:36:26 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 14:36:26 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 14:37:05 - type WetGrassSprinklerRainModel() as this =
2018-10-29 14:37:05 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 14:37:05 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 14:37:05 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 14:37:05 -     let priors = this.BuildPriors ranges
2018-10-29 14:37:05 -     let parameters = this.BuildDistributionParameters ranges priors
2018-10-29 14:37:05 -     let rvs = this.BuildRandomVariables rN parameters
2018-10-29 14:37:05 -     // Methods
2018-10-29 14:37:05 -     member private this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 14:37:05 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 14:37:05 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 14:37:05 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 14:37:05 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 14:37:05 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 14:37:05 -     member private this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 14:37:05 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 14:37:05 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 14:37:05 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 14:37:05 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 14:37:05 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 14:37:05 -         probCloudy.SetValueRange(rg.c)
2018-10-29 14:37:05 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 14:37:05 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 14:37:05 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 14:37:05 -         cptRain.SetValueRange(rg.r)
2018-10-29 14:37:05 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 14:37:05 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 14:37:05 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 14:37:05 -     member   this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 14:37:05 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 14:37:05 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 14:37:05 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 14:37:05 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 14:37:05 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 14:37:05 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 14:38:47 - let model = WetGrassSprinklerRainModel()
2018-10-29 14:38:47 - Expression evaluation failed: The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.
2018-10-29 14:38:47 - InvalidOperationExceptionThe initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.
2018-10-29 14:38:47 -   at Microsoft.FSharp.Core.LanguagePrimitives+IntrinsicFunctions.FailInit () [0x00014] in <5a7d678a904cf4daa74503838a677d5a>:0 
2018-10-29 14:38:47 -   at FSI_0222+WetGrassSprinklerRainModel.BuildPriors (FSI_0181+Ranges rg) [0x00015] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-29 14:38:47 -   at FSI_0222+WetGrassSprinklerRainModel..ctor () [0x000b6] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-29 14:38:47 -   at <StartupCode$FSI_0223>.$FSI_0223.main@ () [0x00000] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-29 14:38:47 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-29 14:38:47 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-29 15:36:21 - module WetGrassSprinklerRainModel =
2018-10-29 15:36:21 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 15:36:21 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 15:36:21 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 15:36:21 -     
2018-10-29 15:36:21 -     // Functions
2018-10-29 15:36:21 -     let addChildFromOneParent 
2018-10-29 15:36:21 -             (parent:RandomVariable) 
2018-10-29 15:36:21 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 15:36:21 -         let r = parent.Range
2018-10-29 15:36:21 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 15:36:21 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 15:36:21 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 15:36:21 -         child
2018-10-29 15:36:21 -         
2018-10-29 15:36:21 -     let AddChildFromTwoParents 
2018-10-29 15:36:21 -             (parent1:RandomVariable) 
2018-10-29 15:36:21 -             (parent2:RandomVariable) 
2018-10-29 15:36:21 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 15:36:21 -         let r = parent1.Range
2018-10-29 15:36:21 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 15:36:21 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 15:36:21 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 15:36:21 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 15:36:21 -         child    
2018-10-29 15:36:21 -     
2018-10-29 15:36:21 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 15:36:21 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 15:36:21 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 15:36:21 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 15:36:21 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 15:36:21 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 15:36:21 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 15:36:21 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 15:36:21 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 15:36:21 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 15:36:21 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 15:36:21 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 15:36:21 -         probCloudy.SetValueRange(rg.c)
2018-10-29 15:36:21 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 15:36:21 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 15:36:21 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 15:36:21 -         cptRain.SetValueRange(rg.r)
2018-10-29 15:36:21 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 15:36:21 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 15:36:21 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 15:36:21 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 15:36:21 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 15:36:21 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 15:36:21 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 15:36:21 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 15:36:21 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 15:36:21 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 15:36:21 -         
2018-10-29 15:36:21 -     let priors = buildPriors ranges
2018-10-29 15:36:21 -     let parameters = buildDistributionParameters ranges priors
2018-10-29 15:36:21 -     let rvs = buildRandomVariables rN parameters
2018-10-29 15:36:24 - The value or constructor 'addChildFromTwoParents' is not defined. Maybe you want one of the following:
2018-10-29 15:36:24 -    AddChildFromTwoParents
2018-10-29 15:36:24 -    AddChildFromOneParent
2018-10-29 15:36:24 -    addChildFromOneParent
2018-10-29 15:36:24 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-29 15:36:48 - module WetGrassSprinklerRainModel =
2018-10-29 15:36:48 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 15:36:48 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 15:36:48 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 15:36:48 -     
2018-10-29 15:36:48 -     // Functions
2018-10-29 15:36:48 -     let addChildFromOneParent 
2018-10-29 15:36:48 -             (parent:RandomVariable) 
2018-10-29 15:36:48 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 15:36:48 -         let r = parent.Range
2018-10-29 15:36:48 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 15:36:48 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 15:36:48 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 15:36:48 -         child
2018-10-29 15:36:48 -         
2018-10-29 15:36:48 -     let addChildFromTwoParents 
2018-10-29 15:36:48 -             (parent1:RandomVariable) 
2018-10-29 15:36:48 -             (parent2:RandomVariable) 
2018-10-29 15:36:48 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 15:36:48 -         let r = parent1.Range
2018-10-29 15:36:48 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 15:36:48 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 15:36:48 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 15:36:48 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 15:36:48 -         child    
2018-10-29 15:36:48 -     
2018-10-29 15:36:48 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 15:36:48 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 15:36:48 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 15:36:48 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 15:36:48 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 15:36:48 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 15:36:48 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 15:36:48 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 15:36:48 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 15:36:48 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 15:36:48 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 15:36:48 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 15:36:48 -         probCloudy.SetValueRange(rg.c)
2018-10-29 15:36:48 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 15:36:48 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 15:36:48 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 15:36:48 -         cptRain.SetValueRange(rg.r)
2018-10-29 15:36:48 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 15:36:48 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 15:36:48 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 15:36:48 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 15:36:48 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 15:36:48 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 15:36:48 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 15:36:48 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 15:36:48 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 15:36:48 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 15:36:48 -         
2018-10-29 15:36:48 -     let priors = buildPriors ranges
2018-10-29 15:36:48 -     let parameters = buildDistributionParameters ranges priors
2018-10-29 15:36:48 -     let rvs = buildRandomVariables rN parameters
2018-10-29 15:41:34 - module WetGrassSprinklerRainModel =
2018-10-29 15:41:34 -     
2018-10-29 15:41:34 -     // Functions
2018-10-29 15:41:34 -     let addChildFromOneParent 
2018-10-29 15:41:34 -             (parent:RandomVariable) 
2018-10-29 15:41:34 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 15:41:34 -         let r = parent.Range
2018-10-29 15:41:34 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 15:41:34 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 15:41:34 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 15:41:34 -         child
2018-10-29 15:41:34 -         
2018-10-29 15:41:34 -     let addChildFromTwoParents 
2018-10-29 15:41:34 -             (parent1:RandomVariable) 
2018-10-29 15:41:34 -             (parent2:RandomVariable) 
2018-10-29 15:41:34 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 15:41:34 -         let r = parent1.Range
2018-10-29 15:41:34 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 15:41:34 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 15:41:34 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 15:41:34 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 15:41:34 -         child    
2018-10-29 15:41:34 -     
2018-10-29 15:41:34 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 15:41:34 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 15:41:34 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 15:41:34 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 15:41:34 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 15:41:34 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 15:41:34 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 15:41:34 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 15:41:34 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 15:41:34 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 15:41:34 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 15:41:34 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 15:41:34 -         probCloudy.SetValueRange(rg.c)
2018-10-29 15:41:34 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 15:41:34 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 15:41:34 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 15:41:34 -         cptRain.SetValueRange(rg.r)
2018-10-29 15:41:34 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 15:41:34 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 15:41:34 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 15:41:34 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 15:41:34 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 15:41:34 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 15:41:34 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 15:41:34 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 15:41:34 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 15:41:34 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 15:41:34 -         
2018-10-29 15:41:34 -     let create () =
2018-10-29 15:41:34 -         let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 15:41:34 -         let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 15:41:34 -         let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 15:41:34 -         let priors = buildPriors ranges
2018-10-29 15:41:34 -         let parameters = buildDistributionParameters ranges priors
2018-10-29 15:41:34 -         let rvs = buildRandomVariables rN parameters
2018-10-29 15:41:34 -         rvs
2018-10-29 15:41:46 - let model = WetGrassSprinklerRainModel.create ()
2018-10-29 15:41:57 - model
2018-10-29 15:48:08 - open WetGrassSprinklerRainModel
2018-10-29 15:48:08 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 15:48:08 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 15:48:08 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 15:48:08 - let priors = buildPriors ranges
2018-10-29 15:48:08 - let parameters = buildDistributionParameters ranges priors
2018-10-29 15:48:08 - let rvs = buildRandomVariables rN parameters
2018-10-29 15:49:56 - type WetGrassSprinklerRainModel() as this =
2018-10-29 15:49:56 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 15:49:56 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 15:49:56 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 15:49:56 -     let priors = this.BuildPriors ranges
2018-10-29 15:49:56 -     let parameters = this.BuildDistributionParameters ranges priors
2018-10-29 15:49:56 -     let rvs = this.BuildRandomVariables rN parameters
2018-10-29 15:49:56 -     // Methods
2018-10-29 15:49:56 -     // Private methods used by constructor
2018-10-29 15:49:56 -     member private this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 15:49:56 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 15:49:56 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 15:49:56 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 15:49:56 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 15:49:56 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 15:49:56 -     member private this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 15:49:56 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 15:49:56 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 15:49:56 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 15:49:56 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 15:49:56 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 15:49:56 -         probCloudy.SetValueRange(rg.c)
2018-10-29 15:49:56 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 15:49:56 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 15:49:56 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 15:49:56 -         cptRain.SetValueRange(rg.r)
2018-10-29 15:49:56 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 15:49:56 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 15:49:56 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 15:49:56 -     member private  this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 15:49:56 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 15:49:56 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 15:49:56 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 15:49:56 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 15:49:56 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 15:49:56 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 15:50:18 - let model = WetGrassSprinklerRainModel ()
2018-10-29 15:50:19 - Expression evaluation failed: The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.
2018-10-29 15:50:19 - InvalidOperationExceptionThe initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.
2018-10-29 15:50:19 -   at Microsoft.FSharp.Core.LanguagePrimitives+IntrinsicFunctions.FailInit () [0x00014] in <5a7d678a904cf4daa74503838a677d5a>:0 
2018-10-29 15:50:19 -   at FSI_0231+WetGrassSprinklerRainModel.BuildPriors (FSI_0181+Ranges rg) [0x00015] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-29 15:50:19 -   at FSI_0231+WetGrassSprinklerRainModel..ctor () [0x000b6] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-29 15:50:19 -   at <StartupCode$FSI_0232>.$FSI_0232.main@ () [0x00000] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-29 15:50:19 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-29 15:50:19 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-29 15:51:56 - type WetGrassSprinklerRainModel() as this =
2018-10-29 15:51:56 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 15:51:56 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 15:51:56 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 15:51:56 -     let priors = this.BuildPriors ranges
2018-10-29 15:51:56 -     let parameters = this.BuildDistributionParameters ranges priors
2018-10-29 15:51:56 -     let rvs = this.BuildRandomVariables rN parameters
2018-10-29 15:51:56 -     // Methods
2018-10-29 15:51:56 -     // Private methods used by constructor
2018-10-29 15:51:56 -     member private this.AddChildFromOneParent 
2018-10-29 15:51:56 -             (parent:RandomVariable) 
2018-10-29 15:51:56 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 15:51:56 -         let r = parent.Range
2018-10-29 15:51:56 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 15:51:56 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 15:51:56 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 15:51:56 -         child
2018-10-29 15:51:56 -         
2018-10-29 15:51:56 -     member private this.AddChildFromTwoParents 
2018-10-29 15:51:56 -             (parent1:RandomVariable) 
2018-10-29 15:51:56 -             (parent2:RandomVariable) 
2018-10-29 15:51:56 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 15:51:56 -         let r = parent1.Range
2018-10-29 15:51:56 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 15:51:56 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 15:51:56 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 15:51:56 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 15:51:56 -         child    
2018-10-29 15:51:56 -         
2018-10-29 15:51:56 -     member private this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 15:51:56 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 15:51:56 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 15:51:56 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 15:51:56 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 15:51:56 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 15:51:56 -     member private this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 15:51:56 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 15:51:56 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 15:51:56 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 15:51:56 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 15:51:56 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 15:51:56 -         probCloudy.SetValueRange(rg.c)
2018-10-29 15:51:56 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 15:51:56 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 15:51:56 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 15:51:56 -         cptRain.SetValueRange(rg.r)
2018-10-29 15:51:56 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 15:51:56 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 15:51:56 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 15:51:56 -     member private  this.BuildRandombbVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 15:51:56 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 15:51:56 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 15:51:56 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 15:51:56 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 15:51:56 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 15:51:56 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 15:51:58 - The field, constructor or member 'BuildRandomVariables' is not defined. Maybe you want one of the following:
2018-10-29 15:51:58 -    BuildRandombbVariables
2018-10-29 15:52:11 - type WetGrassSprinklerRainModel() as this =
2018-10-29 15:52:11 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 15:52:11 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 15:52:11 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 15:52:11 -     let priors = this.BuildPriors ranges
2018-10-29 15:52:11 -     let parameters = this.BuildDistributionParameters ranges priors
2018-10-29 15:52:11 -     let rvs = this.BuildRandomVariables rN parameters
2018-10-29 15:52:11 -     // Methods
2018-10-29 15:52:11 -     // Private methods used by constructor
2018-10-29 15:52:11 -     member private this.AddChildFromOneParent 
2018-10-29 15:52:11 -             (parent:RandomVariable) 
2018-10-29 15:52:11 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 15:52:11 -         let r = parent.Range
2018-10-29 15:52:11 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 15:52:11 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 15:52:11 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 15:52:11 -         child
2018-10-29 15:52:11 -         
2018-10-29 15:52:11 -     member private this.AddChildFromTwoParents 
2018-10-29 15:52:11 -             (parent1:RandomVariable) 
2018-10-29 15:52:11 -             (parent2:RandomVariable) 
2018-10-29 15:52:11 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 15:52:11 -         let r = parent1.Range
2018-10-29 15:52:11 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 15:52:11 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 15:52:11 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 15:52:11 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 15:52:11 -         child    
2018-10-29 15:52:11 -         
2018-10-29 15:52:11 -     member private this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 15:52:11 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 15:52:11 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 15:52:11 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 15:52:11 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 15:52:11 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 15:52:11 -     member private this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 15:52:11 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 15:52:11 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 15:52:11 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 15:52:11 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 15:52:11 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 15:52:11 -         probCloudy.SetValueRange(rg.c)
2018-10-29 15:52:11 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 15:52:11 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 15:52:11 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 15:52:11 -         cptRain.SetValueRange(rg.r)
2018-10-29 15:52:11 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 15:52:11 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 15:52:11 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 15:52:11 -     member private  this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 15:52:11 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 15:52:11 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 15:52:11 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 15:52:11 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 15:52:11 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 15:52:11 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 15:52:27 - type WetGrassSprinklerRainModel() as this =
2018-10-29 15:52:27 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 15:52:27 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 15:52:27 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 15:52:27 -     let priors = this.BuildPriors ranges
2018-10-29 15:52:27 -     let parameters = this.BuildDistributionParameters ranges priors
2018-10-29 15:52:27 -     let rvs = this.BuildRandomVariables rN parameters
2018-10-29 15:52:27 -     // Private methods used by constructor
2018-10-29 15:52:27 -     member private this.AddChildFromOneParent 
2018-10-29 15:52:27 -             (parent:RandomVariable) 
2018-10-29 15:52:27 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 15:52:27 -         let r = parent.Range
2018-10-29 15:52:27 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 15:52:27 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 15:52:27 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 15:52:27 -         child
2018-10-29 15:52:27 -         
2018-10-29 15:52:27 -     member private this.AddChildFromTwoParents 
2018-10-29 15:52:27 -             (parent1:RandomVariable) 
2018-10-29 15:52:27 -             (parent2:RandomVariable) 
2018-10-29 15:52:27 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 15:52:27 -         let r = parent1.Range
2018-10-29 15:52:27 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 15:52:27 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 15:52:27 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 15:52:27 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 15:52:27 -         child    
2018-10-29 15:52:27 -         
2018-10-29 15:52:27 -     member private this.BuildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 15:52:27 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 15:52:27 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 15:52:27 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 15:52:27 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 15:52:27 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 15:52:27 -     member private this.BuildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 15:52:27 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 15:52:27 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 15:52:27 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 15:52:27 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 15:52:27 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 15:52:27 -         probCloudy.SetValueRange(rg.c)
2018-10-29 15:52:27 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 15:52:27 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 15:52:27 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 15:52:27 -         cptRain.SetValueRange(rg.r)
2018-10-29 15:52:27 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 15:52:27 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 15:52:27 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 15:52:27 -     member private  this.BuildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 15:52:27 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 15:52:27 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 15:52:27 -         let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 15:52:27 -         let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 15:52:27 -         let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 15:52:27 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 15:52:30 - let model = WetGrassSprinklerRainModel ()
2018-10-29 15:52:30 - Expression evaluation failed: The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.
2018-10-29 15:52:30 - InvalidOperationExceptionThe initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.
2018-10-29 15:52:30 -   at Microsoft.FSharp.Core.LanguagePrimitives+IntrinsicFunctions.FailInit () [0x00014] in <5a7d678a904cf4daa74503838a677d5a>:0 
2018-10-29 15:52:30 -   at FSI_0235+WetGrassSprinklerRainModel.BuildPriors (FSI_0181+Ranges rg) [0x00015] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-29 15:52:30 -   at FSI_0235+WetGrassSprinklerRainModel..ctor () [0x000b6] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-29 15:52:30 -   at <StartupCode$FSI_0236>.$FSI_0236.main@ () [0x00000] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-29 15:52:30 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-29 15:52:30 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-29 15:53:23 - let model = WetGrassSprinklerRainModel ()
2018-10-29 15:53:23 - Expression evaluation failed: The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.
2018-10-29 15:53:23 - InvalidOperationExceptionThe initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.
2018-10-29 15:53:23 -   at Microsoft.FSharp.Core.LanguagePrimitives+IntrinsicFunctions.FailInit () [0x00014] in <5a7d678a904cf4daa74503838a677d5a>:0 
2018-10-29 15:53:23 -   at FSI_0235+WetGrassSprinklerRainModel.BuildPriors (FSI_0181+Ranges rg) [0x00015] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-29 15:53:23 -   at FSI_0235+WetGrassSprinklerRainModel..ctor () [0x000b6] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-29 15:53:23 -   at <StartupCode$FSI_0237>.$FSI_0237.main@ () [0x00000] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-29 15:53:23 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-29 15:53:23 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-29 16:07:43 - type WetGrassSprinklerRainModel() as this =
2018-10-29 16:07:43 -     // Private fields
2018-10-29 16:07:43 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:07:43 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:07:43 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:07:43 -     let priors = this.BuildPriors ranges
2018-10-29 16:07:43 -     let parameters = this.BuildDistributionParameters ranges priors
2018-10-29 16:07:43 -     let primaryRandomVariables = this.BuildRandomVariables rN parameters
2018-10-29 16:07:43 -     
2018-10-29 16:07:43 -     // Properties
2018-10-29 16:07:43 -     member this.Ranges:Ranges = ranges
2018-10-29 16:07:43 -     member this.NumberOfExamples = numberOfExamples
2018-10-29 16:07:43 -     member this.RangeN = rN
2018-10-29 16:07:43 -     member this.Priors = priors
2018-10-29 16:07:43 -     mamber this.Parameters = parameters
2018-10-29 16:07:43 -     member this.PrimaryRandomVariables = primaryRandomVariables
2018-10-29 16:07:43 -     // Private methods used by constructor
2018-10-29 16:07:43 -     let addChildFromOneParent 
2018-10-29 16:07:43 -             (parent:RandomVariable) 
2018-10-29 16:07:43 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:07:43 -         let r = parent.Range
2018-10-29 16:07:43 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:07:43 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:07:43 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:07:43 -         child
2018-10-29 16:07:43 -         
2018-10-29 16:07:43 -     let addChildFromTwoParents 
2018-10-29 16:07:43 -             (parent1:RandomVariable) 
2018-10-29 16:07:43 -             (parent2:RandomVariable) 
2018-10-29 16:07:43 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:07:43 -         let r = parent1.Range
2018-10-29 16:07:43 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:07:43 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:07:43 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:07:43 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:07:43 -         child    
2018-10-29 16:07:43 -         
2018-10-29 16:07:43 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:07:43 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:07:43 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:07:43 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:07:43 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:07:43 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:07:43 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:07:43 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:07:43 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:07:43 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:07:43 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:07:43 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:07:43 -         probCloudy.SetValueRange(rg.c)
2018-10-29 16:07:43 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:07:43 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:07:43 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:07:43 -         cptRain.SetValueRange(rg.r)
2018-10-29 16:07:43 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:07:43 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:07:43 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:07:43 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:07:43 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:07:43 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:07:43 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:07:43 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:07:43 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:07:43 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:07:43 -         
2018-10-29 16:07:43 -     member this.WetGrassSprinklerRainModel () 
2018-10-29 16:07:43 -         let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:07:43 -         let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:07:43 -         let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:07:43 -         let priors = buildPriors ranges
2018-10-29 16:07:43 -         let parameters = buildDistributionParameters ranges priors
2018-10-29 16:07:43 -         let rvs = buildRandomVariables rN parameters
2018-10-29 16:07:46 - Unexpected identifier in member definition
2018-10-29 16:07:46 - Unexpected keyword 'let' or 'use' in member definition. Expected 'with', '=' or other token.
2018-10-29 16:07:46 - Unexpected keyword 'let' or 'use' in binding. Expected incomplete structured construct at or before this point or other token.
2018-10-29 16:07:46 - Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.
2018-10-29 16:07:46 - Possible incorrect indentation: this token is offside of context started at position (71:9). Try indenting this token further or using standard formatting conventions.
2018-10-29 16:07:46 - Possible incorrect indentation: this token is offside of context started at position (72:9). Try indenting this token further or using standard formatting conventions.
2018-10-29 16:07:46 - Possible incorrect indentation: this token is offside of context started at position (73:9). Try indenting this token further or using standard formatting conventions.
2018-10-29 16:07:46 - Possible incorrect indentation: this token is offside of context started at position (74:9). Try indenting this token further or using standard formatting conventions.
2018-10-29 16:07:46 - Incomplete structured construct at or before this point in type definition. Expected incomplete structured construct at or before this point or other token.
2018-10-29 16:07:46 - 'let' and 'do' bindings must come before member and interface definitions in type definitions
2018-10-29 16:07:46 - The field, constructor or member 'BuildPriors' is not defined.
2018-10-29 16:07:46 - The field, constructor or member 'BuildDistributionParameters' is not defined.
2018-10-29 16:07:46 - The field, constructor or member 'BuildRandomVariables' is not defined. Maybe you want one of the following:
2018-10-29 16:07:46 -    PrimaryRandomVariables
2018-10-29 16:09:23 - type WetGrassSprinklerRainModel() as this =
2018-10-29 16:09:23 -     // Private fields
2018-10-29 16:09:23 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:09:23 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:09:23 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:09:23 -     let priors = this.BuildPriors ranges
2018-10-29 16:09:23 -     let parameters = this.BuildDistributionParameters ranges priors
2018-10-29 16:09:23 -     let primaryRandomVariables = this.BuildRandomVariables rN parameters
2018-10-29 16:09:23 -     
2018-10-29 16:09:23 -     // Properties
2018-10-29 16:09:23 -     member this.Ranges:Ranges = ranges
2018-10-29 16:09:23 -     member this.NumberOfExamples = numberOfExamples
2018-10-29 16:09:23 -     member this.RangeN = rN
2018-10-29 16:09:23 -     member this.Priors = priors
2018-10-29 16:09:23 -     mamber this.Parameters = parameters
2018-10-29 16:09:23 -     member this.PrimaryRandomVariables = primaryRandomVariables
2018-10-29 16:09:23 -     // Private methods used by constructor
2018-10-29 16:09:23 -     let addChildFromOneParent 
2018-10-29 16:09:23 -             (parent:RandomVariable) 
2018-10-29 16:09:23 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:09:23 -         let r = parent.Range
2018-10-29 16:09:23 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:09:23 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:09:23 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:09:23 -         child
2018-10-29 16:09:23 -         
2018-10-29 16:09:23 -     let addChildFromTwoParents 
2018-10-29 16:09:23 -             (parent1:RandomVariable) 
2018-10-29 16:09:23 -             (parent2:RandomVariable) 
2018-10-29 16:09:23 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:09:23 -         let r = parent1.Range
2018-10-29 16:09:23 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:09:23 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:09:23 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:09:23 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:09:23 -         child    
2018-10-29 16:09:23 -         
2018-10-29 16:09:23 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:09:23 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:09:23 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:09:23 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:09:23 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:09:23 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:09:23 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:09:23 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:09:23 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:09:23 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:09:23 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:09:23 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:09:23 -         probCloudy.SetValueRange(rg.c)
2018-10-29 16:09:23 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:09:23 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:09:23 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:09:23 -         cptRain.SetValueRange(rg.r)
2018-10-29 16:09:23 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:09:23 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:09:23 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:09:23 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:09:23 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:09:23 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:09:23 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:09:23 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:09:23 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:09:23 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:09:23 -         
2018-10-29 16:09:23 -     
2018-10-29 16:09:24 - Unexpected identifier in member definition
2018-10-29 16:09:24 - 'let' and 'do' bindings must come before member and interface definitions in type definitions
2018-10-29 16:09:24 - The field, constructor or member 'BuildPriors' is not defined.
2018-10-29 16:09:24 - The field, constructor or member 'BuildDistributionParameters' is not defined.
2018-10-29 16:09:24 - The field, constructor or member 'BuildRandomVariables' is not defined. Maybe you want one of the following:
2018-10-29 16:09:24 -    PrimaryRandomVariables
2018-10-29 16:10:11 - type WetGrassSprinklerRainModel() as this =
2018-10-29 16:10:11 -     // Private fields
2018-10-29 16:10:11 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:10:11 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:10:11 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:10:11 -     let priors = this.BuildPriors ranges
2018-10-29 16:10:11 -     let parameters = this.BuildDistributionParameters ranges priors
2018-10-29 16:10:11 -     let primaryRandomVariables = this.BuildRandomVariables rN parameters
2018-10-29 16:10:11 -     // Private methods used by constructor
2018-10-29 16:10:11 -     let addChildFromOneParent 
2018-10-29 16:10:11 -             (parent:RandomVariable) 
2018-10-29 16:10:11 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:10:11 -         let r = parent.Range
2018-10-29 16:10:11 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:10:11 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:10:11 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:10:11 -         child
2018-10-29 16:10:11 -         
2018-10-29 16:10:11 -     let addChildFromTwoParents 
2018-10-29 16:10:11 -             (parent1:RandomVariable) 
2018-10-29 16:10:11 -             (parent2:RandomVariable) 
2018-10-29 16:10:11 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:10:11 -         let r = parent1.Range
2018-10-29 16:10:11 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:10:11 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:10:11 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:10:11 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:10:11 -         child    
2018-10-29 16:10:11 -         
2018-10-29 16:10:11 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:10:11 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:10:11 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:10:11 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:10:11 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:10:11 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:10:11 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:10:11 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:10:11 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:10:11 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:10:11 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:10:11 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:10:11 -         probCloudy.SetValueRange(rg.c)
2018-10-29 16:10:11 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:10:11 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:10:11 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:10:11 -         cptRain.SetValueRange(rg.r)
2018-10-29 16:10:11 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:10:11 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:10:11 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:10:11 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:10:11 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:10:11 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:10:11 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:10:11 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:10:11 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:10:11 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:10:11 -      
2018-10-29 16:10:11 -     // Properties
2018-10-29 16:10:11 -     member this.Ranges:Ranges = ranges
2018-10-29 16:10:11 -     member this.NumberOfExamples = numberOfExamples
2018-10-29 16:10:11 -     member this.RangeN = rN
2018-10-29 16:10:11 -     member this.Priors = priors
2018-10-29 16:10:11 -     mamber this.Parameters = parameters
2018-10-29 16:10:11 -     member this.PrimaryRandomVariables = primaryRandomVariables
2018-10-29 16:10:11 -     
2018-10-29 16:10:12 - Unexpected identifier in member definition
2018-10-29 16:10:12 - The field, constructor or member 'BuildPriors' is not defined.
2018-10-29 16:10:12 - The field, constructor or member 'BuildDistributionParameters' is not defined.
2018-10-29 16:10:12 - The field, constructor or member 'BuildRandomVariables' is not defined. Maybe you want one of the following:
2018-10-29 16:10:12 -    PrimaryRandomVariables
2018-10-29 16:11:02 - type WetGrassSprinklerRainModel() as this =
2018-10-29 16:11:02 -     // Private fields
2018-10-29 16:11:02 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:11:02 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:11:02 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:11:02 -     let priors = buildPriors ranges
2018-10-29 16:11:02 -     let parameters = buildDistributionParameters ranges priors
2018-10-29 16:11:02 -     let primaryRandomVariables = buildRandomVariables rN parameters
2018-10-29 16:11:02 -     // Private methods used by constructor
2018-10-29 16:11:02 -     let addChildFromOneParent 
2018-10-29 16:11:02 -             (parent:RandomVariable) 
2018-10-29 16:11:02 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:11:02 -         let r = parent.Range
2018-10-29 16:11:02 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:11:02 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:11:02 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:11:02 -         child
2018-10-29 16:11:02 -         
2018-10-29 16:11:02 -     let addChildFromTwoParents 
2018-10-29 16:11:02 -             (parent1:RandomVariable) 
2018-10-29 16:11:02 -             (parent2:RandomVariable) 
2018-10-29 16:11:02 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:11:02 -         let r = parent1.Range
2018-10-29 16:11:02 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:11:02 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:11:02 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:11:02 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:11:02 -         child    
2018-10-29 16:11:02 -         
2018-10-29 16:11:02 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:11:02 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:11:02 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:11:02 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:11:02 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:11:02 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:11:02 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:11:02 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:11:02 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:11:02 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:11:02 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:11:02 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:11:02 -         probCloudy.SetValueRange(rg.c)
2018-10-29 16:11:02 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:11:02 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:11:02 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:11:02 -         cptRain.SetValueRange(rg.r)
2018-10-29 16:11:02 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:11:02 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:11:02 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:11:02 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:11:02 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:11:02 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:11:02 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:11:02 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:11:02 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:11:02 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:11:02 -      
2018-10-29 16:11:02 -     // Properties
2018-10-29 16:11:02 -     member this.Ranges:Ranges = ranges
2018-10-29 16:11:02 -     member this.NumberOfExamples = numberOfExamples
2018-10-29 16:11:02 -     member this.RangeN = rN
2018-10-29 16:11:02 -     member this.Priors = priors
2018-10-29 16:11:02 -     mamber this.Parameters = parameters
2018-10-29 16:11:02 -     member this.PrimaryRandomVariables = primaryRandomVariables
2018-10-29 16:11:02 -     
2018-10-29 16:11:03 - Unexpected identifier in member definition
2018-10-29 16:11:52 - type WetGrassSprinklerRainModel() as this =
2018-10-29 16:11:52 -     // Private fields
2018-10-29 16:11:52 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:11:52 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:11:52 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:11:52 -     let priors = buildPriors ranges
2018-10-29 16:11:52 -     let parameters = buildDistributionParameters ranges priors
2018-10-29 16:11:52 -     let primaryRandomVariables = buildRandomVariables rN parameters
2018-10-29 16:11:52 -     // Private methods used by constructor
2018-10-29 16:11:52 -     let addChildFromOneParent 
2018-10-29 16:11:52 -             (parent:RandomVariable) 
2018-10-29 16:11:52 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:11:52 -         let r = parent.Range
2018-10-29 16:11:52 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:11:52 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:11:52 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:11:52 -         child
2018-10-29 16:11:52 -         
2018-10-29 16:11:52 -     let addChildFromTwoParents 
2018-10-29 16:11:52 -             (parent1:RandomVariable) 
2018-10-29 16:11:52 -             (parent2:RandomVariable) 
2018-10-29 16:11:52 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:11:52 -         let r = parent1.Range
2018-10-29 16:11:52 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:11:52 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:11:52 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:11:52 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:11:52 -         child    
2018-10-29 16:11:52 -         
2018-10-29 16:11:52 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:11:52 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:11:52 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:11:52 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:11:52 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:11:52 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:11:52 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:11:52 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:11:52 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:11:52 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:11:52 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:11:52 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:11:52 -         probCloudy.SetValueRange(rg.c)
2018-10-29 16:11:52 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:11:52 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:11:52 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:11:52 -         cptRain.SetValueRange(rg.r)
2018-10-29 16:11:52 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:11:52 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:11:52 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:11:52 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:11:52 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:11:52 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:11:52 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:11:52 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:11:52 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:11:52 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:11:52 -      
2018-10-29 16:11:52 -     // Properties
2018-10-29 16:11:52 -     member this.Ranges = ranges
2018-10-29 16:11:52 -     member this.NumberOfExamples = numberOfExamples
2018-10-29 16:11:52 -     member this.RangeN = rN
2018-10-29 16:11:52 -     member this.Priors = priors
2018-10-29 16:11:52 -     mamber this.Parameters = parameters
2018-10-29 16:11:52 -     member this.PrimaryRandomVariables = primaryRandomVariables
2018-10-29 16:11:52 -     
2018-10-29 16:11:53 - Unexpected identifier in member definition
2018-10-29 16:12:55 - type WetGrassSprinklerRainModel() =
2018-10-29 16:12:55 -     // Private fields
2018-10-29 16:12:55 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:12:55 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:12:55 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:12:55 -     let priors = buildPriors ranges
2018-10-29 16:12:55 -     let parameters = buildDistributionParameters ranges priors
2018-10-29 16:12:55 -     let primaryRandomVariables = buildRandomVariables rN parameters
2018-10-29 16:12:55 -     // Private methods used by constructor
2018-10-29 16:12:55 -     let addChildFromOneParent 
2018-10-29 16:12:55 -             (parent:RandomVariable) 
2018-10-29 16:12:55 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:12:55 -         let r = parent.Range
2018-10-29 16:12:55 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:12:55 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:12:55 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:12:55 -         child
2018-10-29 16:12:55 -         
2018-10-29 16:12:55 -     let addChildFromTwoParents 
2018-10-29 16:12:55 -             (parent1:RandomVariable) 
2018-10-29 16:12:55 -             (parent2:RandomVariable) 
2018-10-29 16:12:55 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:12:55 -         let r = parent1.Range
2018-10-29 16:12:55 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:12:55 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:12:55 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:12:55 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:12:55 -         child    
2018-10-29 16:12:55 -         
2018-10-29 16:12:55 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:12:55 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:12:55 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:12:55 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:12:55 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:12:55 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:12:55 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:12:55 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:12:55 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:12:55 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:12:55 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:12:55 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:12:55 -         probCloudy.SetValueRange(rg.c)
2018-10-29 16:12:55 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:12:55 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:12:55 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:12:55 -         cptRain.SetValueRange(rg.r)
2018-10-29 16:12:55 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:12:55 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:12:55 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:12:55 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:12:55 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:12:55 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:12:55 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:12:55 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:12:55 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:12:55 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:12:55 -      
2018-10-29 16:12:55 -     // Properties
2018-10-29 16:12:55 -     member this.Ranges = ranges
2018-10-29 16:12:55 -     member this.NumberOfExamples = numberOfExamples
2018-10-29 16:12:55 -     member this.RangeN = rN
2018-10-29 16:12:55 -     member this.Priors = priors
2018-10-29 16:12:55 -     mamber this.Parameters = parameters
2018-10-29 16:12:55 -     member this.PrimaryRandomVariables = primaryRandomVariables
2018-10-29 16:12:55 -     
2018-10-29 16:12:57 - Unexpected identifier in member definition
2018-10-29 16:13:25 - let model = WetGrassSprinklerRainModel ()  // Errors!!!
2018-10-29 16:13:25 - Expression evaluation failed: The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.
2018-10-29 16:13:25 - InvalidOperationExceptionThe initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.
2018-10-29 16:13:25 -   at Microsoft.FSharp.Core.LanguagePrimitives+IntrinsicFunctions.FailInit () [0x00014] in <5a7d678a904cf4daa74503838a677d5a>:0 
2018-10-29 16:13:25 -   at FSI_0235+WetGrassSprinklerRainModel.BuildPriors (FSI_0181+Ranges rg) [0x00015] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-29 16:13:25 -   at FSI_0235+WetGrassSprinklerRainModel..ctor () [0x000b6] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-29 16:13:25 -   at <StartupCode$FSI_0244>.$FSI_0244.main@ () [0x00000] in <98acb9fdf8814ddc95217a757b8032a3>:0 
2018-10-29 16:13:25 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-10-29 16:13:25 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <2943701620b54f86b436d3ffad010412>:0 
2018-10-29 16:14:35 - type WetGrassSprinklerRainModel() =
2018-10-29 16:14:35 -     // Private fields
2018-10-29 16:14:35 -     
2018-10-29 16:14:35 -     // Private methods used by constructor
2018-10-29 16:14:35 -     let addChildFromOneParent 
2018-10-29 16:14:35 -             (parent:RandomVariable) 
2018-10-29 16:14:35 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:14:35 -         let r = parent.Range
2018-10-29 16:14:35 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:14:35 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:14:35 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:14:35 -         child
2018-10-29 16:14:35 -         
2018-10-29 16:14:35 -     let addChildFromTwoParents 
2018-10-29 16:14:35 -             (parent1:RandomVariable) 
2018-10-29 16:14:35 -             (parent2:RandomVariable) 
2018-10-29 16:14:35 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:14:35 -         let r = parent1.Range
2018-10-29 16:14:35 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:14:35 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:14:35 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:14:35 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:14:35 -         child    
2018-10-29 16:14:35 -         
2018-10-29 16:14:35 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:14:35 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:14:35 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:14:35 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:14:35 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:14:35 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:14:35 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:14:35 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:14:35 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:14:35 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:14:35 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:14:35 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:14:35 -         probCloudy.SetValueRange(rg.c)
2018-10-29 16:14:35 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:14:35 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:14:35 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:14:35 -         cptRain.SetValueRange(rg.r)
2018-10-29 16:14:35 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:14:35 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:14:35 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:14:35 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:14:35 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:14:35 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:14:35 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:14:35 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:14:35 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:14:35 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:14:35 -      
2018-10-29 16:14:35 -     // Private fields
2018-10-29 16:14:35 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:14:35 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:14:35 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:14:35 -     let priors = buildPriors ranges
2018-10-29 16:14:35 -     let parameters = buildDistributionParameters ranges priors
2018-10-29 16:14:35 -     let primaryRandomVariables = buildRandomVariables rN parameters
2018-10-29 16:14:35 -     
2018-10-29 16:14:35 -     // Properties
2018-10-29 16:14:35 -     member this.Ranges = ranges
2018-10-29 16:14:35 -     member this.NumberOfExamples = numberOfExamples
2018-10-29 16:14:35 -     member this.RangeN = rN
2018-10-29 16:14:35 -     member this.Priors = priors
2018-10-29 16:14:35 -     mamber this.Parameters = parameters
2018-10-29 16:14:35 -     member this.PrimaryRandomVariables = primaryRandomVariables
2018-10-29 16:14:35 -     
2018-10-29 16:14:35 -     
2018-10-29 16:14:37 - Unexpected identifier in member definition
2018-10-29 16:16:20 - type WetGrassSprinklerRainModel() =
2018-10-29 16:16:20 -     
2018-10-29 16:16:20 -     // Private functions (used by constructor)
2018-10-29 16:16:20 -     let addChildFromOneParent 
2018-10-29 16:16:20 -             (parent:RandomVariable) 
2018-10-29 16:16:20 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:16:20 -         let r = parent.Range
2018-10-29 16:16:20 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:16:20 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:16:20 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:16:20 -         child
2018-10-29 16:16:20 -         
2018-10-29 16:16:20 -     let addChildFromTwoParents 
2018-10-29 16:16:20 -             (parent1:RandomVariable) 
2018-10-29 16:16:20 -             (parent2:RandomVariable) 
2018-10-29 16:16:20 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:16:20 -         let r = parent1.Range
2018-10-29 16:16:20 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:16:20 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:16:20 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:16:20 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:16:20 -         child    
2018-10-29 16:16:20 -         
2018-10-29 16:16:20 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:16:20 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:16:20 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:16:20 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:16:20 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:16:20 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:16:20 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:16:20 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:16:20 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:16:20 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:16:20 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:16:20 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:16:20 -         probCloudy.SetValueRange(rg.c)
2018-10-29 16:16:20 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:16:20 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:16:20 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:16:20 -         cptRain.SetValueRange(rg.r)
2018-10-29 16:16:20 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:16:20 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:16:20 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:16:20 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:16:20 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:16:20 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:16:20 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:16:20 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:16:20 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:16:20 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:16:20 -      
2018-10-29 16:16:20 -     // Private fields
2018-10-29 16:16:20 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:16:20 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:16:20 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:16:20 -     let priors = buildPriors ranges
2018-10-29 16:16:20 -     let parameters = buildDistributionParameters ranges priors
2018-10-29 16:16:20 -     let primaryRandomVariables = buildRandomVariables rN parameters
2018-10-29 16:16:20 -     
2018-10-29 16:16:20 -     // Properties
2018-10-29 16:16:20 -     member this.Ranges = ranges
2018-10-29 16:16:20 -     member this.NumberOfExamples = numberOfExamples
2018-10-29 16:16:20 -     member this.RangeN = rN
2018-10-29 16:16:20 -     member this.Priors = priors
2018-10-29 16:16:20 -     mamber this.Parameters = parameters
2018-10-29 16:16:20 -     member this.PrimaryRandomVariables = primaryRandomVariables
2018-10-29 16:16:20 -     
2018-10-29 16:16:20 -     
2018-10-29 16:16:22 - Unexpected identifier in member definition
2018-10-29 16:18:34 - type WetGrassSprinklerRainModel() =
2018-10-29 16:18:34 -     
2018-10-29 16:18:34 -     // Private functions (used by constructor)
2018-10-29 16:18:34 -     let addChildFromOneParent 
2018-10-29 16:18:34 -             (parent:RandomVariable) 
2018-10-29 16:18:34 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:18:34 -         let r = parent.Range
2018-10-29 16:18:34 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:18:34 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:18:34 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:18:34 -         child
2018-10-29 16:18:34 -         
2018-10-29 16:18:34 -     let addChildFromTwoParents 
2018-10-29 16:18:34 -             (parent1:RandomVariable) 
2018-10-29 16:18:34 -             (parent2:RandomVariable) 
2018-10-29 16:18:34 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:18:34 -         let r = parent1.Range
2018-10-29 16:18:34 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:18:34 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:18:34 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:18:34 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:18:34 -         child    
2018-10-29 16:18:34 -         
2018-10-29 16:18:34 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:18:34 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:18:34 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:18:34 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:18:34 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:18:34 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:18:34 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:18:34 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:18:34 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:18:34 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:18:34 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:18:34 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:18:34 -         do probCloudy.SetValueRange(rg.c)
2018-10-29 16:18:34 -         do cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:18:34 -         do cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:18:34 -         do cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:18:34 -         do cptRain.SetValueRange(rg.r)
2018-10-29 16:18:34 -         do cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:18:34 -         do cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:18:34 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:18:34 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:18:34 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:18:34 -         do vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:18:34 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:18:34 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:18:34 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:18:34 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:18:34 -      
2018-10-29 16:18:34 -     // Private fields
2018-10-29 16:18:34 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:18:34 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:18:34 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:18:34 -     let priors = buildPriors ranges
2018-10-29 16:18:34 -     let parameters = buildDistributionParameters ranges priors
2018-10-29 16:18:34 -     let primaryRandomVariables = buildRandomVariables rN parameters
2018-10-29 16:18:34 -     
2018-10-29 16:18:34 -     // Properties
2018-10-29 16:18:34 -     member this.Ranges = ranges
2018-10-29 16:18:34 -     member this.NumberOfExamples = numberOfExamples
2018-10-29 16:18:34 -     member this.RangeN = rN
2018-10-29 16:18:34 -     member this.Priors = priors
2018-10-29 16:18:34 -     mamber this.Parameters = parameters
2018-10-29 16:18:34 -     member this.PrimaryRandomVariables = primaryRandomVariables
2018-10-29 16:18:34 -     
2018-10-29 16:18:34 -     
2018-10-29 16:18:35 - Unexpected identifier in member definition
2018-10-29 16:26:37 - type WetGrassSprinklerRainModel() =
2018-10-29 16:26:37 -     
2018-10-29 16:26:37 -     // Private functions (used by constructor)
2018-10-29 16:26:37 -     let addChildFromOneParent 
2018-10-29 16:26:37 -             (parent:RandomVariable) 
2018-10-29 16:26:37 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:26:37 -         let r = parent.Range
2018-10-29 16:26:37 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:26:37 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:26:37 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:26:37 -         child
2018-10-29 16:26:37 -         
2018-10-29 16:26:37 -     let addChildFromTwoParents 
2018-10-29 16:26:37 -             (parent1:RandomVariable) 
2018-10-29 16:26:37 -             (parent2:RandomVariable) 
2018-10-29 16:26:37 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:26:37 -         let r = parent1.Range
2018-10-29 16:26:37 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:26:37 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:26:37 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:26:37 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:26:37 -         child    
2018-10-29 16:26:37 -         
2018-10-29 16:26:37 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:26:37 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:26:37 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:26:37 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:26:37 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:26:37 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:26:37 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:26:37 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:26:37 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:26:37 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:26:37 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:26:37 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:26:37 -         do probCloudy.SetValueRange(rg.c)
2018-10-29 16:26:37 -         do cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:26:37 -         do cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:26:37 -         do cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:26:37 -         do cptRain.SetValueRange(rg.r)
2018-10-29 16:26:37 -         do cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:26:37 -         do cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:26:37 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:26:37 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:26:37 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:26:37 -         do vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:26:37 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:26:37 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:26:37 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:26:37 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:26:37 -      
2018-10-29 16:26:37 -     // Private fields
2018-10-29 16:26:37 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:26:37 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:26:37 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:26:37 -     let priors = buildPriors ranges
2018-10-29 16:26:37 -     let parameters = buildDistributionParameters ranges priors
2018-10-29 16:26:37 -     let primaryRandomVariables = buildRandomVariables rN parameters
2018-10-29 16:29:20 - type WetGrassSprinklerRainModel() =
2018-10-29 16:29:20 -     
2018-10-29 16:29:20 -     // Private functions (used by constructor)
2018-10-29 16:29:20 -     let addChildFromOneParent 
2018-10-29 16:29:20 -             (parent:RandomVariable) 
2018-10-29 16:29:20 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:29:20 -         let r = parent.Range
2018-10-29 16:29:20 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:29:20 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:29:20 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:29:20 -         child
2018-10-29 16:29:20 -         
2018-10-29 16:29:20 -     let addChildFromTwoParents 
2018-10-29 16:29:20 -             (parent1:RandomVariable) 
2018-10-29 16:29:20 -             (parent2:RandomVariable) 
2018-10-29 16:29:20 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:29:20 -         let r = parent1.Range
2018-10-29 16:29:20 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:29:20 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:29:20 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:29:20 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:29:20 -         child    
2018-10-29 16:29:20 -         
2018-10-29 16:29:20 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:29:20 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:29:20 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:29:20 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:29:20 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:29:20 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:29:20 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:29:20 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:29:20 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:29:20 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:29:20 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:29:20 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:29:20 -         do probCloudy.SetValueRange(rg.c)
2018-10-29 16:29:20 -         do cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:29:20 -         do cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:29:20 -         do cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:29:20 -         do cptRain.SetValueRange(rg.r)
2018-10-29 16:29:20 -         do cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:29:20 -         do cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:29:20 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:29:20 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:29:20 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:29:20 -         do vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:29:20 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:29:20 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:29:20 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:29:20 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:29:20 -      
2018-10-29 16:29:20 -     // Private fields
2018-10-29 16:29:20 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:29:20 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:29:20 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:29:20 -     let priors = buildPriors ranges
2018-10-29 16:29:20 -     let parameters = buildDistributionParameters ranges priors
2018-10-29 16:29:20 -     let primaryRandomVariables = buildRandomVariables rN parameters
2018-10-29 16:29:20 -     
2018-10-29 16:29:20 -     // Properties
2018-10-29 16:29:20 -     member this.Ranges = ranges
2018-10-29 16:29:20 -     member this.NumberOfExamples = numberOfExamples
2018-10-29 16:29:20 -     member this.RangeN = rN
2018-10-29 16:29:20 -     member this.Priors = priors
2018-10-29 16:29:20 -     mamber this.Parameters = parameters
2018-10-29 16:29:20 -     member this.PrimaryRandomVariables = primaryRandomVariables
2018-10-29 16:29:20 -     
2018-10-29 16:29:22 - Unexpected identifier in member definition
2018-10-29 16:50:50 - type WetGrassSprinklerRainModel() =
2018-10-29 16:50:50 -     
2018-10-29 16:50:50 -     // Private functions (used by constructor)
2018-10-29 16:50:50 -     let addChildFromOneParent 
2018-10-29 16:50:50 -             (parent:RandomVariable) 
2018-10-29 16:50:50 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:50:50 -         let r = parent.Range
2018-10-29 16:50:50 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:50:50 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:50:50 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:50:50 -         child
2018-10-29 16:50:50 -         
2018-10-29 16:50:50 -     let addChildFromTwoParents 
2018-10-29 16:50:50 -             (parent1:RandomVariable) 
2018-10-29 16:50:50 -             (parent2:RandomVariable) 
2018-10-29 16:50:50 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:50:50 -         let r = parent1.Range
2018-10-29 16:50:50 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:50:50 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:50:50 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:50:50 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:50:50 -         child    
2018-10-29 16:50:50 -         
2018-10-29 16:50:50 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:50:50 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:50:50 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:50:50 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:50:50 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:50:50 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:50:50 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:50:50 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:50:50 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:50:50 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:50:50 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:50:50 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:50:50 -         do probCloudy.SetValueRange(rg.c)
2018-10-29 16:50:50 -         do cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:50:50 -         do cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:50:50 -         do cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:50:50 -         do cptRain.SetValueRange(rg.r)
2018-10-29 16:50:50 -         do cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:50:50 -         do cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:50:50 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:50:50 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:50:50 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:50:50 -         do vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:50:50 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:50:50 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:50:50 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:50:50 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:50:50 -      
2018-10-29 16:50:50 -     // Private fields
2018-10-29 16:50:50 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:50:50 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:50:50 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:50:50 -     let priors = buildPriors ranges
2018-10-29 16:50:50 -     let parameters = buildDistributionParameters ranges priors
2018-10-29 16:50:50 -     let primaryRandomVariables = buildRandomVariables rN parameters
2018-10-29 16:50:50 -     
2018-10-29 16:50:50 -     // Properties
2018-10-29 16:50:50 -     member this.Ranges = ranges
2018-10-29 16:51:21 - type WetGrassSprinklerRainModel() =
2018-10-29 16:51:21 -     
2018-10-29 16:51:21 -     // Private functions (used by constructor)
2018-10-29 16:51:21 -     let addChildFromOneParent 
2018-10-29 16:51:21 -             (parent:RandomVariable) 
2018-10-29 16:51:21 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:51:21 -         let r = parent.Range
2018-10-29 16:51:21 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:51:21 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:51:21 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:51:21 -         child
2018-10-29 16:51:21 -         
2018-10-29 16:51:21 -     let addChildFromTwoParents 
2018-10-29 16:51:21 -             (parent1:RandomVariable) 
2018-10-29 16:51:21 -             (parent2:RandomVariable) 
2018-10-29 16:51:21 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:51:21 -         let r = parent1.Range
2018-10-29 16:51:21 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:51:21 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:51:21 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:51:21 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:51:21 -         child    
2018-10-29 16:51:21 -         
2018-10-29 16:51:21 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:51:21 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:51:21 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:51:21 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:51:21 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:51:21 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:51:21 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:51:21 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:51:21 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:51:21 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:51:21 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:51:21 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:51:21 -         do probCloudy.SetValueRange(rg.c)
2018-10-29 16:51:21 -         do cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:51:21 -         do cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:51:21 -         do cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:51:21 -         do cptRain.SetValueRange(rg.r)
2018-10-29 16:51:21 -         do cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:51:21 -         do cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:51:21 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:51:21 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:51:21 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:51:21 -         do vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:51:21 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:51:21 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:51:21 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:51:21 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:51:21 -      
2018-10-29 16:51:21 -     // Private fields
2018-10-29 16:51:21 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:51:21 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:51:21 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:51:21 -     let priors = buildPriors ranges
2018-10-29 16:51:21 -     let parameters = buildDistributionParameters ranges priors
2018-10-29 16:51:21 -     let primaryRandomVariables = buildRandomVariables rN parameters
2018-10-29 16:51:21 -     
2018-10-29 16:51:21 -     // Properties
2018-10-29 16:51:21 -     member this.Ranges = ranges
2018-10-29 16:51:21 -     member this.NumberOfExamples = numberOfExamples
2018-10-29 16:51:45 - type WetGrassSprinklerRainModel() =
2018-10-29 16:51:45 -     
2018-10-29 16:51:45 -     // Private functions (used by constructor)
2018-10-29 16:51:45 -     let addChildFromOneParent 
2018-10-29 16:51:45 -             (parent:RandomVariable) 
2018-10-29 16:51:45 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:51:45 -         let r = parent.Range
2018-10-29 16:51:45 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:51:45 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:51:45 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:51:45 -         child
2018-10-29 16:51:45 -         
2018-10-29 16:51:45 -     let addChildFromTwoParents 
2018-10-29 16:51:45 -             (parent1:RandomVariable) 
2018-10-29 16:51:45 -             (parent2:RandomVariable) 
2018-10-29 16:51:45 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:51:45 -         let r = parent1.Range
2018-10-29 16:51:45 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:51:45 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:51:45 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:51:45 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:51:45 -         child    
2018-10-29 16:51:45 -         
2018-10-29 16:51:45 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:51:45 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:51:45 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:51:45 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:51:45 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:51:45 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:51:45 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:51:45 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:51:45 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:51:45 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:51:45 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:51:45 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:51:45 -         do probCloudy.SetValueRange(rg.c)
2018-10-29 16:51:45 -         do cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:51:45 -         do cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:51:45 -         do cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:51:45 -         do cptRain.SetValueRange(rg.r)
2018-10-29 16:51:45 -         do cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:51:45 -         do cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:51:45 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:51:45 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:51:45 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:51:45 -         do vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:51:45 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:51:45 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:51:45 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:51:45 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:51:45 -      
2018-10-29 16:51:45 -     // Private fields
2018-10-29 16:51:45 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:51:45 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:51:45 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:51:45 -     let priors = buildPriors ranges
2018-10-29 16:51:45 -     let parameters = buildDistributionParameters ranges priors
2018-10-29 16:51:45 -     let primaryRandomVariables = buildRandomVariables rN parameters
2018-10-29 16:51:45 -     
2018-10-29 16:51:45 -     // Properties
2018-10-29 16:51:45 -     member this.Ranges = ranges
2018-10-29 16:51:45 -     member this.NumberOfExamples = numberOfExamples
2018-10-29 16:51:45 -     member this.RangeN = rN
2018-10-29 16:51:45 -     member this.Priors = priors
2018-10-29 16:51:45 -     member this.Parameters = parameters
2018-10-29 16:51:45 -     member this.PrimaryRandomVariables = primaryRandomVariables
2018-10-29 16:52:04 - let model = WetGrassSprinklerRainModel ()  // Errors!!!
2018-10-29 16:52:19 - model.Ranges
2018-10-29 16:52:36 - model.Priors
2018-10-29 16:52:48 - model.Parameters
2018-10-29 16:53:16 - model.PrimaryRandomVariables
2018-10-29 16:54:39 - module WetGrassSprinklerRainModel =
2018-10-29 16:54:39 -     // Functions
2018-10-29 16:54:39 -     let addChildFromOneParent 
2018-10-29 16:54:39 -             (parent:RandomVariable) 
2018-10-29 16:54:39 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:54:39 -         let r = parent.Range
2018-10-29 16:54:39 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:54:39 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:54:39 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:54:39 -         child
2018-10-29 16:54:39 -         
2018-10-29 16:54:39 -     let addChildFromTwoParents 
2018-10-29 16:54:39 -             (parent1:RandomVariable) 
2018-10-29 16:54:39 -             (parent2:RandomVariable) 
2018-10-29 16:54:39 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:54:39 -         let r = parent1.Range
2018-10-29 16:54:39 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:54:39 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:54:39 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:54:39 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:54:39 -         child    
2018-10-29 16:54:39 -     
2018-10-29 16:54:39 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:54:39 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:54:39 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:54:39 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:54:39 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:54:39 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:54:39 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:54:39 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:54:39 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:54:39 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:54:39 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:54:39 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:54:39 -         probCloudy.SetValueRange(rg.c)
2018-10-29 16:54:39 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:54:39 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:54:39 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:54:39 -         cptRain.SetValueRange(rg.r)
2018-10-29 16:54:39 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:54:39 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:54:39 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:54:39 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:54:39 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:54:39 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:54:39 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:54:39 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:54:39 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:54:39 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:54:39 -         
2018-10-29 16:54:39 -     let create () =
2018-10-29 16:54:39 -         let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:54:39 -         let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:54:39 -         let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:54:39 -         let priors = buildPriors ranges
2018-10-29 16:54:39 -         let parameters = buildDistributionParameters ranges priors
2018-10-29 16:54:39 -         let rvs = buildRandomVariables rN parameters
2018-10-29 16:54:39 -         rvs
2018-10-29 16:54:54 - //open WetGrassSprinklerRainModel
2018-10-29 16:54:54 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:54:54 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:54:54 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:54:54 - let priors = WetGrassSprinklerRainModel.buildPriors ranges
2018-10-29 16:54:54 - let parameters = buildDistributionParameters ranges priors
2018-10-29 16:54:54 - let rvs = buildRandomVariables rN parameters
2018-10-29 16:55:16 - open WetGrassSprinklerRainModel
2018-10-29 16:55:16 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:55:16 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:55:16 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:55:16 - let priors = buildPriors ranges
2018-10-29 16:55:16 - let parameters = buildDistributionParameters ranges priors
2018-10-29 16:55:16 - let rvs = buildRandomVariables rN parameters
2018-10-29 16:55:42 - module WetGrassSprinklerRainModel =
2018-10-29 16:55:42 -     // Functions
2018-10-29 16:55:42 -     let addChildFromOneParent 
2018-10-29 16:55:42 -             (parent:RandomVariable) 
2018-10-29 16:55:42 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:55:42 -         let r = parent.Range
2018-10-29 16:55:42 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:55:42 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:55:42 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:55:42 -         child
2018-10-29 16:55:42 -         
2018-10-29 16:55:42 -     let addChildFromTwoParents 
2018-10-29 16:55:42 -             (parent1:RandomVariable) 
2018-10-29 16:55:42 -             (parent2:RandomVariable) 
2018-10-29 16:55:42 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:55:42 -         let r = parent1.Range
2018-10-29 16:55:42 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:55:42 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:55:42 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:55:42 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:55:42 -         child    
2018-10-29 16:55:42 -     
2018-10-29 16:55:42 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:55:42 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:55:42 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:55:42 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:55:42 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:55:42 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:55:42 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:55:42 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:55:42 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:55:42 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:55:42 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:55:42 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:55:42 -         probCloudy.SetValueRange(rg.c)
2018-10-29 16:55:42 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:55:42 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:55:42 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:55:42 -         cptRain.SetValueRange(rg.r)
2018-10-29 16:55:42 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:55:42 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:55:42 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:55:42 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:55:42 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:55:42 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:55:42 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:55:42 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:55:42 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:55:42 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:55:54 - module WetGrassSprinklerRainModel2 =
2018-10-29 16:55:54 -     // Functions
2018-10-29 16:55:54 -     let addChildFromOneParent 
2018-10-29 16:55:54 -             (parent:RandomVariable) 
2018-10-29 16:55:54 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 16:55:54 -         let r = parent.Range
2018-10-29 16:55:54 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:55:54 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 16:55:54 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 16:55:54 -         child
2018-10-29 16:55:54 -         
2018-10-29 16:55:54 -     let addChildFromTwoParents 
2018-10-29 16:55:54 -             (parent1:RandomVariable) 
2018-10-29 16:55:54 -             (parent2:RandomVariable) 
2018-10-29 16:55:54 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 16:55:54 -         let r = parent1.Range
2018-10-29 16:55:54 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 16:55:54 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 16:55:54 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 16:55:54 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 16:55:54 -         child    
2018-10-29 16:55:54 -     
2018-10-29 16:55:54 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 16:55:54 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 16:55:54 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 16:55:54 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 16:55:54 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 16:55:54 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 16:55:54 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 16:55:54 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 16:55:54 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 16:55:54 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 16:55:54 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 16:55:54 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 16:55:54 -         probCloudy.SetValueRange(rg.c)
2018-10-29 16:55:54 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 16:55:54 -         cptSprinkler.SetValueRange(rg.s)
2018-10-29 16:55:54 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 16:55:54 -         cptRain.SetValueRange(rg.r)
2018-10-29 16:55:54 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 16:55:54 -         cptWetGrass.SetValueRange(rg.w)
2018-10-29 16:55:54 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 16:55:54 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 16:55:54 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 16:55:54 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 16:55:54 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 16:55:54 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 16:55:54 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 16:55:54 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 16:56:03 - open WetGrassSprinklerRainModel2
2018-10-29 16:56:03 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 16:56:03 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 16:56:03 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 16:56:03 - let priors = buildPriors ranges
2018-10-29 16:56:03 - let parameters = buildDistributionParameters ranges priors
2018-10-29 16:56:03 - let rvs = buildRandomVariables rN parameters
2018-10-29 16:57:23 - #load "Paket.fsx"
2018-10-29 16:57:26 - Paket.Package
2018-10-29 16:57:26 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-29 16:57:26 -       "Microsoft.ML.Probabilistic"
2018-10-29 16:57:26 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-29 16:57:26 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-29 16:57:26 -       "NETStandard.Library"
2018-10-29 16:57:26 -   ]
2018-10-29 16:58:59 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-29 16:59:05 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-29 17:00:16 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-29 17:00:16 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-29 17:00:16 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-29 17:00:16 - #r "Microsoft.ML.Probabilistic"
2018-10-29 17:00:16 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-29 17:00:16 - #r "netstandard"
2018-10-29 17:00:17 - open System
2018-10-29 17:00:18 - open Microsoft.ML.Probabilistic  
2018-10-29 17:00:18 - open Microsoft.ML.Probabilistic.Models  
2018-10-29 17:00:18 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-29 17:00:18 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-29 17:00:18 - open Microsoft.ML.Probabilistic.Math
2018-10-29 17:00:20 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-29 17:00:27 - open Microsoft.ML.Probabilistic.FSharp
2018-10-29 17:00:27 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2018-10-29 17:00:27 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-10-29 17:00:28 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-10-29 17:00:28 - let AddChildFromOneParent 
2018-10-29 17:00:28 -         (parent:RandomVariable) 
2018-10-29 17:00:28 -         (cpt:ConditionalProbabilityTable) =
2018-10-29 17:00:28 -     let r = parent.Range
2018-10-29 17:00:28 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 17:00:28 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 17:00:28 -                        Variable.Discrete(cpt.[pi])))
2018-10-29 17:00:28 -     child
2018-10-29 17:00:29 - type ConditionalProbabilityTable2D = 
2018-10-29 17:00:29 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-29 17:00:29 - let AddChildFromTwoParents 
2018-10-29 17:00:29 -         (parent1:RandomVariable) 
2018-10-29 17:00:29 -         (parent2:RandomVariable) 
2018-10-29 17:00:29 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 17:00:29 -     let r = parent1.Range
2018-10-29 17:00:29 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 17:00:29 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 17:00:29 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 17:00:29 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 17:00:29 -     child       
2018-10-29 17:00:30 - type RandomVariables =
2018-10-29 17:00:30 -     {cloudy:VariableArray<int>;
2018-10-29 17:00:30 -     sprinkler:VariableArray<int>;
2018-10-29 17:00:30 -     rain:VariableArray<int>;
2018-10-29 17:00:30 -     wetGrass:VariableArray<int> }
2018-10-29 17:00:31 - type ObservedValues =
2018-10-29 17:00:31 -     {cloudy:array<int>;
2018-10-29 17:00:31 -     sprinkler:array<int>;
2018-10-29 17:00:31 -     rain:array<int>;
2018-10-29 17:00:31 -     wetGrass:array<int> }
2018-10-29 17:00:32 - type DistributionParameters =
2018-10-29 17:00:32 -     {cloudy:Variable<Vector> ;
2018-10-29 17:00:32 -     sprinkler:VariableArray<Vector> ;
2018-10-29 17:00:32 -     rain:VariableArray<Vector> ;
2018-10-29 17:00:32 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-29 17:00:33 - type DistributionParameterValues =  
2018-10-29 17:00:33 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-29 17:00:33 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-29 17:00:33 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-29 17:00:33 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-29 17:00:33 -     }
2018-10-29 17:00:33 - type PriorDistributions =
2018-10-29 17:00:33 -     {cloudy:Variable<Dirichlet> ;
2018-10-29 17:00:33 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-29 17:00:33 -     rain:VariableArray<Dirichlet> ;
2018-10-29 17:00:33 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-29 17:00:34 - type PosteriorDistributions =
2018-10-29 17:00:34 -     {cloudy:Dirichlet ;
2018-10-29 17:00:34 -     sprinkler:Dirichlet[] ;
2018-10-29 17:00:34 -     rain:Dirichlet[] ;
2018-10-29 17:00:34 -     wetGrass:Dirichlet[][] }
2018-10-29 17:00:35 - let engine =  InferenceEngine ()
2018-10-29 17:00:35 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 17:00:35 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 17:00:36 - let rC = Range(2).Named("C") // Cloudy
2018-10-29 17:00:36 - let rS = Range(2).Named("S") // Sprinkler
2018-10-29 17:00:36 - let rR = Range(2).Named("R") // Rain
2018-10-29 17:00:36 - let rW = Range(2).Named("W") // Wet
2018-10-29 17:00:36 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-29 17:00:36 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-29 17:00:36 - probCloudy.SetValueRange(rC)
2018-10-29 17:00:37 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-29 17:00:37 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-29 17:00:38 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2018-10-29 17:00:38 - cptSprinkler.SetValueRange(rS)
2018-10-29 17:00:39 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-29 17:00:39 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-29 17:00:39 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-29 17:00:39 - cptRain.SetValueRange(rR)
2018-10-29 17:00:40 - let cptWetGrassPrior= 
2018-10-29 17:00:40 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 17:00:40 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-29 17:00:40 - let cptWetGrass = 
2018-10-29 17:00:40 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 17:00:40 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-29 17:00:41 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-10-29 17:00:41 - cptWetGrass.SetValueRange(rW)
2018-10-29 17:00:41 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 17:00:42 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 17:00:42 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 17:00:42 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 17:00:42 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 17:00:42 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 17:00:42 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 17:00:43 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 17:00:43 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 17:00:43 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 17:00:43 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 17:00:43 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 17:00:43 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 17:00:43 -     probCloudy.SetValueRange(rg.c)
2018-10-29 17:00:43 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 17:00:43 -     cptSprinkler.SetValueRange(rg.s)
2018-10-29 17:00:43 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 17:00:43 -     cptRain.SetValueRange(rg.r)
2018-10-29 17:00:43 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 17:00:43 -     cptWetGrass.SetValueRange(rg.w)
2018-10-29 17:00:43 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 17:00:44 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 17:00:44 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 17:00:44 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 17:00:44 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-10-29 17:00:45 - Reporting 0 opened comms
2018-10-29 17:12:07 - type WetGrassSprinklerRainModel() =
2018-10-29 17:12:07 -     
2018-10-29 17:12:07 -     // Private functions (used by constructor)
2018-10-29 17:12:07 -     let addChildFromOneParent 
2018-10-29 17:12:07 -             (parent:RandomVariable) 
2018-10-29 17:12:07 -             (cpt:ConditionalProbabilityTable) =
2018-10-29 17:12:07 -         let r = parent.Range
2018-10-29 17:12:07 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 17:12:07 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 17:12:07 -                            Variable.Discrete(cpt.[pi])))
2018-10-29 17:12:07 -         child
2018-10-29 17:12:07 -         
2018-10-29 17:12:07 -     let addChildFromTwoParents 
2018-10-29 17:12:07 -             (parent1:RandomVariable) 
2018-10-29 17:12:07 -             (parent2:RandomVariable) 
2018-10-29 17:12:07 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 17:12:07 -         let r = parent1.Range
2018-10-29 17:12:07 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 17:12:07 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 17:12:07 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 17:12:07 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 17:12:07 -         child    
2018-10-29 17:12:07 -         
2018-10-29 17:12:07 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 17:12:07 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 17:12:07 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 17:12:07 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 17:12:07 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 17:12:07 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 17:12:07 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 17:12:07 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 17:12:07 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 17:12:07 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 17:12:07 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 17:12:07 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 17:12:07 -         do probCloudy.SetValueRange(rg.c)
2018-10-29 17:12:07 -         do cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 17:12:07 -         do cptSprinkler.SetValueRange(rg.s)
2018-10-29 17:12:07 -         do cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 17:12:07 -         do cptRain.SetValueRange(rg.r)
2018-10-29 17:12:07 -         do cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 17:12:07 -         do cptWetGrass.SetValueRange(rg.w)
2018-10-29 17:12:07 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 17:12:07 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-29 17:12:07 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 17:12:07 -         do vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-29 17:12:07 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-29 17:12:07 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-29 17:12:07 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-29 17:12:07 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-29 17:12:07 -      
2018-10-29 17:12:07 -     // Private fields
2018-10-29 17:12:07 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 17:12:07 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 17:12:07 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 17:12:07 -     let priors = buildPriors ranges
2018-10-29 17:12:07 -     let parameters = buildDistributionParameters ranges priors
2018-10-29 17:12:07 -     let primaryRandomVariables = buildRandomVariables rN parameters
2018-10-29 17:12:07 -     let engine = InferenceEngine ()
2018-10-29 17:12:07 -     
2018-10-29 17:12:07 -     // Properties
2018-10-29 17:12:07 -     member this.Ranges = ranges
2018-10-29 17:12:07 -     member this.NumberOfExamples = numberOfExamples
2018-10-29 17:12:07 -     member this.RangeN = rN
2018-10-29 17:12:07 -     member this.Priors = priors
2018-10-29 17:12:07 -     member this.Parameters = parameters
2018-10-29 17:12:07 -     member this.PrimaryRandomVariables = primaryRandomVariables
2018-10-29 17:12:07 -     member this.Engine = engine
2018-10-29 17:14:15 - ObservedValues
2018-10-29 17:14:16 - The value or constructor 'ObservedValues' is not defined.
2018-10-29 17:48:16 - let Sample  (numData:int)
2018-10-29 17:48:16 -             (dpv:DistributionParameterValues) : int[][] =     
2018-10-29 17:48:16 -     array.init numData (fun _ ->
2018-10-29 17:48:16 -             let cloudy = Discrete.Sample(dpv.cloudy)
2018-10-29 17:48:16 -             let sprinkler = Discrete.Sample(dpv.sprinkler[cloudy])
2018-10-29 17:48:16 -             let rain = Discrete.Sample(dpv.rain[cloudy])
2018-10-29 17:48:16 -             let wetGrass = Discrete.Sample(dpv.wetGrass[sprinkler][rain])
2018-10-29 17:48:16 -             [|cloudy;sprinkler;rain;wetGrass|])
2018-10-29 17:48:17 - The field, constructor or member 'init' is not defined. Maybe you want one of the following:
2018-10-29 17:48:17 -    Initialize
2018-10-29 17:48:28 - let Sample  (numData:int)
2018-10-29 17:48:28 -             (dpv:DistributionParameterValues) : int[][] =     
2018-10-29 17:48:28 -     Array.init numData (fun _ ->
2018-10-29 17:48:28 -             let cloudy = Discrete.Sample(dpv.cloudy)
2018-10-29 17:48:28 -             let sprinkler = Discrete.Sample(dpv.sprinkler[cloudy])
2018-10-29 17:48:28 -             let rain = Discrete.Sample(dpv.rain[cloudy])
2018-10-29 17:48:28 -             let wetGrass = Discrete.Sample(dpv.wetGrass[sprinkler][rain])
2018-10-29 17:48:28 -             [|cloudy;sprinkler;rain;wetGrass|])
2018-10-29 17:48:29 - This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?
2018-10-29 17:48:29 - This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?
2018-10-29 17:48:29 - This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?
2018-10-29 17:48:56 - let Sample  (numData:int)
2018-10-29 17:48:56 -             (dpv:DistributionParameterValues) : int[][] =     
2018-10-29 17:48:56 -     Array.init numData (fun _ ->
2018-10-29 17:48:56 -             let cloudy = Discrete.Sample(dpv.cloudy);
2018-10-29 17:48:56 -             let sprinkler = Discrete.Sample(dpv.sprinkler[cloudy]);
2018-10-29 17:48:56 -             let rain = Discrete.Sample(dpv.rain[cloudy]);
2018-10-29 17:48:56 -             let wetGrass = Discrete.Sample(dpv.wetGrass[sprinkler][rain]);
2018-10-29 17:48:56 -             [|cloudy;sprinkler;rain;wetGrass|])
2018-10-29 17:48:57 - This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?
2018-10-29 17:48:57 - This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?
2018-10-29 17:48:57 - This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?
2018-10-29 17:49:38 - let Sample  (numData:int)
2018-10-29 17:49:38 -             (dpv:DistributionParameterValues) : int[][] =     
2018-10-29 17:49:38 -     Array.init numData (fun _ ->
2018-10-29 17:49:38 -             let cloudy = Discrete.Sample(dpv.cloudy);
2018-10-29 17:49:38 -             let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy]);
2018-10-29 17:49:38 -             let rain = Discrete.Sample(dpv.rain.[cloudy]);
2018-10-29 17:49:38 -             let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]);
2018-10-29 17:49:38 -             [|cloudy;sprinkler;rain;wetGrass|])
2018-10-29 18:08:37 - let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-29 18:08:37 - let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-29 18:08:37 - let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-29 18:08:37 - let cptWetGrass:Vector[][] = 
2018-10-29 18:08:37 -     [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-29 18:08:37 -             [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-29 18:08:37 -         [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-29 18:08:37 -             [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-29 18:08:37 -     |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-29 18:11:05 - let buildDistributionParameterValues (): DistributionParameterValues =
2018-10-29 18:11:05 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-29 18:11:05 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-29 18:11:05 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-29 18:11:05 -     let cptWetGrass:Vector[][] = 
2018-10-29 18:11:05 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-29 18:11:05 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-29 18:11:05 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-29 18:11:05 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-29 18:11:05 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-29 18:11:05 -     {cloudy=probCloudy;sprinker=cptSprinkler;rain=cptRain;wetGrass=cptWetGrass}
2018-10-29 18:11:06 - The record type 'DistributionParameterValues' does not contain a label 'sprinker'. Maybe you want one of the following:
2018-10-29 18:11:06 -    sprinkler
2018-10-29 18:11:22 - let buildDistributionParameterValues (): DistributionParameterValues =
2018-10-29 18:11:22 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-29 18:11:22 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-29 18:11:22 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-29 18:11:22 -     let cptWetGrass:Vector[][] = 
2018-10-29 18:11:22 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-29 18:11:22 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-29 18:11:22 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-29 18:11:22 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-29 18:11:22 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-29 18:11:22 -     {cloudy=probCloudy;sprinkler=cptSprinkler;rain=cptRain;wetGrass=cptWetGrass}
2018-10-29 18:12:15 - buildDistributionParameterValues ()
2018-10-29 18:13:58 - let setDistributionParameterValues (): DistributionParameterValues =
2018-10-29 18:13:58 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-29 18:13:58 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-29 18:13:58 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-29 18:13:58 -     let cptWetGrass:Vector[][] = 
2018-10-29 18:13:58 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-29 18:13:58 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-29 18:13:58 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-29 18:13:58 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-29 18:13:58 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-29 18:13:58 -     {cloudy=probCloudy;sprinkler=cptSprinkler;rain=cptRain;wetGrass=cptWetGrass}
2018-10-29 18:14:05 - let setDistributionParameterValues (): DistributionParameterValues =
2018-10-29 18:14:05 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-29 18:14:05 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-29 18:14:05 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-29 18:14:05 -     let cptWetGrass:Vector[][] = 
2018-10-29 18:14:05 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-29 18:14:05 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-29 18:14:05 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-29 18:14:05 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-29 18:14:05 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-29 18:14:05 -     {cloudy=probCloudy;sprinkler=cptSprinkler;rain=cptRain;wetGrass=cptWetGrass}
2018-10-29 18:14:08 - setDistributionParameterValues ()
2018-10-29 18:14:33 - let setDistributionParameterValues (): DistributionParameterValues =
2018-10-29 18:14:33 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-29 18:14:33 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-29 18:14:33 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-29 18:14:33 -     let cptWetGrass:Vector[][] = 
2018-10-29 18:14:33 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-29 18:14:33 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-29 18:14:33 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-29 18:14:33 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-29 18:14:33 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-29 18:14:33 -     {cloudy=probCloudy; sprinkler=cptSprinkler; rain=cptRain; wetGrass=cptWetGrass}
2018-10-29 18:16:59 - let dpv = setDistributionParameterValues ()
2018-10-29 18:17:17 - Sample 10 dpv
2018-10-29 18:17:30 - Sample 100 dpv
2018-10-29 18:22:16 - Reporting 0 opened comms
2018-10-29 18:22:17 - #load "Paket.fsx"
2018-10-29 18:22:20 - Paket.Package
2018-10-29 18:22:20 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-29 18:22:20 -       "Microsoft.ML.Probabilistic"
2018-10-29 18:22:20 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-29 18:22:20 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-29 18:22:20 -       "NETStandard.Library"
2018-10-29 18:22:20 -   ]
2018-10-29 18:24:02 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-29 18:24:09 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-29 18:25:29 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-29 18:25:29 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-29 18:25:29 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-29 18:25:30 - #r "Microsoft.ML.Probabilistic"
2018-10-29 18:25:30 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-29 18:25:30 - #r "netstandard"
2018-10-29 18:25:31 - open System
2018-10-29 18:25:31 - open Microsoft.ML.Probabilistic  
2018-10-29 18:25:31 - open Microsoft.ML.Probabilistic.Models  
2018-10-29 18:25:31 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-29 18:25:31 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-29 18:25:31 - open Microsoft.ML.Probabilistic.Math
2018-10-29 18:25:34 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-29 18:25:42 - open Microsoft.ML.Probabilistic.FSharp
2018-10-29 18:25:43 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2018-10-29 18:25:43 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-10-29 18:25:43 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-10-29 18:25:44 - let AddChildFromOneParent 
2018-10-29 18:25:44 -         (parent:RandomVariable) 
2018-10-29 18:25:44 -         (cpt:ConditionalProbabilityTable) =
2018-10-29 18:25:44 -     let r = parent.Range
2018-10-29 18:25:44 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 18:25:44 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-29 18:25:44 -                        Variable.Discrete(cpt.[pi])))
2018-10-29 18:25:44 -     child
2018-10-29 18:25:44 - type ConditionalProbabilityTable2D = 
2018-10-29 18:25:44 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-29 18:25:45 - let AddChildFromTwoParents 
2018-10-29 18:25:45 -         (parent1:RandomVariable) 
2018-10-29 18:25:45 -         (parent2:RandomVariable) 
2018-10-29 18:25:45 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-29 18:25:45 -     let r = parent1.Range
2018-10-29 18:25:45 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-29 18:25:45 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-29 18:25:45 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-29 18:25:45 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-29 18:25:45 -     child       
2018-10-29 18:25:45 - type RandomVariables =
2018-10-29 18:25:45 -     {cloudy:VariableArray<int>;
2018-10-29 18:25:45 -     sprinkler:VariableArray<int>;
2018-10-29 18:25:45 -     rain:VariableArray<int>;
2018-10-29 18:25:45 -     wetGrass:VariableArray<int> }
2018-10-29 18:25:46 - type ObservedValues =
2018-10-29 18:25:46 -     {cloudy:array<int>;
2018-10-29 18:25:46 -     sprinkler:array<int>;
2018-10-29 18:25:46 -     rain:array<int>;
2018-10-29 18:25:46 -     wetGrass:array<int> }
2018-10-29 18:25:47 - type DistributionParameters =
2018-10-29 18:25:47 -     {cloudy:Variable<Vector> ;
2018-10-29 18:25:47 -     sprinkler:VariableArray<Vector> ;
2018-10-29 18:25:47 -     rain:VariableArray<Vector> ;
2018-10-29 18:25:47 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-29 18:25:48 - type DistributionParameterValues =  
2018-10-29 18:25:48 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-29 18:25:48 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-29 18:25:48 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-29 18:25:48 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-29 18:25:48 -     }
2018-10-29 18:25:48 - type PriorDistributions =
2018-10-29 18:25:48 -     {cloudy:Variable<Dirichlet> ;
2018-10-29 18:25:48 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-29 18:25:48 -     rain:VariableArray<Dirichlet> ;
2018-10-29 18:25:48 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-29 18:25:49 - type PosteriorDistributions =
2018-10-29 18:25:49 -     {cloudy:Dirichlet ;
2018-10-29 18:25:49 -     sprinkler:Dirichlet[] ;
2018-10-29 18:25:49 -     rain:Dirichlet[] ;
2018-10-29 18:25:49 -     wetGrass:Dirichlet[][] }
2018-10-29 18:25:50 - let engine =  InferenceEngine ()
2018-10-29 18:25:51 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 18:25:51 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 18:25:52 - let rC = Range(2).Named("C") // Cloudy
2018-10-29 18:25:52 - let rS = Range(2).Named("S") // Sprinkler
2018-10-29 18:25:52 - let rR = Range(2).Named("R") // Rain
2018-10-29 18:25:52 - let rW = Range(2).Named("W") // Wet
2018-10-29 18:25:52 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-29 18:25:52 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-29 18:25:52 - probCloudy.SetValueRange(rC)
2018-10-29 18:25:53 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-29 18:25:53 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-29 18:25:54 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2018-10-29 18:25:54 - cptSprinkler.SetValueRange(rS)
2018-10-29 18:25:55 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-29 18:25:55 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-29 18:25:56 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-29 18:25:56 - cptRain.SetValueRange(rR)
2018-10-29 18:25:57 - let cptWetGrassPrior= 
2018-10-29 18:25:57 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 18:25:57 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-29 18:25:57 - let cptWetGrass = 
2018-10-29 18:25:57 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 18:25:57 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-29 18:25:58 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-10-29 18:25:58 - cptWetGrass.SetValueRange(rW)
2018-10-29 18:25:58 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-29 18:25:59 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-29 18:25:59 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-29 18:25:59 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-29 18:25:59 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-29 18:25:59 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-29 18:25:59 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-29 18:26:00 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-29 18:26:00 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-29 18:26:00 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-29 18:26:00 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-29 18:26:00 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-29 18:26:00 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-29 18:26:00 -     probCloudy.SetValueRange(rg.c)
2018-10-29 18:26:00 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-29 18:26:00 -     cptSprinkler.SetValueRange(rg.s)
2018-10-29 18:26:00 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-29 18:26:00 -     cptRain.SetValueRange(rg.r)
2018-10-29 18:26:00 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-29 18:26:00 -     cptWetGrass.SetValueRange(rg.w)
2018-10-29 18:26:00 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-29 18:26:01 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-29 18:26:01 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-29 18:26:02 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-29 18:26:02 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-10-29 18:44:26 - let learnParameters (engine:InferenceEngine)
2018-10-29 18:44:26 -                     (numberOfExamples:Variable<int>)
2018-10-29 18:44:26 -                     (rvs:RandomVariables)
2018-10-29 18:44:26 -                     (prs:PriorDistributions)
2018-10-29 18:44:26 -                     (obs:ObservedValues)
2018-10-29 18:44:26 -                     (obsPriors:PriorDistributions) =
2018-10-29 18:44:26 -     do numberOfExamples.ObservedValue <- rvs.cloudy.Length
2018-10-29 18:44:26 -     do rvs.cloudy.ObservedValue <- obs.cloudy
2018-10-29 18:44:26 -     do rvs.sprinkler.ObservedValue <- obs.sprinkler
2018-10-29 18:44:26 -     do rvs.rain.ObservedValue <- obs.rain
2018-10-29 18:44:26 -     do rvs.wetGrass.ObservedValue <- obs.wetGrass
2018-10-29 18:44:26 -     
2018-10-29 18:44:26 -     do probCloudyPrior.ObservedValue <- probCloudyPriorObs
2018-10-29 18:44:26 -     do cptSprinklerPrior.ObservedValue <- cptSprinklerPriorObs
2018-10-29 18:44:26 -     do cptRainPrior.ObservedValue <- cptRainPriorObs
2018-10-29 18:44:26 -     do cptWetGrassPrior.ObservedValue <- cptWetGrassPriorObs
2018-10-29 18:44:26 -     // Inference 
2018-10-29 18:44:26 -     {probCloudyPosterior=engine.Infer<Dirichlet>(probCloudy);  
2018-10-29 18:44:26 -         cptSprinklerPosterior=engine.Infer<Dirichlet[]>(cptSprinkler);  
2018-10-29 18:44:26 -         cptRainPosterior=engine.Infer<Dirichlet[]>(cptRain);  
2018-10-29 18:44:26 -         cptWetGrassPosterior=engine.Infer<Dirichlet[][]>(cptWetGrass)}
2018-10-29 18:44:28 - The field, constructor or member 'Length' is not defined.
2018-10-29 18:44:28 - The value or constructor 'probCloudyPriorObs' is not defined. Maybe you want one of the following:
2018-10-29 18:44:28 -    probCloudyPrior
2018-10-29 18:44:28 -    probCloudy
2018-10-29 18:44:28 - The value or constructor 'cptSprinklerPriorObs' is not defined. Maybe you want one of the following:
2018-10-29 18:44:28 -    cptSprinklerPrior
2018-10-29 18:44:28 -    cptSprinkler
2018-10-29 18:44:28 - The value or constructor 'cptRainPriorObs' is not defined. Maybe you want one of the following:
2018-10-29 18:44:28 -    cptRainPrior
2018-10-29 18:44:28 -    cptRain
2018-10-29 18:44:28 - The value or constructor 'cptWetGrassPriorObs' is not defined. Maybe you want one of the following:
2018-10-29 18:44:28 -    cptWetGrassPrior
2018-10-29 18:44:28 -    cptWetGrass
2018-10-29 18:44:28 - The record label 'probCloudyPosterior' is not defined.
2018-10-29 18:44:58 - let learnParameters (engine:InferenceEngine)
2018-10-29 18:44:58 -                     (numberOfExamples:Variable<int>)
2018-10-29 18:44:58 -                     (rvs:RandomVariables)
2018-10-29 18:44:58 -                     (prs:PriorDistributions)
2018-10-29 18:44:58 -                     (obs:ObservedValues)
2018-10-29 18:44:58 -                     (obsPriors:PriorDistributions) =
2018-10-29 18:44:58 -     do numberOfExamples.ObservedValue <- 3 // rvs.cloudy.Length
2018-10-29 18:44:58 -     do rvs.cloudy.ObservedValue <- obs.cloudy
2018-10-29 18:44:58 -     do rvs.sprinkler.ObservedValue <- obs.sprinkler
2018-10-29 18:44:58 -     do rvs.rain.ObservedValue <- obs.rain
2018-10-29 18:44:58 -     do rvs.wetGrass.ObservedValue <- obs.wetGrass
2018-10-29 18:44:58 -     
2018-10-29 18:44:58 -     do probCloudyPrior.ObservedValue <- probCloudyPriorObs
2018-10-29 18:44:58 -     do cptSprinklerPrior.ObservedValue <- cptSprinklerPriorObs
2018-10-29 18:44:58 -     do cptRainPrior.ObservedValue <- cptRainPriorObs
2018-10-29 18:44:58 -     do cptWetGrassPrior.ObservedValue <- cptWetGrassPriorObs
2018-10-29 18:44:58 -     // Inference 
2018-10-29 18:44:58 -     {probCloudyPosterior=engine.Infer<Dirichlet>(probCloudy);  
2018-10-29 18:44:58 -         cptSprinklerPosterior=engine.Infer<Dirichlet[]>(cptSprinkler);  
2018-10-29 18:44:58 -         cptRainPosterior=engine.Infer<Dirichlet[]>(cptRain);  
2018-10-29 18:44:58 -         cptWetGrassPosterior=engine.Infer<Dirichlet[][]>(cptWetGrass)}
2018-10-29 18:44:59 - The value or constructor 'probCloudyPriorObs' is not defined. Maybe you want one of the following:
2018-10-29 18:44:59 -    probCloudyPrior
2018-10-29 18:44:59 -    probCloudy
2018-10-29 18:44:59 - The value or constructor 'cptSprinklerPriorObs' is not defined. Maybe you want one of the following:
2018-10-29 18:44:59 -    cptSprinklerPrior
2018-10-29 18:44:59 -    cptSprinkler
2018-10-29 18:44:59 - The value or constructor 'cptRainPriorObs' is not defined. Maybe you want one of the following:
2018-10-29 18:44:59 -    cptRainPrior
2018-10-29 18:44:59 -    cptRain
2018-10-29 18:44:59 - The value or constructor 'cptWetGrassPriorObs' is not defined. Maybe you want one of the following:
2018-10-29 18:44:59 -    cptWetGrassPrior
2018-10-29 18:44:59 -    cptWetGrass
2018-10-29 18:44:59 - The record label 'probCloudyPosterior' is not defined.
2018-10-29 21:08:07 - let learnParameters (engine:InferenceEngine)
2018-10-29 21:08:07 -                     (numberOfExamples:Variable<int>)
2018-10-29 21:08:07 -                     (rvs:RandomVariables)
2018-10-29 21:08:07 -                     (prs:PriorDistributions)
2018-10-29 21:08:07 -                     (obs:ObservedValues)
2018-10-29 21:08:07 -                     (obsPriors:PosteriorDistributions) =
2018-10-29 21:08:07 -     do numberOfExamples.ObservedValue <- 3 // rvs.cloudy.Length
2018-10-29 21:08:07 -     do rvs.cloudy.ObservedValue <- obs.cloudy
2018-10-29 21:08:07 -     do rvs.sprinkler.ObservedValue <- obs.sprinkler
2018-10-29 21:08:07 -     do rvs.rain.ObservedValue <- obs.rain
2018-10-29 21:08:07 -     do rvs.wetGrass.ObservedValue <- obs.wetGrass
2018-10-29 21:08:07 -     
2018-10-29 21:08:07 -     do probCloudyPrior.ObservedValue <- obsPriors.cloudy
2018-10-29 21:08:07 -     do cptSprinklerPrior.ObservedValue <- obsPriors.sprinkler
2018-10-29 21:08:07 -     do cptRainPrior.ObservedValue <- obsPriors.rain
2018-10-29 21:08:07 -     do cptWetGrassPrior.ObservedValue <- obsPriors.wetGrass
2018-10-29 21:08:07 -     // Inference 
2018-10-29 21:08:07 -     {probCloudyPosterior=engine.Infer<Dirichlet>(probCloudy);  
2018-10-29 21:08:07 -         cptSprinklerPosterior=engine.Infer<Dirichlet[]>(cptSprinkler);  
2018-10-29 21:08:07 -         cptRainPosterior=engine.Infer<Dirichlet[]>(cptRain);  
2018-10-29 21:08:07 -         cptWetGrassPosterior=engine.Infer<Dirichlet[][]>(cptWetGrass)}
2018-10-29 21:08:09 - The record label 'probCloudyPosterior' is not defined.
2018-10-29 21:09:18 - let learnParameters (engine:InferenceEngine)
2018-10-29 21:09:18 -                     (numberOfExamples:Variable<int>)
2018-10-29 21:09:18 -                     (rvs:RandomVariables)
2018-10-29 21:09:18 -                     (prs:PriorDistributions)
2018-10-29 21:09:18 -                     (obs:ObservedValues)
2018-10-29 21:09:18 -                     (obsPriors:PosteriorDistributions) =
2018-10-29 21:09:18 -     do numberOfExamples.ObservedValue <- 3 // rvs.cloudy.Length
2018-10-29 21:09:18 -     do rvs.cloudy.ObservedValue <- obs.cloudy
2018-10-29 21:09:18 -     do rvs.sprinkler.ObservedValue <- obs.sprinkler
2018-10-29 21:09:18 -     do rvs.rain.ObservedValue <- obs.rain
2018-10-29 21:09:18 -     do rvs.wetGrass.ObservedValue <- obs.wetGrass
2018-10-29 21:09:18 -     
2018-10-29 21:09:18 -     do probCloudyPrior.ObservedValue <- obsPriors.cloudy
2018-10-29 21:09:18 -     do cptSprinklerPrior.ObservedValue <- obsPriors.sprinkler
2018-10-29 21:09:18 -     do cptRainPrior.ObservedValue <- obsPriors.rain
2018-10-29 21:09:18 -     do cptWetGrassPrior.ObservedValue <- obsPriors.wetGrass
2018-10-29 21:09:18 -     // Inference 
2018-10-29 21:09:18 -     {probCloudyPosterior=engine.Infer<Dirichlet>(prs.cloudy);  
2018-10-29 21:09:18 -         cptSprinklerPosterior=engine.Infer<Dirichlet[]>(prs.sprinker);  
2018-10-29 21:09:18 -         cptRainPosterior=engine.Infer<Dirichlet[]>(prs.rain);  
2018-10-29 21:09:18 -         cptWetGrassPosterior=engine.Infer<Dirichlet[][]>(prs.wetGrass)}
2018-10-29 21:09:19 - The record label 'probCloudyPosterior' is not defined.
2018-10-29 21:10:18 - let learnParameters (engine:InferenceEngine)
2018-10-29 21:10:18 -                     (numberOfExamples:Variable<int>)
2018-10-29 21:10:18 -                     (rvs:RandomVariables)
2018-10-29 21:10:18 -                     (prs:PriorDistributions)
2018-10-29 21:10:18 -                     (obs:ObservedValues)
2018-10-29 21:10:18 -                     (obsPriors:PosteriorDistributions) =
2018-10-29 21:10:18 -     do numberOfExamples.ObservedValue <- 3 // rvs.cloudy.Length
2018-10-29 21:10:18 -     do rvs.cloudy.ObservedValue <- obs.cloudy
2018-10-29 21:10:18 -     do rvs.sprinkler.ObservedValue <- obs.sprinkler
2018-10-29 21:10:18 -     do rvs.rain.ObservedValue <- obs.rain
2018-10-29 21:10:18 -     do rvs.wetGrass.ObservedValue <- obs.wetGrass
2018-10-29 21:10:18 -     
2018-10-29 21:10:18 -     do prs.cloudy.ObservedValue <- obsPriors.cloudy
2018-10-29 21:10:18 -     do prs.sprinkler.ObservedValue <- obsPriors.sprinkler
2018-10-29 21:10:18 -     do prs.rain.ObservedValue <- obsPriors.rain
2018-10-29 21:10:18 -     do prs.wetGrass.ObservedValue <- obsPriors.wetGrass
2018-10-29 21:10:18 -     // Inference 
2018-10-29 21:10:18 -     {probCloudyPosterior=engine.Infer<Dirichlet>(prs.cloudy);  
2018-10-29 21:10:18 -         cptSprinklerPosterior=engine.Infer<Dirichlet[]>(prs.sprinker);  
2018-10-29 21:10:18 -         cptRainPosterior=engine.Infer<Dirichlet[]>(prs.rain);  
2018-10-29 21:10:18 -         cptWetGrassPosterior=engine.Infer<Dirichlet[][]>(prs.wetGrass)}
2018-10-29 21:10:19 - The record label 'probCloudyPosterior' is not defined.
2018-10-29 21:11:44 - let learnParameters (engine:InferenceEngine)
2018-10-29 21:11:44 -                     (numberOfExamples:Variable<int>)
2018-10-29 21:11:44 -                     (rvs:RandomVariables)
2018-10-29 21:11:44 -                     (prs:PriorDistributions)
2018-10-29 21:11:44 -                     (obs:ObservedValues)
2018-10-29 21:11:44 -                     (obsPriors:PosteriorDistributions):PosteriorDistributions =
2018-10-29 21:11:44 -     do numberOfExamples.ObservedValue <- 3 // rvs.cloudy.Length
2018-10-29 21:11:44 -     do rvs.cloudy.ObservedValue <- obs.cloudy
2018-10-29 21:11:44 -     do rvs.sprinkler.ObservedValue <- obs.sprinkler
2018-10-29 21:11:44 -     do rvs.rain.ObservedValue <- obs.rain
2018-10-29 21:11:44 -     do rvs.wetGrass.ObservedValue <- obs.wetGrass
2018-10-29 21:11:44 -     
2018-10-29 21:11:44 -     do prs.cloudy.ObservedValue <- obsPriors.cloudy
2018-10-29 21:11:44 -     do prs.sprinkler.ObservedValue <- obsPriors.sprinkler
2018-10-29 21:11:44 -     do prs.rain.ObservedValue <- obsPriors.rain
2018-10-29 21:11:44 -     do prs.wetGrass.ObservedValue <- obsPriors.wetGrass
2018-10-29 21:11:44 -     // Inference 
2018-10-29 21:11:44 -     {cloudy=engine.Infer<Dirichlet>(prs.cloudy);  
2018-10-29 21:11:44 -         sprinkler=engine.Infer<Dirichlet[]>(prs.sprinker);  
2018-10-29 21:11:44 -         rain=engine.Infer<Dirichlet[]>(prs.rain);  
2018-10-29 21:11:44 -         wetGrass=engine.Infer<Dirichlet[][]>(prs.wetGrass)}
2018-10-29 21:11:45 - The field, constructor or member 'sprinker' is not defined. Maybe you want one of the following:
2018-10-29 21:11:45 -    sprinkler
2018-10-29 21:12:01 - let learnParameters (engine:InferenceEngine)
2018-10-29 21:12:01 -                     (numberOfExamples:Variable<int>)
2018-10-29 21:12:01 -                     (rvs:RandomVariables)
2018-10-29 21:12:01 -                     (prs:PriorDistributions)
2018-10-29 21:12:01 -                     (obs:ObservedValues)
2018-10-29 21:12:01 -                     (obsPriors:PosteriorDistributions):PosteriorDistributions =
2018-10-29 21:12:01 -     do numberOfExamples.ObservedValue <- 3 // rvs.cloudy.Length
2018-10-29 21:12:01 -     do rvs.cloudy.ObservedValue <- obs.cloudy
2018-10-29 21:12:01 -     do rvs.sprinkler.ObservedValue <- obs.sprinkler
2018-10-29 21:12:01 -     do rvs.rain.ObservedValue <- obs.rain
2018-10-29 21:12:01 -     do rvs.wetGrass.ObservedValue <- obs.wetGrass
2018-10-29 21:12:01 -     
2018-10-29 21:12:01 -     do prs.cloudy.ObservedValue <- obsPriors.cloudy
2018-10-29 21:12:01 -     do prs.sprinkler.ObservedValue <- obsPriors.sprinkler
2018-10-29 21:12:01 -     do prs.rain.ObservedValue <- obsPriors.rain
2018-10-29 21:12:01 -     do prs.wetGrass.ObservedValue <- obsPriors.wetGrass
2018-10-29 21:12:01 -     // Inference 
2018-10-29 21:12:01 -     {cloudy=engine.Infer<Dirichlet>(prs.cloudy);  
2018-10-29 21:12:01 -         sprinkler=engine.Infer<Dirichlet[]>(prs.sprinkler);  
2018-10-29 21:12:01 -         rain=engine.Infer<Dirichlet[]>(prs.rain);  
2018-10-29 21:12:01 -         wetGrass=engine.Infer<Dirichlet[][]>(prs.wetGrass)}
2018-10-29 21:12:53 - let learnParameters (engine:InferenceEngine)
2018-10-29 21:12:53 -                     (numberOfExamples:Variable<int>)
2018-10-29 21:12:53 -                     (rvs:RandomVariables)
2018-10-29 21:12:53 -                     (prs:PriorDistributions)
2018-10-29 21:12:53 -                     (obs:ObservedValues)
2018-10-29 21:12:53 -                     (obsPriors:PosteriorDistributions):PosteriorDistributions =
2018-10-29 21:12:53 -     do numberOfExamples.ObservedValue <- obs.cloudy.Length
2018-10-29 21:12:53 -     do rvs.cloudy.ObservedValue <- obs.cloudy
2018-10-29 21:12:53 -     do rvs.sprinkler.ObservedValue <- obs.sprinkler
2018-10-29 21:12:53 -     do rvs.rain.ObservedValue <- obs.rain
2018-10-29 21:12:53 -     do rvs.wetGrass.ObservedValue <- obs.wetGrass
2018-10-29 21:12:53 -     
2018-10-29 21:12:53 -     do prs.cloudy.ObservedValue <- obsPriors.cloudy
2018-10-29 21:12:53 -     do prs.sprinkler.ObservedValue <- obsPriors.sprinkler
2018-10-29 21:12:53 -     do prs.rain.ObservedValue <- obsPriors.rain
2018-10-29 21:12:53 -     do prs.wetGrass.ObservedValue <- obsPriors.wetGrass
2018-10-29 21:12:53 -     // Inference 
2018-10-29 21:12:53 -     {cloudy=engine.Infer<Dirichlet>(prs.cloudy);  
2018-10-29 21:12:53 -         sprinkler=engine.Infer<Dirichlet[]>(prs.sprinkler);  
2018-10-29 21:12:53 -         rain=engine.Infer<Dirichlet[]>(prs.rain);  
2018-10-29 21:12:53 -         wetGrass=engine.Infer<Dirichlet[][]>(prs.wetGrass)}
2018-10-29 21:13:58 - Sample 10 dpv
2018-10-30 13:08:29 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-10-30 13:08:29 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-10-30 13:08:29 - For help type #help;;
2018-10-30 13:08:29 - > val it :
2018-10-30 13:08:29 -   ResizeArray<System.Type *
2018-10-30 13:08:29 -               (obj ->
2018-10-30 13:08:29 -                  seq<string *
2018-10-30 13:08:29 -                      string> *
2018-10-30 13:08:29 -                  string)>
2018-10-30 13:08:29 - = seq []
2018-10-30 13:08:29 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-10-30 13:08:29 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-10-30 13:08:29 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-10-30 13:08:30 - Reporting 0 opened comms
2018-10-30 13:08:30 - #load "Paket.fsx"
2018-10-30 13:08:49 - Paket.Package
2018-10-30 13:08:49 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-30 13:08:49 -       "Microsoft.ML.Probabilistic"
2018-10-30 13:08:49 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-30 13:08:49 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-30 13:08:49 -       "NETStandard.Library"
2018-10-30 13:08:49 -   ]
2018-10-30 13:10:55 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-30 13:11:05 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-30 13:11:53 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-30 13:11:53 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-30 13:11:53 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-30 13:11:53 - #r "Microsoft.ML.Probabilistic"
2018-10-30 13:11:53 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-30 13:11:53 - #r "netstandard"
2018-10-30 13:11:55 - open System
2018-10-30 13:11:55 - open Microsoft.ML.Probabilistic  
2018-10-30 13:11:55 - open Microsoft.ML.Probabilistic.Models  
2018-10-30 13:11:55 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-30 13:11:55 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-30 13:11:55 - open Microsoft.ML.Probabilistic.Math
2018-10-30 13:11:57 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-30 13:12:02 - open Microsoft.ML.Probabilistic.FSharp
2018-10-30 13:12:03 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2018-10-30 13:12:03 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-10-30 13:12:03 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-10-30 13:12:03 - let AddChildFromOneParent 
2018-10-30 13:12:03 -         (parent:RandomVariable) 
2018-10-30 13:12:03 -         (cpt:ConditionalProbabilityTable) =
2018-10-30 13:12:03 -     let r = parent.Range
2018-10-30 13:12:03 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 13:12:03 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-30 13:12:03 -                        Variable.Discrete(cpt.[pi])))
2018-10-30 13:12:03 -     child
2018-10-30 13:12:04 - type ConditionalProbabilityTable2D = 
2018-10-30 13:12:04 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-30 13:12:04 - let AddChildFromTwoParents 
2018-10-30 13:12:04 -         (parent1:RandomVariable) 
2018-10-30 13:12:04 -         (parent2:RandomVariable) 
2018-10-30 13:12:04 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-30 13:12:04 -     let r = parent1.Range
2018-10-30 13:12:04 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 13:12:04 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-30 13:12:04 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-30 13:12:04 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-30 13:12:04 -     child       
2018-10-30 13:12:04 - type RandomVariables =
2018-10-30 13:12:04 -     {cloudy:VariableArray<int>;
2018-10-30 13:12:04 -     sprinkler:VariableArray<int>;
2018-10-30 13:12:04 -     rain:VariableArray<int>;
2018-10-30 13:12:04 -     wetGrass:VariableArray<int> }
2018-10-30 13:12:06 - type ObservedValues =
2018-10-30 13:12:06 -     {cloudy:array<int>;
2018-10-30 13:12:06 -     sprinkler:array<int>;
2018-10-30 13:12:06 -     rain:array<int>;
2018-10-30 13:12:06 -     wetGrass:array<int> }
2018-10-30 13:12:06 - type DistributionParameters =
2018-10-30 13:12:06 -     {cloudy:Variable<Vector> ;
2018-10-30 13:12:06 -     sprinkler:VariableArray<Vector> ;
2018-10-30 13:12:06 -     rain:VariableArray<Vector> ;
2018-10-30 13:12:06 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-30 13:12:07 - type DistributionParameterValues =  
2018-10-30 13:12:07 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-30 13:12:07 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-30 13:12:07 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-30 13:12:07 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-30 13:12:07 -     }
2018-10-30 13:12:07 - type PriorDistributions =
2018-10-30 13:12:07 -     {cloudy:Variable<Dirichlet> ;
2018-10-30 13:12:07 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-30 13:12:07 -     rain:VariableArray<Dirichlet> ;
2018-10-30 13:12:07 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-30 13:12:08 - type PosteriorDistributions =
2018-10-30 13:12:08 -     {cloudy:Dirichlet ;
2018-10-30 13:12:08 -     sprinkler:Dirichlet[] ;
2018-10-30 13:12:08 -     rain:Dirichlet[] ;
2018-10-30 13:12:08 -     wetGrass:Dirichlet[][] }
2018-10-30 13:12:08 - let engine =  InferenceEngine ()
2018-10-30 13:12:09 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 13:12:09 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 13:12:09 - let rC = Range(2).Named("C") // Cloudy
2018-10-30 13:12:09 - let rS = Range(2).Named("S") // Sprinkler
2018-10-30 13:12:09 - let rR = Range(2).Named("R") // Rain
2018-10-30 13:12:09 - let rW = Range(2).Named("W") // Wet
2018-10-30 13:12:10 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-30 13:12:10 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-30 13:12:10 - probCloudy.SetValueRange(rC)
2018-10-30 13:12:10 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-30 13:12:10 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-30 13:12:11 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2018-10-30 13:12:11 - cptSprinkler.SetValueRange(rS)
2018-10-30 13:12:11 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-30 13:12:11 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-30 13:12:12 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-30 13:12:12 - cptRain.SetValueRange(rR)
2018-10-30 13:12:12 - let cptWetGrassPrior= 
2018-10-30 13:12:12 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 13:12:12 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-30 13:12:12 - let cptWetGrass = 
2018-10-30 13:12:12 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 13:12:12 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-30 13:12:13 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-10-30 13:12:13 - cptWetGrass.SetValueRange(rW)
2018-10-30 13:12:13 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-30 13:12:15 - The type 'Ranges' is not defined. Maybe you want one of the following:
2018-10-30 13:12:15 -    Range
2018-10-30 13:12:15 - The record label 'c' is not defined.
2018-10-30 13:12:15 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-30 13:12:15 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-30 13:12:15 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-30 13:12:15 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-30 13:12:15 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 13:12:15 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-30 13:12:16 - The type 'Ranges' is not defined. Maybe you want one of the following:
2018-10-30 13:12:16 -    Range
2018-10-30 13:12:16 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-30 13:12:16 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2018-10-30 13:12:16 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-30 13:12:16 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2018-10-30 13:12:16 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-30 13:12:16 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2018-10-30 13:12:16 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-30 13:12:16 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(array: VariableArray<'TItem,'TArray>, r: Range) : VariableArray<VariableArray<'TItem,'TArray>,'TArray []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(itemPrototype: 'TItem, r: Range) : VariableArray<'TItem,'TArray>
2018-10-30 13:12:16 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-30 13:12:16 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-30 13:12:16 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-30 13:12:16 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-30 13:12:16 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 13:12:16 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-30 13:12:16 -     probCloudy.SetValueRange(rg.c)
2018-10-30 13:12:16 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-30 13:12:16 -     cptSprinkler.SetValueRange(rg.s)
2018-10-30 13:12:16 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-30 13:12:16 -     cptRain.SetValueRange(rg.r)
2018-10-30 13:12:16 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-30 13:12:16 -     cptWetGrass.SetValueRange(rg.w)
2018-10-30 13:12:16 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-30 13:12:17 - The type 'Ranges' is not defined. Maybe you want one of the following:
2018-10-30 13:12:17 -    Range
2018-10-30 13:12:17 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-30 13:12:17 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2018-10-30 13:12:17 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-30 13:12:17 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2018-10-30 13:12:17 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-30 13:12:17 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2018-10-30 13:12:17 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-30 13:12:17 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(array: VariableArray<'TItem,'TArray>, r: Range) : VariableArray<VariableArray<'TItem,'TArray>,'TArray []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(itemPrototype: 'TItem, r: Range) : VariableArray<'TItem,'TArray>
2018-10-30 13:12:17 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-30 13:12:17 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-30 13:12:17 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-30 13:12:17 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-30 13:12:17 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-30 13:12:17 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-30 13:12:17 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-10-30 13:12:17 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-10-30 13:12:17 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 13:12:17 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 13:12:18 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-30 13:12:18 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-10-30 13:12:18 - #load "Paket.fsx"
2018-10-30 13:12:39 - Paket.Package
2018-10-30 13:12:39 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-30 13:12:39 -       "Microsoft.ML.Probabilistic"
2018-10-30 13:12:39 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-30 13:12:39 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-30 13:12:39 -       "NETStandard.Library"
2018-10-30 13:12:39 -   ]
2018-10-30 13:13:38 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-30 13:13:43 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-30 13:14:28 - //#load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-30 13:14:28 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-30 13:14:28 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-30 13:14:28 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-30 13:14:29 - #r "Microsoft.ML.Probabilistic"
2018-10-30 13:14:29 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-30 13:14:29 - #r "netstandard"
2018-10-30 13:14:29 - open System
2018-10-30 13:14:30 - open Microsoft.ML.Probabilistic  
2018-10-30 13:14:30 - open Microsoft.ML.Probabilistic.Models  
2018-10-30 13:14:30 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-30 13:14:30 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-30 13:14:30 - open Microsoft.ML.Probabilistic.Math
2018-10-30 13:14:31 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-30 13:14:36 - open Microsoft.ML.Probabilistic.FSharp
2018-10-30 13:14:36 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2018-10-30 13:14:36 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-10-30 13:14:37 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-10-30 13:14:37 - let AddChildFromOneParent 
2018-10-30 13:14:37 -         (parent:RandomVariable) 
2018-10-30 13:14:37 -         (cpt:ConditionalProbabilityTable) =
2018-10-30 13:14:37 -     let r = parent.Range
2018-10-30 13:14:37 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 13:14:37 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-30 13:14:37 -                        Variable.Discrete(cpt.[pi])))
2018-10-30 13:14:37 -     child
2018-10-30 13:14:37 - type ConditionalProbabilityTable2D = 
2018-10-30 13:14:37 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-30 13:14:38 - let AddChildFromTwoParents 
2018-10-30 13:14:38 -         (parent1:RandomVariable) 
2018-10-30 13:14:38 -         (parent2:RandomVariable) 
2018-10-30 13:14:38 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-30 13:14:38 -     let r = parent1.Range
2018-10-30 13:14:38 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 13:14:38 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-30 13:14:38 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-30 13:14:38 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-30 13:14:38 -     child       
2018-10-30 13:14:38 - type RandomVariables =
2018-10-30 13:14:38 -     {cloudy:VariableArray<int>;
2018-10-30 13:14:38 -     sprinkler:VariableArray<int>;
2018-10-30 13:14:38 -     rain:VariableArray<int>;
2018-10-30 13:14:38 -     wetGrass:VariableArray<int> }
2018-10-30 13:14:39 - type ObservedValues =
2018-10-30 13:14:39 -     {cloudy:array<int>;
2018-10-30 13:14:39 -     sprinkler:array<int>;
2018-10-30 13:14:39 -     rain:array<int>;
2018-10-30 13:14:39 -     wetGrass:array<int> }
2018-10-30 13:14:39 - type DistributionParameters =
2018-10-30 13:14:39 -     {cloudy:Variable<Vector> ;
2018-10-30 13:14:39 -     sprinkler:VariableArray<Vector> ;
2018-10-30 13:14:39 -     rain:VariableArray<Vector> ;
2018-10-30 13:14:39 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-30 13:14:40 - type DistributionParameterValues =  
2018-10-30 13:14:40 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-30 13:14:40 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-30 13:14:40 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-30 13:14:40 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-30 13:14:40 -     }
2018-10-30 13:14:40 - type PriorDistributions =
2018-10-30 13:14:40 -     {cloudy:Variable<Dirichlet> ;
2018-10-30 13:14:40 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-30 13:14:40 -     rain:VariableArray<Dirichlet> ;
2018-10-30 13:14:40 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-30 13:14:40 - type PosteriorDistributions =
2018-10-30 13:14:40 -     {cloudy:Dirichlet ;
2018-10-30 13:14:40 -     sprinkler:Dirichlet[] ;
2018-10-30 13:14:40 -     rain:Dirichlet[] ;
2018-10-30 13:14:40 -     wetGrass:Dirichlet[][] }
2018-10-30 13:14:41 - type Ranges = {c:Range;s:Range;r:Range;w:Range}
2018-10-30 13:14:41 - let engine =  InferenceEngine ()
2018-10-30 13:14:42 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 13:14:42 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 13:14:42 - let rC = Range(2).Named("C") // Cloudy
2018-10-30 13:14:42 - let rS = Range(2).Named("S") // Sprinkler
2018-10-30 13:14:42 - let rR = Range(2).Named("R") // Rain
2018-10-30 13:14:42 - let rW = Range(2).Named("W") // Wet
2018-10-30 13:14:42 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-30 13:14:42 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-30 13:14:42 - probCloudy.SetValueRange(rC)
2018-10-30 13:14:43 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-30 13:14:43 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-30 13:14:43 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2018-10-30 13:14:43 - cptSprinkler.SetValueRange(rS)
2018-10-30 13:14:44 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-30 13:14:44 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-30 13:14:44 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-30 13:14:44 - cptRain.SetValueRange(rR)
2018-10-30 13:14:44 - let cptWetGrassPrior= 
2018-10-30 13:14:44 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 13:14:44 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-30 13:14:44 - let cptWetGrass = 
2018-10-30 13:14:44 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 13:14:44 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-30 13:14:45 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-10-30 13:14:45 - cptWetGrass.SetValueRange(rW)
2018-10-30 13:14:45 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-30 13:14:46 - let priors:PriorDistributions = {
2018-10-30 13:14:46 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-30 13:14:46 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-10-30 13:14:46 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-10-30 13:14:46 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 13:14:46 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-10-30 13:14:46 - let parameters:DistributionParameters = {
2018-10-30 13:14:46 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-10-30 13:14:46 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-10-30 13:14:46 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-10-30 13:14:46 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 13:14:46 -                 Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-10-30 13:14:47 - parameters.cloudy.SetValueRange(ranges.c)
2018-10-30 13:14:47 - parameters.sprinkler.[ranges.c] <- Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c])
2018-10-30 13:14:47 - parameters.sprinkler.SetValueRange(ranges.s)
2018-10-30 13:14:47 - parameters.rain.[ranges.c] <- Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c])
2018-10-30 13:14:47 - parameters.rain.SetValueRange(ranges.r)
2018-10-30 13:14:47 - parameters.wetGrass.[ranges.s].[ranges.r] <- Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[ranges.s].[ranges.r])
2018-10-30 13:14:47 - parameters.wetGrass.SetValueRange(ranges.w)
2018-10-30 13:14:47 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-30 13:14:47 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-30 13:14:47 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-30 13:14:47 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-30 13:14:47 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 13:14:47 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-30 13:14:48 - let priors = buildPriors ranges
2018-10-30 13:14:48 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-30 13:14:48 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-30 13:14:48 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-30 13:14:48 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-30 13:14:48 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 13:14:48 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-30 13:14:48 -     probCloudy.SetValueRange(rg.c)
2018-10-30 13:14:48 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-30 13:14:48 -     cptSprinkler.SetValueRange(rg.s)
2018-10-30 13:14:48 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-30 13:14:48 -     cptRain.SetValueRange(rg.r)
2018-10-30 13:14:48 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-30 13:14:48 -     cptWetGrass.SetValueRange(rg.w)
2018-10-30 13:14:48 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-30 13:14:49 - let parameters = buildDistributionParameters ranges priors
2018-10-30 13:14:49 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 13:14:49 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 13:14:49 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-30 13:14:49 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-10-30 13:14:50 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("sprinkler")
2018-10-30 13:14:50 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("rain")
2018-10-30 13:14:50 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("wetGrass")
2018-10-30 13:14:50 - let rvs:RandomVariables =
2018-10-30 13:14:50 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-30 13:14:50 -     vC.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-10-30 13:14:50 -     let vS = (AddChildFromOneParent vC cptSprinkler).Named("sprinkler")
2018-10-30 13:14:50 -     let vR = (AddChildFromOneParent vC cptRain).Named("rain")
2018-10-30 13:14:50 -     let vW = (AddChildFromTwoParents vS vR cptWetGrass).Named("wetGrass")
2018-10-30 13:14:50 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-30 13:14:50 - let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-30 13:14:50 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-30 13:14:50 -     vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-30 13:14:50 -     let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-30 13:14:50 -     let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-10-30 13:14:50 -     let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-30 13:14:50 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-30 13:14:51 - let numberOfExamples = Variable.New<int>().Named("NofE")
2018-10-30 13:14:51 - let rN = Range(numberOfExamples).Named("N")
2018-10-30 13:14:51 - let ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("W")}
2018-10-30 13:14:51 - let priors = buildPriors ranges
2018-10-30 13:14:51 - let parameters = buildDistributionParameters ranges priors
2018-10-30 13:14:51 - let rvs = buildRandomVariables rN parameters
2018-10-30 13:14:52 - let a:array<int> = [|3|]
2018-10-30 13:14:52 - let b:int[] =  [|3|]
2018-10-30 13:14:52 - let c:int[] = a
2018-10-30 13:14:52 - let d:Vector[][] = [|[|Vector.FromArray(2.,3.)|]|]
2018-10-30 13:14:52 - let e:array<array<Vector>> = [|[|Vector.FromArray(2.,3.)|]|]
2018-10-30 13:14:52 - let f:array<array<Vector>> = d
2018-10-30 13:14:52 - type WetGrassSprinklerRainModel() =
2018-10-30 13:14:52 -     
2018-10-30 13:14:52 -     // Private functions (used by constructor)
2018-10-30 13:14:52 -     let addChildFromOneParent 
2018-10-30 13:14:52 -             (parent:RandomVariable) 
2018-10-30 13:14:52 -             (cpt:ConditionalProbabilityTable) =
2018-10-30 13:14:52 -         let r = parent.Range
2018-10-30 13:14:52 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 13:14:52 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-30 13:14:52 -                            Variable.Discrete(cpt.[pi])))
2018-10-30 13:14:52 -         child
2018-10-30 13:14:52 -         
2018-10-30 13:14:52 -     let addChildFromTwoParents 
2018-10-30 13:14:52 -             (parent1:RandomVariable) 
2018-10-30 13:14:52 -             (parent2:RandomVariable) 
2018-10-30 13:14:52 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-30 13:14:52 -         let r = parent1.Range
2018-10-30 13:14:52 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 13:14:52 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-30 13:14:52 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-30 13:14:52 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-30 13:14:52 -         child    
2018-10-30 13:14:52 -         
2018-10-30 13:14:52 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-30 13:14:52 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-30 13:14:52 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-30 13:14:52 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-30 13:14:52 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 13:14:52 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-30 13:14:52 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-30 13:14:52 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-30 13:14:52 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-30 13:14:52 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-30 13:14:52 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 13:14:52 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-30 13:14:52 -         do probCloudy.SetValueRange(rg.c)
2018-10-30 13:14:52 -         do cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-30 13:14:52 -         do cptSprinkler.SetValueRange(rg.s)
2018-10-30 13:14:52 -         do cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-30 13:14:52 -         do cptRain.SetValueRange(rg.r)
2018-10-30 13:14:52 -         do cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-30 13:14:52 -         do cptWetGrass.SetValueRange(rg.w)
2018-10-30 13:14:52 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-30 13:14:52 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-30 13:14:52 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-30 13:14:52 -         do vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-30 13:14:52 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-30 13:14:52 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-30 13:14:52 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-30 13:14:52 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-30 13:14:52 -      
2018-10-30 13:14:52 -     // Private fields
2018-10-30 13:14:52 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-30 13:14:52 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 13:14:52 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 13:14:52 -     let priors = buildPriors ranges
2018-10-30 13:14:52 -     let parameters = buildDistributionParameters ranges priors
2018-10-30 13:14:52 -     let primaryRandomVariables = buildRandomVariables rN parameters
2018-10-30 13:14:52 -     let engine = InferenceEngine ()
2018-10-30 13:14:52 -     
2018-10-30 13:14:52 -     // Properties
2018-10-30 13:14:52 -     member this.Ranges = ranges
2018-10-30 13:14:52 -     member this.NumberOfExamples = numberOfExamples
2018-10-30 13:14:52 -     member this.RangeN = rN
2018-10-30 13:14:52 -     member this.Priors = priors
2018-10-30 13:14:52 -     member this.Parameters = parameters
2018-10-30 13:14:52 -     member this.PrimaryRandomVariables = primaryRandomVariables
2018-10-30 13:14:52 -     member this.Engine = engine
2018-10-30 13:14:54 - let model = WetGrassSprinklerRainModel ()  
2018-10-30 13:14:54 - module WetGrassSprinklerRainModel2 =
2018-10-30 13:14:54 -     // Functions
2018-10-30 13:14:54 -     let addChildFromOneParent 
2018-10-30 13:14:54 -             (parent:RandomVariable) 
2018-10-30 13:14:54 -             (cpt:ConditionalProbabilityTable) =
2018-10-30 13:14:54 -         let r = parent.Range
2018-10-30 13:14:54 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 13:14:54 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-30 13:14:54 -                            Variable.Discrete(cpt.[pi])))
2018-10-30 13:14:54 -         child
2018-10-30 13:14:54 -         
2018-10-30 13:14:54 -     let addChildFromTwoParents 
2018-10-30 13:14:54 -             (parent1:RandomVariable) 
2018-10-30 13:14:54 -             (parent2:RandomVariable) 
2018-10-30 13:14:54 -             (cpt:ConditionalProbabilityTable2D) = 
2018-10-30 13:14:54 -         let r = parent1.Range
2018-10-30 13:14:54 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 13:14:54 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-30 13:14:54 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-30 13:14:54 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-30 13:14:54 -         child    
2018-10-30 13:14:54 -     
2018-10-30 13:14:54 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-30 13:14:54 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-30 13:14:54 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-30 13:14:54 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-30 13:14:54 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 13:14:54 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-30 13:14:54 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-30 13:14:54 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-30 13:14:54 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-30 13:14:54 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-30 13:14:54 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 13:14:54 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-30 13:14:54 -         probCloudy.SetValueRange(rg.c)
2018-10-30 13:14:54 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-30 13:14:54 -         cptSprinkler.SetValueRange(rg.s)
2018-10-30 13:14:54 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-30 13:14:54 -         cptRain.SetValueRange(rg.r)
2018-10-30 13:14:54 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-30 13:14:54 -         cptWetGrass.SetValueRange(rg.w)
2018-10-30 13:14:54 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-30 13:14:54 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-10-30 13:14:54 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-10-30 13:14:54 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-10-30 13:14:54 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-10-30 13:14:54 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-10-30 13:14:54 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-10-30 13:14:54 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-10-30 13:14:55 - open WetGrassSprinklerRainModel2
2018-10-30 13:14:55 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-30 13:14:55 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 13:14:55 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 13:14:55 - let priors = buildPriors ranges
2018-10-30 13:14:55 - let parameters = buildDistributionParameters ranges priors
2018-10-30 13:14:55 - let rvs = buildRandomVariables rN parameters
2018-10-30 13:14:55 - let engine =  InferenceEngine ()
2018-10-30 13:14:56 - let setDistributionParameterValues (): DistributionParameterValues =
2018-10-30 13:14:56 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-30 13:14:56 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-30 13:14:56 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-30 13:14:56 -     let cptWetGrass:Vector[][] = 
2018-10-30 13:14:56 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-30 13:14:56 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-30 13:14:56 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-30 13:14:56 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-30 13:14:56 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-30 13:14:56 -     {cloudy=probCloudy; sprinkler=cptSprinkler; rain=cptRain; wetGrass=cptWetGrass}
2018-10-30 13:14:56 - let dpv = setDistributionParameterValues ()
2018-10-30 13:14:57 - let Sample  (numData:int)
2018-10-30 13:14:57 -             (dpv:DistributionParameterValues) : int[][] =     
2018-10-30 13:14:57 -     Array.init numData (fun _ ->
2018-10-30 13:14:57 -             let cloudy = Discrete.Sample(dpv.cloudy);
2018-10-30 13:14:57 -             let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy]);
2018-10-30 13:14:57 -             let rain = Discrete.Sample(dpv.rain.[cloudy]);
2018-10-30 13:14:57 -             let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]);
2018-10-30 13:14:57 -             [|cloudy;sprinkler;rain;wetGrass|])
2018-10-30 13:14:57 - Sample 10 dpv
2018-10-30 13:14:58 - let learnParameters (engine:InferenceEngine)
2018-10-30 13:14:58 -                     (numberOfExamples:Variable<int>)
2018-10-30 13:14:58 -                     (rvs:RandomVariables)
2018-10-30 13:14:58 -                     (prs:PriorDistributions)
2018-10-30 13:14:58 -                     (obs:ObservedValues)
2018-10-30 13:14:58 -                     (obsPriors:PosteriorDistributions):PosteriorDistributions =
2018-10-30 13:14:58 -     do numberOfExamples.ObservedValue <- obs.cloudy.Length
2018-10-30 13:14:58 -     do rvs.cloudy.ObservedValue <- obs.cloudy
2018-10-30 13:14:58 -     do rvs.sprinkler.ObservedValue <- obs.sprinkler
2018-10-30 13:14:58 -     do rvs.rain.ObservedValue <- obs.rain
2018-10-30 13:14:58 -     do rvs.wetGrass.ObservedValue <- obs.wetGrass
2018-10-30 13:14:58 -     
2018-10-30 13:14:58 -     do prs.cloudy.ObservedValue <- obsPriors.cloudy
2018-10-30 13:14:58 -     do prs.sprinkler.ObservedValue <- obsPriors.sprinkler
2018-10-30 13:14:58 -     do prs.rain.ObservedValue <- obsPriors.rain
2018-10-30 13:14:58 -     do prs.wetGrass.ObservedValue <- obsPriors.wetGrass
2018-10-30 13:14:58 -     // Inference 
2018-10-30 13:14:58 -     {cloudy=engine.Infer<Dirichlet>(prs.cloudy);  
2018-10-30 13:14:58 -         sprinkler=engine.Infer<Dirichlet[]>(prs.sprinkler);  
2018-10-30 13:14:58 -         rain=engine.Infer<Dirichlet[]>(prs.rain);  
2018-10-30 13:14:58 -         wetGrass=engine.Infer<Dirichlet[][]>(prs.wetGrass)}
2018-10-30 13:14:58 - let probRain (cloudy:Option<int>) (sprinkler:Option<int>) = 
2018-10-30 13:14:58 -     match cloudy with 
2018-10-30 13:14:58 -     | Some cloudy -> printfn "the valid value is %A" cloudy
2018-10-30 13:14:58 -     | None -> printfn "the value is None" 
2018-10-30 13:14:58 -     ()
2018-10-30 13:14:59 - probRain (Some 3) None
2018-10-30 13:14:59 - NumberOfExamples.ObservedValue = 1;
2018-10-30 13:15:00 - The value, namespace, type or module 'NumberOfExamples' is not defined. Maybe you want one of the following:
2018-10-30 13:15:00 -    numberOfExamples
2018-10-30 13:15:00 - (*
2018-10-30 13:15:00 - if (cloudy.HasValue)
2018-10-30 13:15:00 -             {
2018-10-30 13:15:00 -                 Cloudy.ObservedValue = new int[] { cloudy.Value };
2018-10-30 13:15:00 -             }
2018-10-30 13:15:00 -             else
2018-10-30 13:15:00 -             {
2018-10-30 13:15:00 -                 Cloudy.ClearObservedValue();
2018-10-30 13:15:00 -             }
2018-10-30 13:15:00 -             if (sprinkler.HasValue)
2018-10-30 13:15:00 -             {
2018-10-30 13:15:00 -                 Sprinkler.ObservedValue = new int[] { sprinkler.Value };
2018-10-30 13:15:00 -             }
2018-10-30 13:15:00 -             else
2018-10-30 13:15:00 -             {
2018-10-30 13:15:00 -                 Sprinkler.ClearObservedValue();
2018-10-30 13:15:00 -             }
2018-10-30 13:15:00 -             if (wet.HasValue)
2018-10-30 13:15:00 -             {
2018-10-30 13:15:00 -                 WetGrass.ObservedValue = new int[] { wet.Value };
2018-10-30 13:15:00 -             }
2018-10-30 13:15:00 -             else
2018-10-30 13:15:00 -             {
2018-10-30 13:15:00 -                 WetGrass.ClearObservedValue();
2018-10-30 13:15:00 -             }
2018-10-30 13:15:00 -             Rain.ClearObservedValue();
2018-10-30 13:15:00 -             ProbCloudyPrior.ObservedValue = probCloudyPrior;
2018-10-30 13:15:00 -             CPTSprinklerPrior.ObservedValue = cptSprinklerPrior;
2018-10-30 13:15:00 -             CPTRainPrior.ObservedValue = cptRainPrior;
2018-10-30 13:15:00 -             CPTWetGrassPrior.ObservedValue = cptWetGrassPrior;
2018-10-30 13:15:00 -             // Inference
2018-10-30 13:15:00 -             var rainPosterior = Engine.Infer<Discrete[]>(Rain);
2018-10-30 13:15:00 -             // In this example, index 0 is true and index 1 is false
2018-10-30 13:15:00 -             return rainPosterior[0].GetProbs()[0];
2018-10-30 13:15:00 -         } *)
2018-10-30 13:15:00 - let sample numData:int probCloudy:Vector[] cptSprinkler 
2018-10-30 13:15:00 - Syntax error in labelled type argument
2018-10-30 13:15:01 - let setDistributionParameterValues (): DistributionParameterValues =
2018-10-30 13:15:01 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-30 13:15:01 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-30 13:15:01 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-30 13:15:01 -     let cptWetGrass:Vector[][] = 
2018-10-30 13:15:01 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-30 13:15:01 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-30 13:15:01 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-30 13:15:01 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-30 13:15:01 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-30 13:15:01 -     {cloudy=probCloudy; sprinkler=cptSprinkler; rain=cptRain; wetGrass=cptWetGrass}
2018-10-30 13:15:01 - setDistributionParameterValues ()
2018-10-30 13:15:02 - let probRainGivenWetGrass = model.ProbRain(null, null, 0, probCloudy, cptSprinkler, cptRain, cptWetGrass);
2018-10-30 13:15:02 - let probRainGivenWetGrassNotCloudy = model.ProbRain(1, null, 0, probCloudy, cptSprinkler, cptRain, cptWetGrass);
2018-10-30 13:15:02 - printf "P(rain | grass is wet)              = %A" probRainGivenWetGrass
2018-10-30 13:15:02 - printf "P(rain | grass is wet, not cloudy ) = %A" probRainGivenWetGrassNotCloudy
2018-10-30 13:15:02 - The field, constructor or member 'ProbRain' is not defined.
2018-10-30 13:15:02 - The field, constructor or member 'ProbRain' is not defined.
2018-10-30 13:15:02 - let sample = WetGlassSprinklerRainModel.Sample(1000, probCloudy, cptSprinkler, cptRain, cptWetGrass)
2018-10-30 13:15:03 - The value, namespace, type or module 'WetGlassSprinklerRainModel' is not defined. Maybe you want one of the following:
2018-10-30 13:15:03 -    WetGrassSprinklerRainModel
2018-10-30 13:15:03 -    WetGrassSprinklerRainModel2
2018-10-30 13:15:03 - model.LearnParameters(sample[0], sample[1], sample[2], sample[3])
2018-10-30 13:15:03 - The field, constructor or member 'LearnParameters' is not defined.
2018-10-30 13:15:03 - printf "Prob. Cloudy:                              Ground truth: %A, Inferred: %A", 0.5, model.ProbCloudyPosterior.GetMean()[0]
2018-10-30 13:15:03 - printf "Prob. Sprinkler | Cloudy:                  Ground truth: %A, Inferred: %A", 0.1, model.CPTSprinklerPosterior[0].GetMean()[0]
2018-10-30 13:15:03 - printf "Prob. Sprinkler | Not Cloudy:              Ground truth: %A, Inferred: %A", 0.5, model.CPTSprinklerPosterior[1].GetMean()[0]
2018-10-30 13:15:03 - printf "Prob. Rain      | Cloudy:                  Ground truth: %A, Inferred: %A", 0.8, model.CPTRainPosterior[0].GetMean()[0]
2018-10-30 13:15:03 - printf "Prob. Rain      | Not Cloudy:              Ground truth: %A, Inferred: %A", 0.2, model.CPTRainPosterior[1].GetMean()[0]
2018-10-30 13:15:03 - printf "Prob. Wet Grass | Sprinkler, Rain:         Ground truth: %A, Inferred: %A", 0.99, model.CPTWetGrassPosterior[0][0].GetMean()[0]
2018-10-30 13:15:03 - printf "Prob. Wet Grass | Sprinkler, Not Rain      Ground truth: %A, Inferred: %A", 0.9, model.CPTWetGrassPosterior[0][1].GetMean()[0]
2018-10-30 13:15:03 - printf "Prob. Wet Grass | Not Sprinkler, Rain:     Ground truth: %A, Inferred: %A", 0.9, model.CPTWetGrassPosterior[1][0].GetMean()[0]
2018-10-30 13:15:03 - printf "Prob. Wet Grass | Not Sprinkler, Not Rain: Ground truth: %A, Inferred: %A", 0.0, model.CPTWetGrassPosterior[1][1].GetMean()[0]
2018-10-30 13:15:04 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-30 13:15:04 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-30 13:15:04 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-30 13:15:04 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-10-30 13:15:04 - The field, constructor or member 'ProbCloudyPosterior' is not defined.
2018-10-30 13:15:04 - The field, constructor or member 'CPTSprinklerPosterior' is not defined.
2018-10-30 13:15:04 - The field, constructor or member 'CPTSprinklerPosterior' is not defined.
2018-10-30 13:15:04 - The field, constructor or member 'CPTRainPosterior' is not defined.
2018-10-30 13:15:04 - The field, constructor or member 'CPTRainPosterior' is not defined.
2018-10-30 13:15:04 - The field, constructor or member 'CPTWetGrassPosterior' is not defined.
2018-10-30 13:15:04 - The field, constructor or member 'CPTWetGrassPosterior' is not defined.
2018-10-30 13:15:04 - The field, constructor or member 'CPTWetGrassPosterior' is not defined.
2018-10-30 13:15:04 - The field, constructor or member 'CPTWetGrassPosterior' is not defined.
2018-10-30 13:15:04 - // Use posteriors we have just learnt
2018-10-30 13:15:04 - let probRainGivenWetGrass1 = model.ProbRain(null, null, 0, model.ProbCloudyPosterior, model.CPTSprinklerPosterior, model.CPTRainPosterior, model.CPTWetGrassPosterior)
2018-10-30 13:15:04 - let probRainGivenWetGrassNotCloudy1 = model.ProbRain(1, null, 0, model.ProbCloudyPosterior, model.CPTSprinklerPosterior, model.CPTRainPosterior, model.CPTWetGrassPosterior)
2018-10-30 13:15:05 - The field, constructor or member 'ProbRain' is not defined.
2018-10-30 13:15:05 - The field, constructor or member 'ProbRain' is not defined.
2018-10-30 13:15:05 - probRainGivenWetGrass1
2018-10-30 13:15:05 - The value or constructor 'probRainGivenWetGrass1' is not defined. Maybe you want one of the following:
2018-10-30 13:15:05 -    probRain
2018-10-30 13:15:05 - probRainGivenWetGrassNotCloudy1
2018-10-30 13:15:06 - The value or constructor 'probRainGivenWetGrassNotCloudy1' is not defined.
2018-10-30 13:15:06 - let sizes:array<int> = [| 2; 3 |]  
2018-10-30 13:15:06 - let item:Range = Range(sizes.Length).Named("item")  // Standard range of 2 items is outer loop
2018-10-30 13:15:06 - let sizesVar:VariableArray<int> = Variable.Constant(sizes, item).Named("sizes")  
2018-10-30 13:15:06 - let feature:Range =  Range(sizesVar.[item]).Named("feature")  // Inner range "feature" is variable in size
2018-10-30 13:15:06 - let x:VariableArray<VariableArray<float>,float[][]>
2018-10-30 13:15:06 -         = Variable.Array<VariableArray<float>,float[][]>(Variable.Array<float>(feature), item).Named("x");
2018-10-30 13:15:06 - let xPrior:Gaussian = Gaussian(1.2, 3.4) 
2018-10-30 13:15:06 - x.[item].[feature] <- Variable.Random(xPrior).ForEach(item, feature)  // Assign all 5 item-features (!)
2018-10-30 13:15:06 - Variable.ConstrainPositive(x.[item].[feature])   // Constrain all 5 item-features (!)
2018-10-30 13:15:07 - //using the Foreach Block  
2018-10-30 13:15:07 - let pixel = Range(10)  
2018-10-30 13:15:07 - let bools = Variable.Array<bool>(pixel)
2018-10-30 13:15:07 - Variable.ForeachBlock pixel ( fun pixel -> bools.[pixel] <- Variable.Bernoulli(0.7) ||| Variable.Bernoulli(0.4))
2018-10-30 13:15:08 - //using the Switch Block - to model a 2 component (scalar) Gaussian mixture
2018-10-30 13:15:08 - let mixtureSize = 2  
2018-10-30 13:15:08 - let k2 = Range(mixtureSize)  
2018-10-30 13:15:08 - let c:Variable<int> = Variable.Discrete(k2, [|0.5;0.5|])  // c is a discrete random variable with values {0,1}
2018-10-30 13:15:08 - let means2:VariableArray<float> = Variable.Observed( [|1.0;2.0|], k2)  // Constant means for each Gaussian
2018-10-30 13:15:08 - let x:Variable<float> = Variable.New<double>()  // x is a univariate Gaussian
2018-10-30 13:15:08 - Variable.SwitchBlock c (fun _ -> 
2018-10-30 13:15:08 -     let _ = x.SetTo(Variable.GaussianFromMeanAndVariance(means2.[c], 1.0))  
2018-10-30 13:15:08 -     ()  
2018-10-30 13:15:08 - )
2018-10-30 13:15:08 - //using the SwitchExpr Block - to model 100 outcomes of a 2-component mixture Wishart distributed variable
2018-10-30 13:15:08 - let k =  Range(2).Named("k")
2018-10-30 13:15:09 - // Loop over mixture components - parameters are constant, so don't vary based on prior distribution, yet
2018-10-30 13:15:09 - let means:VariableArray<Vector> = 
2018-10-30 13:15:09 -     Variable.ArrayInit k (fun k ->  
2018-10-30 13:15:09 -         Variable.VectorGaussianFromMeanAndPrecision( Vector.Constant(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-10-30 13:15:09 - let precs:VariableArray<PositiveDefiniteMatrix> =  
2018-10-30 13:15:09 -     Variable.ArrayInit k (fun k -> 
2018-10-30 13:15:09 -         Variable.WishartFromShapeAndScale(1.0,  
2018-10-30 13:15:09 -             PositiveDefiniteMatrix.Identity(2)))  
2018-10-30 13:15:10 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-10-30 13:15:10 - let n = Range(100).Named("n")
2018-10-30 13:15:10 - let z:VariableArray<int> = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-10-30 13:15:10 - let data = Variable.ArrayInit n (fun (i:Range)->  
2018-10-30 13:15:10 -                Variable.SwitchExpr (z.[i]) (fun (zi:Variable<int>) ->  
2018-10-30 13:15:10 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-10-30 13:15:11 - // Data from a clinical trial  
2018-10-30 13:15:11 - let controlGroup = Variable.Observed<bool>([|false; false; true; false; false|])  
2018-10-30 13:15:11 - let treatedGroup = Variable.Observed<bool>([|true; false; true; true; true |])  
2018-10-30 13:15:11 - let i = controlGroup.Range  
2018-10-30 13:15:11 - let j = treatedGroup.Range  
2018-10-30 13:15:11 - // Prior on being an effective treatment  
2018-10-30 13:15:11 - let isEffective = Variable.Bernoulli(0.5).Named("isEffective");  
2018-10-30 13:15:11 - let probIfTreated = ref (Variable.New<float>())  
2018-10-30 13:15:11 - let probIfControl = ref (Variable.New<float>())
2018-10-30 13:15:11 - // If Block function  
2018-10-30 13:15:11 - let f1 (vb1: Variable<bool>) =  
2018-10-30 13:15:11 -     probIfControl := Variable.Beta(1.0, 1.0).Named("probIfControl")  
2018-10-30 13:15:11 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->
2018-10-30 13:15:11 -         Variable.Bernoulli(!probIfControl)) 
2018-10-30 13:15:11 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->
2018-10-30 13:15:11 -         Variable.Bernoulli(!probIfTreated))  
2018-10-30 13:15:11 -     ()  
2018-10-30 13:15:12 - // IfNot Block function  
2018-10-30 13:15:12 - let f2 (vb2: Variable<bool>) =  
2018-10-30 13:15:12 -     let probAll = Variable.Beta(1.0, 1.0).Named("probAll")  
2018-10-30 13:15:12 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->Variable.Bernoulli(probAll))  
2018-10-30 13:15:12 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->Variable.Bernoulli(probAll))  
2018-10-30 13:15:12 -     ()  
2018-10-30 13:15:12 - // Call IfBlock  
2018-10-30 13:15:12 - let _ = Variable.IfBlock isEffective f1 f2
2018-10-30 13:21:00 - #load "Paket.fsx"
2018-10-30 13:21:02 - Paket.Package
2018-10-30 13:21:02 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-30 13:21:02 -       "Microsoft.ML.Probabilistic"
2018-10-30 13:21:02 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-30 13:21:02 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-30 13:21:02 -       "NETStandard.Library"
2018-10-30 13:21:02 -   ]
2018-10-30 13:22:07 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-30 13:22:10 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-30 13:22:48 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-30 13:22:48 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-30 13:22:48 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-30 13:22:48 - #r "Microsoft.ML.Probabilistic"
2018-10-30 13:22:48 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-30 13:22:48 - #r "netstandard"
2018-10-30 13:22:49 - open System
2018-10-30 13:22:49 - open Microsoft.ML.Probabilistic  
2018-10-30 13:22:49 - open Microsoft.ML.Probabilistic.Models  
2018-10-30 13:22:49 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-30 13:22:49 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-30 13:22:49 - open Microsoft.ML.Probabilistic.Math
2018-10-30 13:22:51 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-30 13:22:55 - open Microsoft.ML.Probabilistic.FSharp
2018-10-30 13:22:55 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2018-10-30 13:22:55 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-10-30 13:22:56 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-10-30 13:22:56 - let AddChildFromOneParent 
2018-10-30 13:22:56 -         (parent:RandomVariable) 
2018-10-30 13:22:56 -         (cpt:ConditionalProbabilityTable) =
2018-10-30 13:22:56 -     let r = parent.Range
2018-10-30 13:22:56 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 13:22:56 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-30 13:22:56 -                        Variable.Discrete(cpt.[pi])))
2018-10-30 13:22:56 -     child
2018-10-30 13:22:56 - type ConditionalProbabilityTable2D = 
2018-10-30 13:22:56 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-30 13:22:57 - let AddChildFromTwoParents 
2018-10-30 13:22:57 -         (parent1:RandomVariable) 
2018-10-30 13:22:57 -         (parent2:RandomVariable) 
2018-10-30 13:22:57 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-30 13:22:57 -     let r = parent1.Range
2018-10-30 13:22:57 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 13:22:57 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-30 13:22:57 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-30 13:22:57 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-30 13:22:57 -     child       
2018-10-30 13:22:57 - type RandomVariables =
2018-10-30 13:22:57 -     {cloudy:VariableArray<int>;
2018-10-30 13:22:57 -     sprinkler:VariableArray<int>;
2018-10-30 13:22:57 -     rain:VariableArray<int>;
2018-10-30 13:22:57 -     wetGrass:VariableArray<int> }
2018-10-30 13:22:57 - type ObservedValues =
2018-10-30 13:22:57 -     {cloudy:array<int>;
2018-10-30 13:22:57 -     sprinkler:array<int>;
2018-10-30 13:22:57 -     rain:array<int>;
2018-10-30 13:22:57 -     wetGrass:array<int> }
2018-10-30 13:22:58 - type DistributionParameters =
2018-10-30 13:22:58 -     {cloudy:Variable<Vector> ;
2018-10-30 13:22:58 -     sprinkler:VariableArray<Vector> ;
2018-10-30 13:22:58 -     rain:VariableArray<Vector> ;
2018-10-30 13:22:58 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-30 13:22:58 - type DistributionParameterValues =  
2018-10-30 13:22:58 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-30 13:22:58 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-30 13:22:58 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-30 13:22:58 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-30 13:22:58 -     }
2018-10-30 13:22:59 - type PriorDistributions =
2018-10-30 13:22:59 -     {cloudy:Variable<Dirichlet> ;
2018-10-30 13:22:59 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-30 13:22:59 -     rain:VariableArray<Dirichlet> ;
2018-10-30 13:22:59 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-30 13:22:59 - type PosteriorDistributions =
2018-10-30 13:22:59 -     {cloudy:Dirichlet ;
2018-10-30 13:22:59 -     sprinkler:Dirichlet[] ;
2018-10-30 13:22:59 -     rain:Dirichlet[] ;
2018-10-30 13:22:59 -     wetGrass:Dirichlet[][] }
2018-10-30 13:23:00 - let engine =  InferenceEngine ()
2018-10-30 13:23:00 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 13:23:00 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 13:23:00 - let rC = Range(2).Named("C") // Cloudy
2018-10-30 13:23:00 - let rS = Range(2).Named("S") // Sprinkler
2018-10-30 13:23:00 - let rR = Range(2).Named("R") // Rain
2018-10-30 13:23:00 - let rW = Range(2).Named("W") // Wet
2018-10-30 13:23:01 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-30 13:23:01 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-30 13:23:01 - probCloudy.SetValueRange(rC)
2018-10-30 13:23:01 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-30 13:23:01 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-30 13:23:02 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2018-10-30 13:23:02 - cptSprinkler.SetValueRange(rS)
2018-10-30 13:23:02 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-30 13:23:02 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-30 13:23:03 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-30 13:23:03 - cptRain.SetValueRange(rR)
2018-10-30 13:23:03 - let cptWetGrassPrior= 
2018-10-30 13:23:03 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 13:23:03 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-30 13:23:03 - let cptWetGrass = 
2018-10-30 13:23:03 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 13:23:03 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-30 13:23:04 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-10-30 13:23:04 - cptWetGrass.SetValueRange(rW)
2018-10-30 13:23:04 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-30 13:23:05 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-30 13:23:05 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-30 13:23:05 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-30 13:23:05 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-30 13:23:05 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 13:23:05 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-30 13:23:05 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-30 13:23:05 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-30 13:23:05 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-30 13:23:05 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-30 13:23:05 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 13:23:05 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-30 13:23:05 -     probCloudy.SetValueRange(rg.c)
2018-10-30 13:23:05 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-30 13:23:05 -     cptSprinkler.SetValueRange(rg.s)
2018-10-30 13:23:05 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-30 13:23:05 -     cptRain.SetValueRange(rg.r)
2018-10-30 13:23:05 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-30 13:23:05 -     cptWetGrass.SetValueRange(rg.w)
2018-10-30 13:23:05 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-30 13:23:05 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 13:23:05 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 13:23:06 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-30 13:23:06 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-10-30 13:23:06 - let setDistributionParameterValues (): DistributionParameterValues =
2018-10-30 13:23:06 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-30 13:23:06 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-30 13:23:06 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-30 13:23:06 -     let cptWetGrass:Vector[][] = 
2018-10-30 13:23:06 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-30 13:23:06 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-30 13:23:06 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-30 13:23:06 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-30 13:23:06 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-30 13:23:06 -     {cloudy=probCloudy; sprinkler=cptSprinkler; rain=cptRain; wetGrass=cptWetGrass}
2018-10-30 13:23:07 - let Sample  (numData:int)
2018-10-30 13:23:07 -             (dpv:DistributionParameterValues) : int[][] =     
2018-10-30 13:23:07 -     Array.init numData (fun _ ->
2018-10-30 13:23:07 -             let cloudy = Discrete.Sample(dpv.cloudy);
2018-10-30 13:23:07 -             let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy]);
2018-10-30 13:23:07 -             let rain = Discrete.Sample(dpv.rain.[cloudy]);
2018-10-30 13:23:07 -             let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]);
2018-10-30 13:23:07 -             [|cloudy;sprinkler;rain;wetGrass|])
2018-10-30 16:08:13 - #load "Paket.fsx"
2018-10-30 16:08:22 - Paket.Package
2018-10-30 16:08:22 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-30 16:08:22 -       "Microsoft.ML.Probabilistic"
2018-10-30 16:08:22 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-30 16:08:22 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-30 16:08:22 -       "NETStandard.Library"
2018-10-30 16:08:22 -   ]
2018-10-30 16:09:08 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-30 16:09:11 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-30 16:09:35 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-30 16:09:35 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-30 16:09:35 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-30 16:09:35 - #r "Microsoft.ML.Probabilistic"
2018-10-30 16:09:35 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-30 16:09:35 - #r "netstandard"
2018-10-30 16:09:35 - open System
2018-10-30 16:09:36 - open Microsoft.ML.Probabilistic  
2018-10-30 16:09:36 - open Microsoft.ML.Probabilistic.Models  
2018-10-30 16:09:36 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-30 16:09:36 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-30 16:09:36 - open Microsoft.ML.Probabilistic.Math
2018-10-30 16:09:37 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-30 16:09:39 - open Microsoft.ML.Probabilistic.FSharp
2018-10-30 16:09:39 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2018-10-30 16:09:39 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-10-30 16:09:40 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-10-30 16:09:40 - let AddChildFromOneParent 
2018-10-30 16:09:40 -         (parent:RandomVariable) 
2018-10-30 16:09:40 -         (cpt:ConditionalProbabilityTable) =
2018-10-30 16:09:40 -     let r = parent.Range
2018-10-30 16:09:40 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 16:09:40 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-30 16:09:40 -                        Variable.Discrete(cpt.[pi])))
2018-10-30 16:09:40 -     child
2018-10-30 16:09:41 - type ConditionalProbabilityTable2D = 
2018-10-30 16:09:41 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-30 16:09:41 - let AddChildFromTwoParents 
2018-10-30 16:09:41 -         (parent1:RandomVariable) 
2018-10-30 16:09:41 -         (parent2:RandomVariable) 
2018-10-30 16:09:41 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-30 16:09:41 -     let r = parent1.Range
2018-10-30 16:09:41 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 16:09:41 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-30 16:09:41 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-30 16:09:41 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-30 16:09:41 -     child       
2018-10-30 16:09:42 - type RandomVariables =
2018-10-30 16:09:42 -     {cloudy:VariableArray<int>;
2018-10-30 16:09:42 -     sprinkler:VariableArray<int>;
2018-10-30 16:09:42 -     rain:VariableArray<int>;
2018-10-30 16:09:42 -     wetGrass:VariableArray<int> }
2018-10-30 16:09:42 - type ObservedValues =
2018-10-30 16:09:42 -     {cloudy:array<int>;
2018-10-30 16:09:42 -     sprinkler:array<int>;
2018-10-30 16:09:42 -     rain:array<int>;
2018-10-30 16:09:42 -     wetGrass:array<int> }
2018-10-30 16:09:42 - type DistributionParameters =
2018-10-30 16:09:42 -     {cloudy:Variable<Vector> ;
2018-10-30 16:09:42 -     sprinkler:VariableArray<Vector> ;
2018-10-30 16:09:42 -     rain:VariableArray<Vector> ;
2018-10-30 16:09:42 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-30 16:09:43 - type DistributionParameterValues =  
2018-10-30 16:09:43 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-30 16:09:43 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-30 16:09:43 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-30 16:09:43 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-30 16:09:43 -     }
2018-10-30 16:09:43 - type PriorDistributions =
2018-10-30 16:09:43 -     {cloudy:Variable<Dirichlet> ;
2018-10-30 16:09:43 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-30 16:09:43 -     rain:VariableArray<Dirichlet> ;
2018-10-30 16:09:43 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-30 16:09:44 - type PosteriorDistributions =
2018-10-30 16:09:44 -     {cloudy:Dirichlet ;
2018-10-30 16:09:44 -     sprinkler:Dirichlet[] ;
2018-10-30 16:09:44 -     rain:Dirichlet[] ;
2018-10-30 16:09:44 -     wetGrass:Dirichlet[][] }
2018-10-30 16:09:44 - let engine =  InferenceEngine ()
2018-10-30 16:09:44 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 16:09:44 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 16:09:44 - let rC = Range(2).Named("C") // Cloudy
2018-10-30 16:09:44 - let rS = Range(2).Named("S") // Sprinkler
2018-10-30 16:09:44 - let rR = Range(2).Named("R") // Rain
2018-10-30 16:09:44 - let rW = Range(2).Named("W") // Wet
2018-10-30 16:09:45 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-30 16:09:45 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-30 16:09:45 - probCloudy.SetValueRange(rC)
2018-10-30 16:09:45 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-30 16:09:45 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-30 16:09:46 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2018-10-30 16:09:46 - cptSprinkler.SetValueRange(rS)
2018-10-30 16:09:46 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-30 16:09:46 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-30 16:09:46 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-30 16:09:46 - cptRain.SetValueRange(rR)
2018-10-30 16:09:47 - let cptWetGrassPrior= 
2018-10-30 16:09:47 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 16:09:47 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-30 16:09:47 - let cptWetGrass = 
2018-10-30 16:09:47 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 16:09:47 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-30 16:09:47 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-10-30 16:09:47 - cptWetGrass.SetValueRange(rW)
2018-10-30 16:09:48 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-30 16:09:48 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-30 16:09:48 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-30 16:09:48 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-30 16:09:48 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-30 16:09:48 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 16:09:48 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-30 16:09:48 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-30 16:09:48 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-30 16:09:48 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-30 16:09:48 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-30 16:09:48 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 16:09:48 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-30 16:09:48 -     probCloudy.SetValueRange(rg.c)
2018-10-30 16:09:48 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-30 16:09:48 -     cptSprinkler.SetValueRange(rg.s)
2018-10-30 16:09:48 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-30 16:09:48 -     cptRain.SetValueRange(rg.r)
2018-10-30 16:09:48 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-30 16:09:48 -     cptWetGrass.SetValueRange(rg.w)
2018-10-30 16:09:48 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-30 16:09:49 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 16:09:49 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 16:09:49 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-30 16:09:49 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-10-30 16:09:49 - let setDistributionParameterValues (): DistributionParameterValues =
2018-10-30 16:09:49 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-30 16:09:49 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-30 16:09:49 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-30 16:09:49 -     let cptWetGrass:Vector[][] = 
2018-10-30 16:09:49 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-30 16:09:49 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-30 16:09:49 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-30 16:09:49 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-30 16:09:49 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-30 16:09:49 -     {cloudy=probCloudy; sprinkler=cptSprinkler; rain=cptRain; wetGrass=cptWetGrass}
2018-10-30 16:09:50 - let Sample  (numData:int)
2018-10-30 16:09:50 -             (dpv:DistributionParameterValues) : int[][] =     
2018-10-30 16:09:50 -     Array.init numData (fun _ ->
2018-10-30 16:09:50 -             let cloudy = Discrete.Sample(dpv.cloudy);
2018-10-30 16:09:50 -             let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy]);
2018-10-30 16:09:50 -             let rain = Discrete.Sample(dpv.rain.[cloudy]);
2018-10-30 16:09:50 -             let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]);
2018-10-30 16:09:50 -             [|cloudy;sprinkler;rain;wetGrass|])
2018-10-30 17:04:00 - #load "Paket.fsx"
2018-10-30 17:04:04 - Paket.Package
2018-10-30 17:04:04 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-30 17:04:04 -       "Microsoft.ML.Probabilistic"
2018-10-30 17:04:04 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-30 17:04:04 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-30 17:04:04 -       "NETStandard.Library"
2018-10-30 17:04:04 -   ]
2018-10-30 17:04:46 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-30 17:04:49 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-30 17:05:15 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-30 17:05:15 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-30 17:05:15 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-30 17:05:16 - #r "Microsoft.ML.Probabilistic"
2018-10-30 17:05:16 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-30 17:05:16 - #r "netstandard"
2018-10-30 17:05:17 - open System
2018-10-30 17:05:17 - open Microsoft.ML.Probabilistic  
2018-10-30 17:05:17 - open Microsoft.ML.Probabilistic.Models  
2018-10-30 17:05:17 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-30 17:05:17 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-30 17:05:17 - open Microsoft.ML.Probabilistic.Math
2018-10-30 17:05:18 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-30 17:05:21 - open Microsoft.ML.Probabilistic.FSharp
2018-10-30 17:05:23 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2018-10-30 17:05:23 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-10-30 17:05:23 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-10-30 17:05:23 - let AddChildFromOneParent 
2018-10-30 17:05:23 -         (parent:RandomVariable) 
2018-10-30 17:05:23 -         (cpt:ConditionalProbabilityTable) =
2018-10-30 17:05:23 -     let r = parent.Range
2018-10-30 17:05:23 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 17:05:23 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-30 17:05:23 -                        Variable.Discrete(cpt.[pi])))
2018-10-30 17:05:23 -     child
2018-10-30 17:05:23 - type ConditionalProbabilityTable2D = 
2018-10-30 17:05:23 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-30 17:05:24 - let AddChildFromTwoParents 
2018-10-30 17:05:24 -         (parent1:RandomVariable) 
2018-10-30 17:05:24 -         (parent2:RandomVariable) 
2018-10-30 17:05:24 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-30 17:05:24 -     let r = parent1.Range
2018-10-30 17:05:24 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 17:05:24 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-30 17:05:24 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-30 17:05:24 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-30 17:05:24 -     child       
2018-10-30 17:05:24 - type RandomVariables =
2018-10-30 17:05:24 -     {cloudy:VariableArray<int>;
2018-10-30 17:05:24 -     sprinkler:VariableArray<int>;
2018-10-30 17:05:24 -     rain:VariableArray<int>;
2018-10-30 17:05:24 -     wetGrass:VariableArray<int> }
2018-10-30 17:05:25 - type ObservedValues =
2018-10-30 17:05:25 -     {cloudy:array<int>;
2018-10-30 17:05:25 -     sprinkler:array<int>;
2018-10-30 17:05:25 -     rain:array<int>;
2018-10-30 17:05:25 -     wetGrass:array<int> }
2018-10-30 17:05:25 - type DistributionParameters =
2018-10-30 17:05:25 -     {cloudy:Variable<Vector> ;
2018-10-30 17:05:25 -     sprinkler:VariableArray<Vector> ;
2018-10-30 17:05:25 -     rain:VariableArray<Vector> ;
2018-10-30 17:05:25 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-30 17:05:25 - type DistributionParameterValues =  
2018-10-30 17:05:25 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-30 17:05:25 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-30 17:05:25 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-30 17:05:25 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-30 17:05:25 -     }
2018-10-30 17:05:27 - type PriorDistributions =
2018-10-30 17:05:27 -     {cloudy:Variable<Dirichlet> ;
2018-10-30 17:05:27 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-30 17:05:27 -     rain:VariableArray<Dirichlet> ;
2018-10-30 17:05:27 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-30 17:05:28 - type PosteriorDistributions =
2018-10-30 17:05:28 -     {cloudy:Dirichlet ;
2018-10-30 17:05:28 -     sprinkler:Dirichlet[] ;
2018-10-30 17:05:28 -     rain:Dirichlet[] ;
2018-10-30 17:05:28 -     wetGrass:Dirichlet[][] }
2018-10-30 17:05:29 - let engine =  InferenceEngine ()
2018-10-30 17:05:29 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 17:05:29 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 17:05:29 - let rC = Range(2).Named("C") // Cloudy
2018-10-30 17:05:29 - let rS = Range(2).Named("S") // Sprinkler
2018-10-30 17:05:29 - let rR = Range(2).Named("R") // Rain
2018-10-30 17:05:29 - let rW = Range(2).Named("W") // Wet
2018-10-30 17:05:30 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-30 17:05:30 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-30 17:05:30 - probCloudy.SetValueRange(rC)
2018-10-30 17:05:30 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-30 17:05:30 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-30 17:05:30 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2018-10-30 17:05:30 - cptSprinkler.SetValueRange(rS)
2018-10-30 17:05:31 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-30 17:05:31 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-30 17:05:31 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-30 17:05:31 - cptRain.SetValueRange(rR)
2018-10-30 17:05:33 - let cptWetGrassPrior= 
2018-10-30 17:05:33 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 17:05:33 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-30 17:05:33 - let cptWetGrass = 
2018-10-30 17:05:33 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 17:05:33 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-30 17:05:33 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-10-30 17:05:33 - cptWetGrass.SetValueRange(rW)
2018-10-30 17:05:34 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-30 17:05:34 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-30 17:05:34 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-30 17:05:34 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-30 17:05:34 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-30 17:05:34 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 17:05:34 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-30 17:05:34 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-30 17:05:34 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-30 17:05:34 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-30 17:05:34 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-30 17:05:34 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 17:05:34 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-30 17:05:34 -     probCloudy.SetValueRange(rg.c)
2018-10-30 17:05:34 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-30 17:05:34 -     cptSprinkler.SetValueRange(rg.s)
2018-10-30 17:05:34 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-30 17:05:34 -     cptRain.SetValueRange(rg.r)
2018-10-30 17:05:34 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-30 17:05:34 -     cptWetGrass.SetValueRange(rg.w)
2018-10-30 17:05:34 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-30 17:05:34 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 17:05:34 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 17:05:35 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-30 17:05:35 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-10-30 17:05:35 - let setDistributionParameterValues (): DistributionParameterValues =
2018-10-30 17:05:35 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-30 17:05:35 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-30 17:05:35 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-30 17:05:35 -     let cptWetGrass:Vector[][] = 
2018-10-30 17:05:35 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-30 17:05:35 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-30 17:05:35 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-30 17:05:35 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-30 17:05:35 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-30 17:05:35 -     {cloudy=probCloudy; sprinkler=cptSprinkler; rain=cptRain; wetGrass=cptWetGrass}
2018-10-30 17:05:37 - let Sample  (numData:int)
2018-10-30 17:05:37 -             (dpv:DistributionParameterValues) : int[][] =     
2018-10-30 17:05:37 -     Array.init numData (fun _ ->
2018-10-30 17:05:37 -             let cloudy = Discrete.Sample(dpv.cloudy);
2018-10-30 17:05:37 -             let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy]);
2018-10-30 17:05:37 -             let rain = Discrete.Sample(dpv.rain.[cloudy]);
2018-10-30 17:05:37 -             let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]);
2018-10-30 17:05:37 -             [|cloudy;sprinkler;rain;wetGrass|])
2018-10-30 17:41:04 - #load "Paket.fsx"
2018-10-30 17:41:05 - Paket.Package
2018-10-30 17:41:05 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-30 17:41:05 -       "Microsoft.ML.Probabilistic"
2018-10-30 17:41:05 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-30 17:41:05 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-30 17:41:05 -       "NETStandard.Library"
2018-10-30 17:41:05 -   ]
2018-10-30 17:41:37 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-30 17:41:41 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-30 17:42:02 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-30 17:42:02 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-30 17:42:02 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-30 17:42:03 - #r "Microsoft.ML.Probabilistic"
2018-10-30 17:42:03 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-30 17:42:03 - #r "netstandard"
2018-10-30 17:42:03 - open System
2018-10-30 17:42:03 - open Microsoft.ML.Probabilistic  
2018-10-30 17:42:03 - open Microsoft.ML.Probabilistic.Models  
2018-10-30 17:42:03 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-30 17:42:03 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-30 17:42:03 - open Microsoft.ML.Probabilistic.Math
2018-10-30 17:42:04 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-30 17:42:06 - open Microsoft.ML.Probabilistic.FSharp
2018-10-30 17:42:06 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2018-10-30 17:42:06 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-10-30 17:42:06 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-10-30 17:42:07 - let AddChildFromOneParent 
2018-10-30 17:42:07 -         (parent:RandomVariable) 
2018-10-30 17:42:07 -         (cpt:ConditionalProbabilityTable) =
2018-10-30 17:42:07 -     let r = parent.Range
2018-10-30 17:42:07 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 17:42:07 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-30 17:42:07 -                        Variable.Discrete(cpt.[pi])))
2018-10-30 17:42:07 -     child
2018-10-30 17:42:07 - type ConditionalProbabilityTable2D = 
2018-10-30 17:42:07 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-30 17:42:07 - let AddChildFromTwoParents 
2018-10-30 17:42:07 -         (parent1:RandomVariable) 
2018-10-30 17:42:07 -         (parent2:RandomVariable) 
2018-10-30 17:42:07 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-30 17:42:07 -     let r = parent1.Range
2018-10-30 17:42:07 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 17:42:07 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-30 17:42:07 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-30 17:42:07 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-30 17:42:07 -     child       
2018-10-30 17:42:08 - type RandomVariables =
2018-10-30 17:42:08 -     {cloudy:VariableArray<int>;
2018-10-30 17:42:08 -     sprinkler:VariableArray<int>;
2018-10-30 17:42:08 -     rain:VariableArray<int>;
2018-10-30 17:42:08 -     wetGrass:VariableArray<int> }
2018-10-30 17:42:08 - type ObservedValues =
2018-10-30 17:42:08 -     {cloudy:array<int>;
2018-10-30 17:42:08 -     sprinkler:array<int>;
2018-10-30 17:42:08 -     rain:array<int>;
2018-10-30 17:42:08 -     wetGrass:array<int> }
2018-10-30 17:42:08 - type DistributionParameters =
2018-10-30 17:42:08 -     {cloudy:Variable<Vector> ;
2018-10-30 17:42:08 -     sprinkler:VariableArray<Vector> ;
2018-10-30 17:42:08 -     rain:VariableArray<Vector> ;
2018-10-30 17:42:08 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-30 17:42:09 - type DistributionParameterValues =  
2018-10-30 17:42:09 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-30 17:42:09 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-30 17:42:09 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-30 17:42:09 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-30 17:42:09 -     }
2018-10-30 17:42:09 - type PriorDistributions =
2018-10-30 17:42:09 -     {cloudy:Variable<Dirichlet> ;
2018-10-30 17:42:09 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-30 17:42:09 -     rain:VariableArray<Dirichlet> ;
2018-10-30 17:42:09 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-30 17:42:09 - type PosteriorDistributions =
2018-10-30 17:42:09 -     {cloudy:Dirichlet ;
2018-10-30 17:42:09 -     sprinkler:Dirichlet[] ;
2018-10-30 17:42:09 -     rain:Dirichlet[] ;
2018-10-30 17:42:09 -     wetGrass:Dirichlet[][] }
2018-10-30 17:42:09 - let engine =  InferenceEngine ()
2018-10-30 17:42:10 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 17:42:10 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 17:42:10 - let rC = Range(2).Named("C") // Cloudy
2018-10-30 17:42:10 - let rS = Range(2).Named("S") // Sprinkler
2018-10-30 17:42:10 - let rR = Range(2).Named("R") // Rain
2018-10-30 17:42:10 - let rW = Range(2).Named("W") // Wet
2018-10-30 17:42:10 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-30 17:42:10 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-30 17:42:10 - probCloudy.SetValueRange(rC)
2018-10-30 17:42:11 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-30 17:42:11 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-30 17:42:11 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2018-10-30 17:42:11 - cptSprinkler.SetValueRange(rS)
2018-10-30 17:42:11 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-30 17:42:11 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-30 17:42:11 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-30 17:42:11 - cptRain.SetValueRange(rR)
2018-10-30 17:42:12 - let cptWetGrassPrior= 
2018-10-30 17:42:12 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 17:42:12 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-30 17:42:12 - let cptWetGrass = 
2018-10-30 17:42:12 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 17:42:12 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-30 17:42:12 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-10-30 17:42:12 - cptWetGrass.SetValueRange(rW)
2018-10-30 17:42:12 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-30 17:42:13 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-30 17:42:13 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-30 17:42:13 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-30 17:42:13 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-30 17:42:13 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 17:42:13 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-30 17:42:13 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-30 17:42:13 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-30 17:42:13 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-30 17:42:13 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-30 17:42:13 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 17:42:13 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-30 17:42:13 -     probCloudy.SetValueRange(rg.c)
2018-10-30 17:42:13 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-30 17:42:13 -     cptSprinkler.SetValueRange(rg.s)
2018-10-30 17:42:13 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-30 17:42:13 -     cptRain.SetValueRange(rg.r)
2018-10-30 17:42:13 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-30 17:42:13 -     cptWetGrass.SetValueRange(rg.w)
2018-10-30 17:42:13 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-30 17:42:13 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 17:42:13 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 17:42:13 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-30 17:42:13 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-10-30 17:42:14 - let setDistributionParameterValues (): DistributionParameterValues =
2018-10-30 17:42:14 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-30 17:42:14 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-30 17:42:14 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-30 17:42:14 -     let cptWetGrass:Vector[][] = 
2018-10-30 17:42:14 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-30 17:42:14 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-30 17:42:14 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-30 17:42:14 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-30 17:42:14 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-30 17:42:14 -     {cloudy=probCloudy; sprinkler=cptSprinkler; rain=cptRain; wetGrass=cptWetGrass}
2018-10-30 17:42:14 - let Sample  (numData:int)
2018-10-30 17:42:14 -             (dpv:DistributionParameterValues) : int[][] =     
2018-10-30 17:42:14 -     Array.init numData (fun _ ->
2018-10-30 17:42:14 -             let cloudy = Discrete.Sample(dpv.cloudy);
2018-10-30 17:42:14 -             let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy]);
2018-10-30 17:42:14 -             let rain = Discrete.Sample(dpv.rain.[cloudy]);
2018-10-30 17:42:14 -             let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]);
2018-10-30 17:42:14 -             [|cloudy;sprinkler;rain;wetGrass|])
2018-10-30 20:30:09 - #load "Paket.fsx"
2018-10-30 20:30:12 - Paket.Package
2018-10-30 20:30:12 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-10-30 20:30:12 -       "Microsoft.ML.Probabilistic"
2018-10-30 20:30:12 -       "Microsoft.ML.Probabilistic.Compiler"
2018-10-30 20:30:12 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-10-30 20:30:12 -       "NETStandard.Library"
2018-10-30 20:30:12 -   ]
2018-10-30 20:30:57 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-10-30 20:31:00 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-10-30 20:31:27 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-10-30 20:31:27 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-10-30 20:31:27 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-10-30 20:31:27 - #r "Microsoft.ML.Probabilistic"
2018-10-30 20:31:27 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-10-30 20:31:27 - #r "netstandard"
2018-10-30 20:31:28 - open System
2018-10-30 20:31:28 - open Microsoft.ML.Probabilistic  
2018-10-30 20:31:28 - open Microsoft.ML.Probabilistic.Models  
2018-10-30 20:31:28 - open Microsoft.ML.Probabilistic.Distributions  
2018-10-30 20:31:28 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-10-30 20:31:28 - open Microsoft.ML.Probabilistic.Math
2018-10-30 20:31:29 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-10-30 20:31:33 - open Microsoft.ML.Probabilistic.FSharp
2018-10-30 20:31:34 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2018-10-30 20:31:34 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-10-30 20:31:34 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-10-30 20:31:34 - let AddChildFromOneParent 
2018-10-30 20:31:34 -         (parent:RandomVariable) 
2018-10-30 20:31:34 -         (cpt:ConditionalProbabilityTable) =
2018-10-30 20:31:34 -     let r = parent.Range
2018-10-30 20:31:34 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 20:31:34 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-10-30 20:31:34 -                        Variable.Discrete(cpt.[pi])))
2018-10-30 20:31:34 -     child
2018-10-30 20:31:35 - type ConditionalProbabilityTable2D = 
2018-10-30 20:31:35 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-10-30 20:31:35 - let AddChildFromTwoParents 
2018-10-30 20:31:35 -         (parent1:RandomVariable) 
2018-10-30 20:31:35 -         (parent2:RandomVariable) 
2018-10-30 20:31:35 -         (cpt:ConditionalProbabilityTable2D) = 
2018-10-30 20:31:35 -     let r = parent1.Range
2018-10-30 20:31:35 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-10-30 20:31:35 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-10-30 20:31:35 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-10-30 20:31:35 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-10-30 20:31:35 -     child       
2018-10-30 20:31:36 - type RandomVariables =
2018-10-30 20:31:36 -     {cloudy:VariableArray<int>;
2018-10-30 20:31:36 -     sprinkler:VariableArray<int>;
2018-10-30 20:31:36 -     rain:VariableArray<int>;
2018-10-30 20:31:36 -     wetGrass:VariableArray<int> }
2018-10-30 20:31:36 - type ObservedValues =
2018-10-30 20:31:36 -     {cloudy:array<int>;
2018-10-30 20:31:36 -     sprinkler:array<int>;
2018-10-30 20:31:36 -     rain:array<int>;
2018-10-30 20:31:36 -     wetGrass:array<int> }
2018-10-30 20:31:37 - type DistributionParameters =
2018-10-30 20:31:37 -     {cloudy:Variable<Vector> ;
2018-10-30 20:31:37 -     sprinkler:VariableArray<Vector> ;
2018-10-30 20:31:37 -     rain:VariableArray<Vector> ;
2018-10-30 20:31:37 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-10-30 20:31:37 - type DistributionParameterValues =  
2018-10-30 20:31:37 -     {cloudy:Vector;     // probCloudy     2-vector
2018-10-30 20:31:37 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-10-30 20:31:37 -     rain:Vector[];      // cptRain        2-vector * 2
2018-10-30 20:31:37 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-10-30 20:31:37 -     }
2018-10-30 20:31:38 - type PriorDistributions =
2018-10-30 20:31:38 -     {cloudy:Variable<Dirichlet> ;
2018-10-30 20:31:38 -     sprinkler:VariableArray<Dirichlet> ;
2018-10-30 20:31:38 -     rain:VariableArray<Dirichlet> ;
2018-10-30 20:31:38 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-10-30 20:31:38 - type PosteriorDistributions =
2018-10-30 20:31:38 -     {cloudy:Dirichlet ;
2018-10-30 20:31:38 -     sprinkler:Dirichlet[] ;
2018-10-30 20:31:38 -     rain:Dirichlet[] ;
2018-10-30 20:31:38 -     wetGrass:Dirichlet[][] }
2018-10-30 20:31:39 - let engine =  InferenceEngine ()
2018-10-30 20:31:39 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 20:31:39 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 20:31:39 - let rC = Range(2).Named("C") // Cloudy
2018-10-30 20:31:39 - let rS = Range(2).Named("S") // Sprinkler
2018-10-30 20:31:39 - let rR = Range(2).Named("R") // Rain
2018-10-30 20:31:39 - let rW = Range(2).Named("W") // Wet
2018-10-30 20:31:40 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-10-30 20:31:40 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-10-30 20:31:40 - probCloudy.SetValueRange(rC)
2018-10-30 20:31:40 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-10-30 20:31:40 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-10-30 20:31:41 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2018-10-30 20:31:41 - cptSprinkler.SetValueRange(rS)
2018-10-30 20:31:41 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-10-30 20:31:41 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-10-30 20:31:41 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-10-30 20:31:41 - cptRain.SetValueRange(rR)
2018-10-30 20:31:42 - let cptWetGrassPrior= 
2018-10-30 20:31:42 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 20:31:42 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-10-30 20:31:42 - let cptWetGrass = 
2018-10-30 20:31:42 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 20:31:42 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-10-30 20:31:42 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-10-30 20:31:42 - cptWetGrass.SetValueRange(rW)
2018-10-30 20:31:43 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-10-30 20:31:43 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-10-30 20:31:43 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-10-30 20:31:43 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-10-30 20:31:43 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-10-30 20:31:43 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-10-30 20:31:43 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-10-30 20:31:43 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-10-30 20:31:43 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-10-30 20:31:43 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-10-30 20:31:43 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-10-30 20:31:43 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-10-30 20:31:43 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-10-30 20:31:43 -     probCloudy.SetValueRange(rg.c)
2018-10-30 20:31:43 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-10-30 20:31:43 -     cptSprinkler.SetValueRange(rg.s)
2018-10-30 20:31:43 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-10-30 20:31:43 -     cptRain.SetValueRange(rg.r)
2018-10-30 20:31:43 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-10-30 20:31:43 -     cptWetGrass.SetValueRange(rg.w)
2018-10-30 20:31:43 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-10-30 20:31:44 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-10-30 20:31:44 - let rN:Range = Range(numberOfExamples).Named("N")
2018-10-30 20:31:44 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-10-30 20:31:44 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-10-30 20:31:45 - let setDistributionParameterValues (): DistributionParameterValues =
2018-10-30 20:31:45 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-10-30 20:31:45 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-30 20:31:45 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-10-30 20:31:45 -     let cptWetGrass:Vector[][] = 
2018-10-30 20:31:45 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-10-30 20:31:45 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-10-30 20:31:45 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-10-30 20:31:45 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-10-30 20:31:45 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-10-30 20:31:45 -     {cloudy=probCloudy; sprinkler=cptSprinkler; rain=cptRain; wetGrass=cptWetGrass}
2018-10-30 20:31:45 - let Sample  (numData:int)
2018-10-30 20:31:45 -             (dpv:DistributionParameterValues) : int[][] =     
2018-10-30 20:31:45 -     Array.init numData (fun _ ->
2018-10-30 20:31:45 -             let cloudy = Discrete.Sample(dpv.cloudy);
2018-10-30 20:31:45 -             let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy]);
2018-10-30 20:31:45 -             let rain = Discrete.Sample(dpv.rain.[cloudy]);
2018-10-30 20:31:45 -             let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]);
2018-10-30 20:31:45 -             [|cloudy;sprinkler;rain;wetGrass|])
2018-11-03 18:39:38 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2018-11-03 18:39:38 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-03 18:39:38 - For help type #help;;
2018-11-03 18:39:38 - > val it :
2018-11-03 18:39:38 -   ResizeArray<System.Type *
2018-11-03 18:39:38 -               (obj ->
2018-11-03 18:39:38 -                  seq<string *
2018-11-03 18:39:38 -                      string> *
2018-11-03 18:39:38 -                  string)>
2018-11-03 18:39:38 - = seq []
2018-11-03 18:39:38 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-11-03 18:39:38 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-03 18:39:38 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-03 18:39:59 - Reporting 0 opened comms
2018-11-03 18:40:08 - #load "Paket.fsx"
2018-11-03 18:40:15 - Paket.Package
2018-11-03 18:40:15 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-11-03 18:40:15 -       "Microsoft.ML.Probabilistic"
2018-11-03 18:40:15 -       "Microsoft.ML.Probabilistic.Compiler"
2018-11-03 18:40:15 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-11-03 18:40:15 -       "NETStandard.Library"
2018-11-03 18:40:15 -   ]
2018-11-03 18:41:33 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-11-03 18:41:40 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-11-03 18:42:14 - //#load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-11-03 18:42:15 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-11-03 18:42:15 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-11-03 18:42:15 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-11-03 18:42:15 - #r "Microsoft.ML.Probabilistic"
2018-11-03 18:42:15 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-11-03 18:42:15 - #r "netstandard"
2018-11-03 18:42:16 - open System
2018-11-03 18:42:16 - open Microsoft.ML.Probabilistic  
2018-11-03 18:42:16 - open Microsoft.ML.Probabilistic.Models  
2018-11-03 18:42:16 - open Microsoft.ML.Probabilistic.Distributions  
2018-11-03 18:42:16 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-11-03 18:42:16 - open Microsoft.ML.Probabilistic.Math
2018-11-03 18:42:17 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-11-03 18:42:21 - open Microsoft.ML.Probabilistic.FSharp
2018-11-03 18:42:21 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2018-11-03 18:42:21 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-11-03 18:42:21 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-11-03 18:42:21 - let AddChildFromOneParent 
2018-11-03 18:42:21 -         (parent:RandomVariable) 
2018-11-03 18:42:21 -         (cpt:ConditionalProbabilityTable) =
2018-11-03 18:42:21 -     let r = parent.Range
2018-11-03 18:42:21 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-11-03 18:42:21 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-11-03 18:42:21 -                        Variable.Discrete(cpt.[pi])))
2018-11-03 18:42:21 -     child
2018-11-03 18:42:22 - type ConditionalProbabilityTable2D = 
2018-11-03 18:42:22 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-11-03 18:42:22 - let AddChildFromTwoParents 
2018-11-03 18:42:22 -         (parent1:RandomVariable) 
2018-11-03 18:42:22 -         (parent2:RandomVariable) 
2018-11-03 18:42:22 -         (cpt:ConditionalProbabilityTable2D) = 
2018-11-03 18:42:22 -     let r = parent1.Range
2018-11-03 18:42:22 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-11-03 18:42:22 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-11-03 18:42:22 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-11-03 18:42:22 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-11-03 18:42:22 -     child       
2018-11-03 18:42:22 - type RandomVariables =
2018-11-03 18:42:22 -     {cloudy:VariableArray<int>;
2018-11-03 18:42:22 -     sprinkler:VariableArray<int>;
2018-11-03 18:42:22 -     rain:VariableArray<int>;
2018-11-03 18:42:22 -     wetGrass:VariableArray<int> }
2018-11-03 18:42:23 - type ObservedValues =
2018-11-03 18:42:23 -     {cloudy:array<int>;
2018-11-03 18:42:23 -     sprinkler:array<int>;
2018-11-03 18:42:23 -     rain:array<int>;
2018-11-03 18:42:23 -     wetGrass:array<int> }
2018-11-03 18:42:23 - type DistributionParameters =
2018-11-03 18:42:23 -     {cloudy:Variable<Vector> ;
2018-11-03 18:42:23 -     sprinkler:VariableArray<Vector> ;
2018-11-03 18:42:23 -     rain:VariableArray<Vector> ;
2018-11-03 18:42:23 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-11-03 18:42:24 - type DistributionParameterValues =  
2018-11-03 18:42:24 -     {cloudy:Vector;     // probCloudy     2-vector
2018-11-03 18:42:24 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-11-03 18:42:24 -     rain:Vector[];      // cptRain        2-vector * 2
2018-11-03 18:42:24 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-11-03 18:42:24 -     }
2018-11-03 18:42:24 - type PriorDistributions =
2018-11-03 18:42:24 -     {cloudy:Variable<Dirichlet> ;
2018-11-03 18:42:24 -     sprinkler:VariableArray<Dirichlet> ;
2018-11-03 18:42:24 -     rain:VariableArray<Dirichlet> ;
2018-11-03 18:42:24 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-11-03 18:42:24 - type PosteriorDistributions =
2018-11-03 18:42:24 -     {cloudy:Dirichlet ;
2018-11-03 18:42:24 -     sprinkler:Dirichlet[] ;
2018-11-03 18:42:24 -     rain:Dirichlet[] ;
2018-11-03 18:42:24 -     wetGrass:Dirichlet[][] }
2018-11-03 18:42:25 - type Ranges = {c:Range;s:Range;r:Range;w:Range}
2018-11-03 18:42:25 - let engine =  InferenceEngine ()
2018-11-03 18:42:26 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-11-03 18:42:26 - let rN:Range = Range(numberOfExamples).Named("N")
2018-11-03 18:42:26 - let rC = Range(2).Named("C") // Cloudy
2018-11-03 18:42:26 - let rS = Range(2).Named("S") // Sprinkler
2018-11-03 18:42:26 - let rR = Range(2).Named("R") // Rain
2018-11-03 18:42:26 - let rW = Range(2).Named("W") // Wet
2018-11-03 18:42:26 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-11-03 18:42:26 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-11-03 18:42:26 - probCloudy.SetValueRange(rC)
2018-11-03 18:42:27 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-11-03 18:42:27 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-11-03 18:42:27 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2018-11-03 18:42:27 - cptSprinkler.SetValueRange(rS)
2018-11-03 18:42:28 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-11-03 18:42:28 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-11-03 18:42:28 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-11-03 18:42:28 - cptRain.SetValueRange(rR)
2018-11-03 18:42:28 - let cptWetGrassPrior= 
2018-11-03 18:42:28 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-11-03 18:42:28 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-11-03 18:42:28 - let cptWetGrass = 
2018-11-03 18:42:28 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-11-03 18:42:28 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-11-03 18:42:29 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-11-03 18:42:29 - cptWetGrass.SetValueRange(rW)
2018-11-03 18:42:29 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-11-03 18:42:30 - let priors:PriorDistributions = {
2018-11-03 18:42:30 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-11-03 18:42:30 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-11-03 18:42:30 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-11-03 18:42:30 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-11-03 18:42:30 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-11-03 18:42:30 - let parameters:DistributionParameters = {
2018-11-03 18:42:30 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-11-03 18:42:30 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-11-03 18:42:30 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-11-03 18:42:30 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-11-03 18:42:30 -                 Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-11-03 18:42:30 - parameters.cloudy.SetValueRange(ranges.c)
2018-11-03 18:42:30 - parameters.sprinkler.[ranges.c] <- Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c])
2018-11-03 18:42:30 - parameters.sprinkler.SetValueRange(ranges.s)
2018-11-03 18:42:30 - parameters.rain.[ranges.c] <- Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c])
2018-11-03 18:42:30 - parameters.rain.SetValueRange(ranges.r)
2018-11-03 18:42:30 - parameters.wetGrass.[ranges.s].[ranges.r] <- Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[ranges.s].[ranges.r])
2018-11-03 18:42:30 - parameters.wetGrass.SetValueRange(ranges.w)
2018-11-03 18:42:31 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-11-03 18:42:31 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-11-03 18:42:31 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-11-03 18:42:31 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-11-03 18:42:31 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-11-03 18:42:31 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-11-03 18:42:31 - let priors = buildPriors ranges
2018-11-03 18:42:32 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-11-03 18:42:32 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-11-03 18:42:32 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-11-03 18:42:32 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-11-03 18:42:32 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-11-03 18:42:32 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-11-03 18:42:32 -     probCloudy.SetValueRange(rg.c)
2018-11-03 18:42:32 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-11-03 18:42:32 -     cptSprinkler.SetValueRange(rg.s)
2018-11-03 18:42:32 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-11-03 18:42:32 -     cptRain.SetValueRange(rg.r)
2018-11-03 18:42:32 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-11-03 18:42:32 -     cptWetGrass.SetValueRange(rg.w)
2018-11-03 18:42:32 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-11-03 18:42:32 - let parameters = buildDistributionParameters ranges priors
2018-11-03 18:42:32 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-11-03 18:42:32 - let rN:Range = Range(numberOfExamples).Named("N")
2018-11-03 18:42:33 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-11-03 18:42:33 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-11-03 18:42:33 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("sprinkler")
2018-11-03 18:42:33 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("rain")
2018-11-03 18:42:33 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("wetGrass")
2018-11-03 18:42:34 - let rvs:RandomVariables =
2018-11-03 18:42:34 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2018-11-03 18:42:34 -     vC.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-11-03 18:42:34 -     let vS = (AddChildFromOneParent vC cptSprinkler).Named("sprinkler")
2018-11-03 18:42:34 -     let vR = (AddChildFromOneParent vC cptRain).Named("rain")
2018-11-03 18:42:34 -     let vW = (AddChildFromTwoParents vS vR cptWetGrass).Named("wetGrass")
2018-11-03 18:42:34 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-11-03 18:42:34 - let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-11-03 18:42:34 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2018-11-03 18:42:34 -     vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-11-03 18:42:34 -     let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-11-03 18:42:34 -     let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-11-03 18:42:34 -     let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-11-03 18:42:34 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-11-03 18:42:35 - let numberOfExamples = Variable.New<int>().Named("NofE")
2018-11-03 18:42:35 - let rN = Range(numberOfExamples).Named("N")
2018-11-03 18:42:35 - let ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("W")}
2018-11-03 18:42:35 - let priors = buildPriors ranges
2018-11-03 18:42:35 - let parameters = buildDistributionParameters ranges priors
2018-11-03 18:42:35 - let rvs = buildRandomVariables rN parameters
2018-11-03 18:42:35 - let a:array<int> = [|3|]
2018-11-03 18:42:35 - let b:int[] =  [|3|]
2018-11-03 18:42:35 - let c:int[] = a
2018-11-03 18:42:35 - let d:Vector[][] = [|[|Vector.FromArray(2.,3.)|]|]
2018-11-03 18:42:35 - let e:array<array<Vector>> = [|[|Vector.FromArray(2.,3.)|]|]
2018-11-03 18:42:35 - let f:array<array<Vector>> = d
2018-11-03 18:42:36 - type WetGrassSprinklerRainModel() =
2018-11-03 18:42:36 -     
2018-11-03 18:42:36 -     // Private functions (used by constructor)
2018-11-03 18:42:36 -     let addChildFromOneParent 
2018-11-03 18:42:36 -             (parent:RandomVariable) 
2018-11-03 18:42:36 -             (cpt:ConditionalProbabilityTable) =
2018-11-03 18:42:36 -         let r = parent.Range
2018-11-03 18:42:36 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-11-03 18:42:36 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-11-03 18:42:36 -                            Variable.Discrete(cpt.[pi])))
2018-11-03 18:42:36 -         child
2018-11-03 18:42:36 -         
2018-11-03 18:42:36 -     let addChildFromTwoParents 
2018-11-03 18:42:36 -             (parent1:RandomVariable) 
2018-11-03 18:42:36 -             (parent2:RandomVariable) 
2018-11-03 18:42:36 -             (cpt:ConditionalProbabilityTable2D) = 
2018-11-03 18:42:36 -         let r = parent1.Range
2018-11-03 18:42:36 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-11-03 18:42:36 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-11-03 18:42:36 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-11-03 18:42:36 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-11-03 18:42:36 -         child    
2018-11-03 18:42:36 -         
2018-11-03 18:42:36 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-11-03 18:42:36 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-11-03 18:42:36 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-11-03 18:42:36 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-11-03 18:42:36 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-11-03 18:42:36 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-11-03 18:42:36 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-11-03 18:42:36 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-11-03 18:42:36 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-11-03 18:42:36 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-11-03 18:42:36 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-11-03 18:42:36 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-11-03 18:42:36 -         do probCloudy.SetValueRange(rg.c)
2018-11-03 18:42:36 -         do cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-11-03 18:42:36 -         do cptSprinkler.SetValueRange(rg.s)
2018-11-03 18:42:36 -         do cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-11-03 18:42:36 -         do cptRain.SetValueRange(rg.r)
2018-11-03 18:42:36 -         do cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-11-03 18:42:36 -         do cptWetGrass.SetValueRange(rg.w)
2018-11-03 18:42:36 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-11-03 18:42:36 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-11-03 18:42:36 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-11-03 18:42:36 -         do vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-11-03 18:42:36 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-11-03 18:42:36 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-11-03 18:42:36 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-11-03 18:42:36 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-11-03 18:42:36 -      
2018-11-03 18:42:36 -     // Private fields
2018-11-03 18:42:36 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-11-03 18:42:36 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-11-03 18:42:36 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-11-03 18:42:36 -     let priors = buildPriors ranges
2018-11-03 18:42:36 -     let parameters = buildDistributionParameters ranges priors
2018-11-03 18:42:36 -     let primaryRandomVariables = buildRandomVariables rN parameters
2018-11-03 18:42:36 -     let engine = InferenceEngine ()
2018-11-03 18:42:36 -     
2018-11-03 18:42:36 -     // Properties
2018-11-03 18:42:36 -     member this.Ranges = ranges
2018-11-03 18:42:36 -     member this.NumberOfExamples = numberOfExamples
2018-11-03 18:42:36 -     member this.RangeN = rN
2018-11-03 18:42:36 -     member this.Priors = priors
2018-11-03 18:42:36 -     member this.Parameters = parameters
2018-11-03 18:42:36 -     member this.PrimaryRandomVariables = primaryRandomVariables
2018-11-03 18:42:36 -     member this.Engine = engine
2018-11-03 18:42:37 - let model = WetGrassSprinklerRainModel ()  
2018-11-03 18:42:37 - module WetGrassSprinklerRainModel2 =
2018-11-03 18:42:37 -     // Functions
2018-11-03 18:42:37 -     let addChildFromOneParent 
2018-11-03 18:42:37 -             (parent:RandomVariable) 
2018-11-03 18:42:37 -             (cpt:ConditionalProbabilityTable) =
2018-11-03 18:42:37 -         let r = parent.Range
2018-11-03 18:42:37 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-11-03 18:42:37 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-11-03 18:42:37 -                            Variable.Discrete(cpt.[pi])))
2018-11-03 18:42:37 -         child
2018-11-03 18:42:37 -         
2018-11-03 18:42:37 -     let addChildFromTwoParents 
2018-11-03 18:42:37 -             (parent1:RandomVariable) 
2018-11-03 18:42:37 -             (parent2:RandomVariable) 
2018-11-03 18:42:37 -             (cpt:ConditionalProbabilityTable2D) = 
2018-11-03 18:42:37 -         let r = parent1.Range
2018-11-03 18:42:37 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-11-03 18:42:37 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-11-03 18:42:37 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-11-03 18:42:37 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-11-03 18:42:37 -         child    
2018-11-03 18:42:37 -     
2018-11-03 18:42:37 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-11-03 18:42:37 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-11-03 18:42:37 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-11-03 18:42:37 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-11-03 18:42:37 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-11-03 18:42:37 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-11-03 18:42:37 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-11-03 18:42:37 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-11-03 18:42:37 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-11-03 18:42:37 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-11-03 18:42:37 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-11-03 18:42:37 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-11-03 18:42:37 -         probCloudy.SetValueRange(rg.c)
2018-11-03 18:42:37 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-11-03 18:42:37 -         cptSprinkler.SetValueRange(rg.s)
2018-11-03 18:42:37 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-11-03 18:42:37 -         cptRain.SetValueRange(rg.r)
2018-11-03 18:42:37 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-11-03 18:42:37 -         cptWetGrass.SetValueRange(rg.w)
2018-11-03 18:42:37 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-11-03 18:42:37 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-11-03 18:42:37 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-11-03 18:42:37 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-11-03 18:42:37 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-11-03 18:42:37 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-11-03 18:42:37 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-11-03 18:42:37 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-11-03 18:42:38 - open WetGrassSprinklerRainModel2
2018-11-03 18:42:38 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-11-03 18:42:38 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-11-03 18:42:38 - let rN:Range = Range(numberOfExamples).Named("N")
2018-11-03 18:42:38 - let priors = buildPriors ranges
2018-11-03 18:42:38 - let parameters = buildDistributionParameters ranges priors
2018-11-03 18:42:38 - let rvs = buildRandomVariables rN parameters
2018-11-03 18:42:38 - let engine =  InferenceEngine ()
2018-11-03 18:42:38 - let setDistributionParameterValues (): DistributionParameterValues =
2018-11-03 18:42:38 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-11-03 18:42:38 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-11-03 18:42:38 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-11-03 18:42:38 -     let cptWetGrass:Vector[][] = 
2018-11-03 18:42:38 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-11-03 18:42:38 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-11-03 18:42:38 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-11-03 18:42:38 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-11-03 18:42:38 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-11-03 18:42:38 -     {cloudy=probCloudy; sprinkler=cptSprinkler; rain=cptRain; wetGrass=cptWetGrass}
2018-11-03 18:42:39 - let dpv = setDistributionParameterValues ()
2018-11-03 18:42:39 - let Sample  (numData:int)
2018-11-03 18:42:39 -             (dpv:DistributionParameterValues) : int[][] =     
2018-11-03 18:42:39 -     Array.init numData (fun _ ->
2018-11-03 18:42:39 -             let cloudy = Discrete.Sample(dpv.cloudy);
2018-11-03 18:42:39 -             let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy]);
2018-11-03 18:42:39 -             let rain = Discrete.Sample(dpv.rain.[cloudy]);
2018-11-03 18:42:39 -             let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]);
2018-11-03 18:42:39 -             [|cloudy;sprinkler;rain;wetGrass|])
2018-11-03 18:42:40 - Sample 10 dpv
2018-11-03 18:42:40 - let learnParameters (engine:InferenceEngine)
2018-11-03 18:42:40 -                     (numberOfExamples:Variable<int>)
2018-11-03 18:42:40 -                     (rvs:RandomVariables)
2018-11-03 18:42:40 -                     (prs:PriorDistributions)
2018-11-03 18:42:40 -                     (obs:ObservedValues)
2018-11-03 18:42:40 -                     (obsPriors:PosteriorDistributions):PosteriorDistributions =
2018-11-03 18:42:40 -     do numberOfExamples.ObservedValue <- obs.cloudy.Length
2018-11-03 18:42:40 -     do rvs.cloudy.ObservedValue <- obs.cloudy
2018-11-03 18:42:40 -     do rvs.sprinkler.ObservedValue <- obs.sprinkler
2018-11-03 18:42:40 -     do rvs.rain.ObservedValue <- obs.rain
2018-11-03 18:42:40 -     do rvs.wetGrass.ObservedValue <- obs.wetGrass
2018-11-03 18:42:40 -     
2018-11-03 18:42:40 -     do prs.cloudy.ObservedValue <- obsPriors.cloudy
2018-11-03 18:42:40 -     do prs.sprinkler.ObservedValue <- obsPriors.sprinkler
2018-11-03 18:42:40 -     do prs.rain.ObservedValue <- obsPriors.rain
2018-11-03 18:42:40 -     do prs.wetGrass.ObservedValue <- obsPriors.wetGrass
2018-11-03 18:42:40 -     // Inference 
2018-11-03 18:42:40 -     {cloudy=engine.Infer<Dirichlet>(prs.cloudy);  
2018-11-03 18:42:40 -         sprinkler=engine.Infer<Dirichlet[]>(prs.sprinkler);  
2018-11-03 18:42:40 -         rain=engine.Infer<Dirichlet[]>(prs.rain);  
2018-11-03 18:42:40 -         wetGrass=engine.Infer<Dirichlet[][]>(prs.wetGrass)}
2018-11-03 18:42:40 - let probRain (cloudy:Option<int>) (sprinkler:Option<int>) = 
2018-11-03 18:42:40 -     match cloudy with 
2018-11-03 18:42:40 -     | Some cloudy -> printfn "the valid value is %A" cloudy
2018-11-03 18:42:40 -     | None -> printfn "the value is None" 
2018-11-03 18:42:40 -     ()
2018-11-03 18:42:41 - probRain (Some 3) None
2018-11-03 18:42:41 - NumberOfExamples.ObservedValue = 1;
2018-11-03 18:42:41 - The value, namespace, type or module 'NumberOfExamples' is not defined. Maybe you want one of the following:
2018-11-03 18:42:41 -    numberOfExamples
2018-11-03 18:42:42 - (*
2018-11-03 18:42:42 - if (cloudy.HasValue)
2018-11-03 18:42:42 -             {
2018-11-03 18:42:42 -                 Cloudy.ObservedValue = new int[] { cloudy.Value };
2018-11-03 18:42:42 -             }
2018-11-03 18:42:42 -             else
2018-11-03 18:42:42 -             {
2018-11-03 18:42:42 -                 Cloudy.ClearObservedValue();
2018-11-03 18:42:42 -             }
2018-11-03 18:42:42 -             if (sprinkler.HasValue)
2018-11-03 18:42:42 -             {
2018-11-03 18:42:42 -                 Sprinkler.ObservedValue = new int[] { sprinkler.Value };
2018-11-03 18:42:42 -             }
2018-11-03 18:42:42 -             else
2018-11-03 18:42:42 -             {
2018-11-03 18:42:42 -                 Sprinkler.ClearObservedValue();
2018-11-03 18:42:42 -             }
2018-11-03 18:42:42 -             if (wet.HasValue)
2018-11-03 18:42:42 -             {
2018-11-03 18:42:42 -                 WetGrass.ObservedValue = new int[] { wet.Value };
2018-11-03 18:42:42 -             }
2018-11-03 18:42:42 -             else
2018-11-03 18:42:42 -             {
2018-11-03 18:42:42 -                 WetGrass.ClearObservedValue();
2018-11-03 18:42:42 -             }
2018-11-03 18:42:42 -             Rain.ClearObservedValue();
2018-11-03 18:42:42 -             ProbCloudyPrior.ObservedValue = probCloudyPrior;
2018-11-03 18:42:42 -             CPTSprinklerPrior.ObservedValue = cptSprinklerPrior;
2018-11-03 18:42:42 -             CPTRainPrior.ObservedValue = cptRainPrior;
2018-11-03 18:42:42 -             CPTWetGrassPrior.ObservedValue = cptWetGrassPrior;
2018-11-03 18:42:42 -             // Inference
2018-11-03 18:42:42 -             var rainPosterior = Engine.Infer<Discrete[]>(Rain);
2018-11-03 18:42:42 -             // In this example, index 0 is true and index 1 is false
2018-11-03 18:42:42 -             return rainPosterior[0].GetProbs()[0];
2018-11-03 18:42:42 -         } *)
2018-11-03 18:42:42 - let sample numData:int probCloudy:Vector[] cptSprinkler 
2018-11-03 18:42:42 - Syntax error in labelled type argument
2018-11-03 18:42:42 - let setDistributionParameterValues (): DistributionParameterValues =
2018-11-03 18:42:42 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-11-03 18:42:42 -     let cptSprinkler:Vector[] = [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-11-03 18:42:42 -     let cptRain:Vector[] =      [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] |> Array.map (fun a -> Vector.FromArray a)
2018-11-03 18:42:42 -     let cptWetGrass:Vector[][] = 
2018-11-03 18:42:42 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-11-03 18:42:42 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-11-03 18:42:42 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-11-03 18:42:42 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-11-03 18:42:42 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-11-03 18:42:42 -     {cloudy=probCloudy; sprinkler=cptSprinkler; rain=cptRain; wetGrass=cptWetGrass}
2018-11-03 18:42:42 - setDistributionParameterValues ()
2018-11-03 18:42:43 - let probRainGivenWetGrass = model.ProbRain(null, null, 0, probCloudy, cptSprinkler, cptRain, cptWetGrass);
2018-11-03 18:42:43 - let probRainGivenWetGrassNotCloudy = model.ProbRain(1, null, 0, probCloudy, cptSprinkler, cptRain, cptWetGrass);
2018-11-03 18:42:43 - printf "P(rain | grass is wet)              = %A" probRainGivenWetGrass
2018-11-03 18:42:43 - printf "P(rain | grass is wet, not cloudy ) = %A" probRainGivenWetGrassNotCloudy
2018-11-03 18:42:43 - The field, constructor or member 'ProbRain' is not defined.
2018-11-03 18:42:43 - The field, constructor or member 'ProbRain' is not defined.
2018-11-03 18:42:43 - let sample = WetGlassSprinklerRainModel.Sample(1000, probCloudy, cptSprinkler, cptRain, cptWetGrass)
2018-11-03 18:42:44 - The value, namespace, type or module 'WetGlassSprinklerRainModel' is not defined. Maybe you want one of the following:
2018-11-03 18:42:44 -    WetGrassSprinklerRainModel
2018-11-03 18:42:44 -    WetGrassSprinklerRainModel2
2018-11-03 18:42:44 - model.LearnParameters(sample[0], sample[1], sample[2], sample[3])
2018-11-03 18:42:44 - The field, constructor or member 'LearnParameters' is not defined.
2018-11-03 18:42:44 - printf "Prob. Cloudy:                              Ground truth: %A, Inferred: %A", 0.5, model.ProbCloudyPosterior.GetMean()[0]
2018-11-03 18:42:44 - printf "Prob. Sprinkler | Cloudy:                  Ground truth: %A, Inferred: %A", 0.1, model.CPTSprinklerPosterior[0].GetMean()[0]
2018-11-03 18:42:44 - printf "Prob. Sprinkler | Not Cloudy:              Ground truth: %A, Inferred: %A", 0.5, model.CPTSprinklerPosterior[1].GetMean()[0]
2018-11-03 18:42:44 - printf "Prob. Rain      | Cloudy:                  Ground truth: %A, Inferred: %A", 0.8, model.CPTRainPosterior[0].GetMean()[0]
2018-11-03 18:42:44 - printf "Prob. Rain      | Not Cloudy:              Ground truth: %A, Inferred: %A", 0.2, model.CPTRainPosterior[1].GetMean()[0]
2018-11-03 18:42:44 - printf "Prob. Wet Grass | Sprinkler, Rain:         Ground truth: %A, Inferred: %A", 0.99, model.CPTWetGrassPosterior[0][0].GetMean()[0]
2018-11-03 18:42:44 - printf "Prob. Wet Grass | Sprinkler, Not Rain      Ground truth: %A, Inferred: %A", 0.9, model.CPTWetGrassPosterior[0][1].GetMean()[0]
2018-11-03 18:42:44 - printf "Prob. Wet Grass | Not Sprinkler, Rain:     Ground truth: %A, Inferred: %A", 0.9, model.CPTWetGrassPosterior[1][0].GetMean()[0]
2018-11-03 18:42:44 - printf "Prob. Wet Grass | Not Sprinkler, Not Rain: Ground truth: %A, Inferred: %A", 0.0, model.CPTWetGrassPosterior[1][1].GetMean()[0]
2018-11-03 18:42:45 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-11-03 18:42:45 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-11-03 18:42:45 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-11-03 18:42:45 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-11-03 18:42:45 - The field, constructor or member 'ProbCloudyPosterior' is not defined.
2018-11-03 18:42:45 - The field, constructor or member 'CPTSprinklerPosterior' is not defined.
2018-11-03 18:42:45 - The field, constructor or member 'CPTSprinklerPosterior' is not defined.
2018-11-03 18:42:45 - The field, constructor or member 'CPTRainPosterior' is not defined.
2018-11-03 18:42:45 - The field, constructor or member 'CPTRainPosterior' is not defined.
2018-11-03 18:42:45 - The field, constructor or member 'CPTWetGrassPosterior' is not defined.
2018-11-03 18:42:45 - The field, constructor or member 'CPTWetGrassPosterior' is not defined.
2018-11-03 18:42:45 - The field, constructor or member 'CPTWetGrassPosterior' is not defined.
2018-11-03 18:42:45 - The field, constructor or member 'CPTWetGrassPosterior' is not defined.
2018-11-03 18:42:45 - // Use posteriors we have just learnt
2018-11-03 18:42:45 - let probRainGivenWetGrass1 = model.ProbRain(null, null, 0, model.ProbCloudyPosterior, model.CPTSprinklerPosterior, model.CPTRainPosterior, model.CPTWetGrassPosterior)
2018-11-03 18:42:45 - let probRainGivenWetGrassNotCloudy1 = model.ProbRain(1, null, 0, model.ProbCloudyPosterior, model.CPTSprinklerPosterior, model.CPTRainPosterior, model.CPTWetGrassPosterior)
2018-11-03 18:42:45 - The field, constructor or member 'ProbRain' is not defined.
2018-11-03 18:42:45 - The field, constructor or member 'ProbRain' is not defined.
2018-11-03 18:42:45 - probRainGivenWetGrass1
2018-11-03 18:42:46 - The value or constructor 'probRainGivenWetGrass1' is not defined. Maybe you want one of the following:
2018-11-03 18:42:46 -    probRain
2018-11-03 18:42:46 - probRainGivenWetGrassNotCloudy1
2018-11-03 18:42:46 - The value or constructor 'probRainGivenWetGrassNotCloudy1' is not defined.
2018-11-03 18:42:46 - let sizes:array<int> = [| 2; 3 |]  
2018-11-03 18:42:46 - let item:Range = Range(sizes.Length).Named("item")  // Standard range of 2 items is outer loop
2018-11-03 18:42:46 - let sizesVar:VariableArray<int> = Variable.Constant(sizes, item).Named("sizes")  
2018-11-03 18:42:46 - let feature:Range =  Range(sizesVar.[item]).Named("feature")  // Inner range "feature" is variable in size
2018-11-03 18:42:46 - let x:VariableArray<VariableArray<float>,float[][]>
2018-11-03 18:42:46 -         = Variable.Array<VariableArray<float>,float[][]>(Variable.Array<float>(feature), item).Named("x");
2018-11-03 18:42:47 - let xPrior:Gaussian = Gaussian(1.2, 3.4) 
2018-11-03 18:42:47 - x.[item].[feature] <- Variable.Random(xPrior).ForEach(item, feature)  // Assign all 5 item-features (!)
2018-11-03 18:42:47 - Variable.ConstrainPositive(x.[item].[feature])   // Constrain all 5 item-features (!)
2018-11-03 18:42:47 - //using the Foreach Block  
2018-11-03 18:42:47 - let pixel = Range(10)  
2018-11-03 18:42:47 - let bools = Variable.Array<bool>(pixel)
2018-11-03 18:42:47 - Variable.ForeachBlock pixel ( fun pixel -> bools.[pixel] <- Variable.Bernoulli(0.7) ||| Variable.Bernoulli(0.4))
2018-11-03 18:42:48 - //using the Switch Block - to model a 2 component (scalar) Gaussian mixture
2018-11-03 18:42:48 - let mixtureSize = 2  
2018-11-03 18:42:48 - let k2 = Range(mixtureSize)  
2018-11-03 18:42:48 - let c:Variable<int> = Variable.Discrete(k2, [|0.5;0.5|])  // c is a discrete random variable with values {0,1}
2018-11-03 18:42:48 - let means2:VariableArray<float> = Variable.Observed( [|1.0;2.0|], k2)  // Constant means for each Gaussian
2018-11-03 18:42:48 - let x:Variable<float> = Variable.New<double>()  // x is a univariate Gaussian
2018-11-03 18:42:48 - Variable.SwitchBlock c (fun _ -> 
2018-11-03 18:42:48 -     let _ = x.SetTo(Variable.GaussianFromMeanAndVariance(means2.[c], 1.0))  
2018-11-03 18:42:48 -     ()  
2018-11-03 18:42:48 - )
2018-11-03 18:42:49 - //using the SwitchExpr Block - to model 100 outcomes of a 2-component mixture Wishart distributed variable
2018-11-03 18:42:49 - let k =  Range(2).Named("k")
2018-11-03 18:42:49 - // Loop over mixture components - parameters are constant, so don't vary based on prior distribution, yet
2018-11-03 18:42:49 - let means:VariableArray<Vector> = 
2018-11-03 18:42:49 -     Variable.ArrayInit k (fun k ->  
2018-11-03 18:42:49 -         Variable.VectorGaussianFromMeanAndPrecision( Vector.Constant(2,0.0), PositiveDefiniteMatrix.Identity(2)))  
2018-11-03 18:42:49 - let precs:VariableArray<PositiveDefiniteMatrix> =  
2018-11-03 18:42:49 -     Variable.ArrayInit k (fun k -> 
2018-11-03 18:42:49 -         Variable.WishartFromShapeAndScale(1.0,  
2018-11-03 18:42:49 -             PositiveDefiniteMatrix.Identity(2)))  
2018-11-03 18:42:49 - let weights = Variable.Dirichlet(k,[|1.0; 1.0|])
2018-11-03 18:42:50 - let n = Range(100).Named("n")
2018-11-03 18:42:50 - let z:VariableArray<int> = Variable.ArrayInit n (fun i -> Variable.Discrete(weights))  
2018-11-03 18:42:50 - let data = Variable.ArrayInit n (fun (i:Range)->  
2018-11-03 18:42:50 -                Variable.SwitchExpr (z.[i]) (fun (zi:Variable<int>) ->  
2018-11-03 18:42:50 -                    Variable.VectorGaussianFromMeanAndPrecision(means.[zi], precs.[zi])))
2018-11-03 18:42:51 - // Data from a clinical trial  
2018-11-03 18:42:51 - let controlGroup = Variable.Observed<bool>([|false; false; true; false; false|])  
2018-11-03 18:42:51 - let treatedGroup = Variable.Observed<bool>([|true; false; true; true; true |])  
2018-11-03 18:42:51 - let i = controlGroup.Range  
2018-11-03 18:42:51 - let j = treatedGroup.Range  
2018-11-03 18:42:51 - // Prior on being an effective treatment  
2018-11-03 18:42:51 - let isEffective = Variable.Bernoulli(0.5).Named("isEffective");  
2018-11-03 18:42:51 - let probIfTreated = ref (Variable.New<float>())  
2018-11-03 18:42:51 - let probIfControl = ref (Variable.New<float>())
2018-11-03 18:42:51 - // If Block function  
2018-11-03 18:42:51 - let f1 (vb1: Variable<bool>) =  
2018-11-03 18:42:51 -     probIfControl := Variable.Beta(1.0, 1.0).Named("probIfControl")  
2018-11-03 18:42:51 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->
2018-11-03 18:42:51 -         Variable.Bernoulli(!probIfControl)) 
2018-11-03 18:42:51 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->
2018-11-03 18:42:51 -         Variable.Bernoulli(!probIfTreated))  
2018-11-03 18:42:51 -     ()  
2018-11-03 18:42:51 - // IfNot Block function  
2018-11-03 18:42:51 - let f2 (vb2: Variable<bool>) =  
2018-11-03 18:42:51 -     let probAll = Variable.Beta(1.0, 1.0).Named("probAll")  
2018-11-03 18:42:51 -     let controlGroup = Variable.AssignVariableArray controlGroup i (fun i ->Variable.Bernoulli(probAll))  
2018-11-03 18:42:51 -     let treatedGroup = Variable.AssignVariableArray treatedGroup j (fun j ->Variable.Bernoulli(probAll))  
2018-11-03 18:42:51 -     ()  
2018-11-03 18:42:52 - // Call IfBlock  
2018-11-03 18:42:52 - let _ = Variable.IfBlock isEffective f1 f2
2018-11-03 21:00:00 - let sample  (numData:int)
2018-11-03 21:00:00 -             (dpv:DistributionParameterValues) : int[][] =     
2018-11-03 21:00:00 -     Array.init numData (fun _ ->
2018-11-03 21:00:00 -             let cloudy = Discrete.Sample(dpv.cloudy);
2018-11-03 21:00:00 -             let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy]);
2018-11-03 21:00:00 -             let rain = Discrete.Sample(dpv.rain.[cloudy]);
2018-11-03 21:00:00 -             let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]);
2018-11-03 21:00:00 -             [|cloudy;sprinkler;rain;wetGrass|])
2018-11-03 21:00:01 - sample 10 dpv
2018-11-03 21:03:35 - dpv
2018-11-03 21:04:08 - let sample = sample 10 dpv
2018-11-03 21:05:04 - let sample  (numData:int)
2018-11-03 21:05:04 -             (dpv:DistributionParameterValues) : int[][] =     
2018-11-03 21:05:04 -     Array.init numData (fun _ ->
2018-11-03 21:05:04 -             let cloudy = Discrete.Sample(dpv.cloudy);
2018-11-03 21:05:04 -             let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy]);
2018-11-03 21:05:04 -             let rain = Discrete.Sample(dpv.rain.[cloudy]);
2018-11-03 21:05:04 -             let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]);
2018-11-03 21:05:04 -             [|cloudy;sprinkler;rain;wetGrass|])
2018-11-03 21:05:34 - let dpv = setDistributionParameterValues ()
2018-11-03 21:05:41 - let sample10 = sample 10 dpv
2018-11-03 21:05:50 - sample[0]
2018-11-03 21:05:51 - This expression was expected to have type
2018-11-03 21:05:51 -     'int'    
2018-11-03 21:05:51 - but here has type
2018-11-03 21:05:51 -     ''a list'    
2018-11-03 21:06:01 - sample.[0]
2018-11-03 21:06:01 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-11-03 21:06:11 - sample10.[0]
2018-11-03 21:08:15 - let sample  (numData:int)
2018-11-03 21:08:15 -             (dpv:DistributionParameterValues) : int[][] =     
2018-11-03 21:08:15 -     Array.init numData (fun _ ->
2018-11-03 21:08:15 -             let cloudy = Discrete.Sample(dpv.cloudy);
2018-11-03 21:08:15 -             let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy]);
2018-11-03 21:08:15 -             let rain = Discrete.Sample(dpv.rain.[cloudy]);
2018-11-03 21:08:15 -             let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]);
2018-11-03 21:08:15 -     [|cloudy;sprinkler;rain;wetGrass|])
2018-11-03 21:08:16 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2018-11-03 21:08:16 - Possible incorrect indentation: this token is offside of context started at position (3:5). Try indenting this token further or using standard formatting conventions.
2018-11-03 21:08:16 - Unexpected symbol '[|' in expression
2018-11-03 21:08:16 - Unexpected symbol ')' in binding. Expected incomplete structured construct at or before this point or other token.
2018-11-03 21:08:16 - sample 10 dpv
2018-11-03 21:09:06 - let sample  (numData:int)
2018-11-03 21:09:06 -             (dpv:DistributionParameterValues) : int[][] =     
2018-11-03 21:09:06 -     Array.init numData (fun _ ->
2018-11-03 21:09:06 -             let cloudy = Discrete.Sample(dpv.cloudy)
2018-11-03 21:09:06 -             let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy])
2018-11-03 21:09:06 -             let rain = Discrete.Sample(dpv.rain.[cloudy])
2018-11-03 21:09:06 -             let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]))
2018-11-03 21:09:06 -     [|cloudy;sprinkler;rain;wetGrass|]
2018-11-03 21:09:07 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2018-11-03 21:09:07 - sample 10 dpv
2018-11-03 21:10:19 - let sample  (numData:int)
2018-11-03 21:10:19 -             (dpv:DistributionParameterValues) : int[][] =     
2018-11-03 21:10:19 -     Array.init numData (fun _ ->
2018-11-03 21:10:19 -             let cloudy = Discrete.Sample(dpv.cloudy);
2018-11-03 21:10:19 -             let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy]);
2018-11-03 21:10:19 -             let rain = Discrete.Sample(dpv.rain.[cloudy]);
2018-11-03 21:10:19 -             let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]))
2018-11-03 21:10:19 -     [|cloudy;sprinkler;rain;wetGrass|]
2018-11-03 21:10:20 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2018-11-03 21:15:00 - let sample  (numData:int)
2018-11-03 21:15:00 -             (dpv:DistributionParameterValues) : int[][] =     
2018-11-03 21:15:00 -     let cloudy = Array.init numData (fun _ -> Discrete.Sample(dpv.cloudy))
2018-11-03 21:15:00 -     let sprinkler = Array.init numData (fun _ -> Discrete.Sample(dpv.sprinkler.[cloudy]))
2018-11-03 21:15:00 -     let rain = Array.init numData (fun _ -> Discrete.Sample(dpv.rain.[cloudy]))
2018-11-03 21:15:00 -     let wetGrass = Array.init numData (fun _ -> Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]))
2018-11-03 21:15:00 -     [|cloudy;sprinkler;rain;wetGrass|]
2018-11-03 21:15:00 - This expression was expected to have type
2018-11-03 21:15:00 -     'int'    
2018-11-03 21:15:00 - but here has type
2018-11-03 21:15:00 -     'int []'    
2018-11-03 21:15:00 - This expression was expected to have type
2018-11-03 21:15:00 -     'int'    
2018-11-03 21:15:00 - but here has type
2018-11-03 21:15:00 -     'int []'    
2018-11-03 21:15:00 - This expression was expected to have type
2018-11-03 21:15:00 -     'int'    
2018-11-03 21:15:00 - but here has type
2018-11-03 21:15:00 -     'int []'    
2018-11-03 21:15:00 - This expression was expected to have type
2018-11-03 21:15:00 -     'int'    
2018-11-03 21:15:00 - but here has type
2018-11-03 21:15:00 -     'int []'    
2018-11-03 21:15:01 - sample 10 dpv
2018-11-03 21:16:42 - let sample  (numData:int)
2018-11-03 21:16:42 -             (dpv:DistributionParameterValues) =     
2018-11-03 21:16:42 -     let cloudy = Array.init numData (fun _ -> Discrete.Sample(dpv.cloudy))
2018-11-03 21:16:42 -     let sprinkler = Array.init numData (fun _ -> Discrete.Sample(dpv.sprinkler.[cloudy]))
2018-11-03 21:16:42 -     let rain = Array.init numData (fun _ -> Discrete.Sample(dpv.rain.[cloudy]))
2018-11-03 21:16:42 -     let wetGrass = Array.init numData (fun _ -> Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]))
2018-11-03 21:16:42 -     [|cloudy; sprinkler; rain; wetGrass|]
2018-11-03 21:16:42 - This expression was expected to have type
2018-11-03 21:16:42 -     'int'    
2018-11-03 21:16:42 - but here has type
2018-11-03 21:16:42 -     'int []'    
2018-11-03 21:16:42 - This expression was expected to have type
2018-11-03 21:16:42 -     'int'    
2018-11-03 21:16:42 - but here has type
2018-11-03 21:16:42 -     'int []'    
2018-11-03 21:16:42 - This expression was expected to have type
2018-11-03 21:16:42 -     'int'    
2018-11-03 21:16:42 - but here has type
2018-11-03 21:16:42 -     'int []'    
2018-11-03 21:16:42 - This expression was expected to have type
2018-11-03 21:16:42 -     'int'    
2018-11-03 21:16:42 - but here has type
2018-11-03 21:16:42 -     'int []'    
2018-11-03 21:16:42 - sample 10 dpv
2018-11-03 21:17:21 - dpv.cloudy
2018-11-03 21:17:40 - Discrete.Sample(dpv.cloudy)
2018-11-03 21:18:24 - let cloudy = Array.init numData (fun _ -> Discrete.Sample(dpv.cloudy))
2018-11-03 21:18:24 - let sprinkler = Array.init numData (fun _ -> Discrete.Sample(dpv.sprinkler.[cloudy]))
2018-11-03 21:18:24 - let rain = Array.init numData (fun _ -> Discrete.Sample(dpv.rain.[cloudy]))
2018-11-03 21:18:24 - let wetGrass = Array.init numData (fun _ -> Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]))
2018-11-03 21:18:25 - The value or constructor 'numData' is not defined.
2018-11-03 21:18:25 - The value or constructor 'numData' is not defined.
2018-11-03 21:18:25 - This expression was expected to have type
2018-11-03 21:18:25 -     'int'    
2018-11-03 21:18:25 - but here has type
2018-11-03 21:18:25 -     'int []'    
2018-11-03 21:18:25 - The value or constructor 'numData' is not defined.
2018-11-03 21:18:25 - This expression was expected to have type
2018-11-03 21:18:25 -     'int'    
2018-11-03 21:18:25 - but here has type
2018-11-03 21:18:25 -     'int []'    
2018-11-03 21:18:25 - The value or constructor 'numData' is not defined.
2018-11-03 21:18:25 - This expression was expected to have type
2018-11-03 21:18:25 -     'int'    
2018-11-03 21:18:25 - but here has type
2018-11-03 21:18:25 -     'int []'    
2018-11-03 21:18:25 - This expression was expected to have type
2018-11-03 21:18:25 -     'int'    
2018-11-03 21:18:25 - but here has type
2018-11-03 21:18:25 -     'int []'    
2018-11-03 21:18:36 - let cloudy = Array.init 5 (fun _ -> Discrete.Sample(dpv.cloudy))
2018-11-03 21:18:36 - let sprinkler = Array.init 5 (fun _ -> Discrete.Sample(dpv.sprinkler.[cloudy]))
2018-11-03 21:18:36 - let rain = Array.init 5 (fun _ -> Discrete.Sample(dpv.rain.[cloudy]))
2018-11-03 21:18:36 - let wetGrass = Array.init 5 (fun _ -> Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]))
2018-11-03 21:18:36 - This expression was expected to have type
2018-11-03 21:18:36 -     'int'    
2018-11-03 21:18:36 - but here has type
2018-11-03 21:18:36 -     'int []'    
2018-11-03 21:18:36 - This expression was expected to have type
2018-11-03 21:18:36 -     'int'    
2018-11-03 21:18:36 - but here has type
2018-11-03 21:18:36 -     'int []'    
2018-11-03 21:18:36 - This expression was expected to have type
2018-11-03 21:18:36 -     'int'    
2018-11-03 21:18:36 - but here has type
2018-11-03 21:18:36 -     'int []'    
2018-11-03 21:18:36 - This expression was expected to have type
2018-11-03 21:18:36 -     'int'    
2018-11-03 21:18:36 - but here has type
2018-11-03 21:18:36 -     'int []'    
2018-11-05 19:29:34 - Reporting 0 opened comms
2018-11-05 19:34:56 - #load "Paket.fsx"
2018-11-05 19:35:28 - Paket.Package
2018-11-05 19:35:28 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2018-11-05 19:35:28 -       "Microsoft.ML.Probabilistic"
2018-11-05 19:35:28 -       "Microsoft.ML.Probabilistic.Compiler"
2018-11-05 19:35:28 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2018-11-05 19:35:28 -       "NETStandard.Library"
2018-11-05 19:35:28 -   ]
2018-11-05 19:36:39 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2018-11-05 19:36:46 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2018-11-05 19:37:48 - //#load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-11-05 19:37:48 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2018-11-05 19:37:48 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2018-11-05 19:37:48 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2018-11-05 19:37:49 - #r "Microsoft.ML.Probabilistic"
2018-11-05 19:37:49 - #r "Microsoft.ML.Probabilistic.Compiler"
2018-11-05 19:37:49 - #r "netstandard"
2018-11-05 19:37:49 - open System
2018-11-05 19:37:50 - open Microsoft.ML.Probabilistic  
2018-11-05 19:37:50 - open Microsoft.ML.Probabilistic.Models  
2018-11-05 19:37:50 - open Microsoft.ML.Probabilistic.Distributions  
2018-11-05 19:37:50 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2018-11-05 19:37:50 - open Microsoft.ML.Probabilistic.Math
2018-11-05 19:37:54 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2018-11-05 19:38:00 - open Microsoft.ML.Probabilistic.FSharp
2018-11-05 19:38:01 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2018-11-05 19:38:01 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2018-11-05 19:38:01 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2018-11-05 19:38:01 - let AddChildFromOneParent 
2018-11-05 19:38:01 -         (parent:RandomVariable) 
2018-11-05 19:38:01 -         (cpt:ConditionalProbabilityTable) =
2018-11-05 19:38:01 -     let r = parent.Range
2018-11-05 19:38:01 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-11-05 19:38:01 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-11-05 19:38:01 -                        Variable.Discrete(cpt.[pi])))
2018-11-05 19:38:01 -     child
2018-11-05 19:38:02 - type ConditionalProbabilityTable2D = 
2018-11-05 19:38:02 -     VariableArray<VariableArray<Vector>, Vector[][]>
2018-11-05 19:38:02 - let AddChildFromTwoParents 
2018-11-05 19:38:02 -         (parent1:RandomVariable) 
2018-11-05 19:38:02 -         (parent2:RandomVariable) 
2018-11-05 19:38:02 -         (cpt:ConditionalProbabilityTable2D) = 
2018-11-05 19:38:02 -     let r = parent1.Range
2018-11-05 19:38:02 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-11-05 19:38:02 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-11-05 19:38:02 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-11-05 19:38:02 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2018-11-05 19:38:02 -     child       
2018-11-05 19:38:04 - type RandomVariables =
2018-11-05 19:38:04 -     {cloudy:VariableArray<int>;
2018-11-05 19:38:04 -     sprinkler:VariableArray<int>;
2018-11-05 19:38:04 -     rain:VariableArray<int>;
2018-11-05 19:38:04 -     wetGrass:VariableArray<int> }
2018-11-05 19:38:05 - type ObservedValues =
2018-11-05 19:38:05 -     {cloudy:array<int>;
2018-11-05 19:38:05 -     sprinkler:array<int>;
2018-11-05 19:38:05 -     rain:array<int>;
2018-11-05 19:38:05 -     wetGrass:array<int> }
2018-11-05 19:38:05 - type DistributionParameters =
2018-11-05 19:38:05 -     {cloudy:Variable<Vector> ;
2018-11-05 19:38:05 -     sprinkler:VariableArray<Vector> ;
2018-11-05 19:38:05 -     rain:VariableArray<Vector> ;
2018-11-05 19:38:05 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2018-11-05 19:38:06 - type DistributionParameterValues =  
2018-11-05 19:38:06 -     {cloudy:Vector;     // probCloudy     2-vector
2018-11-05 19:38:06 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2018-11-05 19:38:06 -     rain:Vector[];      // cptRain        2-vector * 2
2018-11-05 19:38:06 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2018-11-05 19:38:06 -     }
2018-11-05 19:38:09 - type PriorDistributions =
2018-11-05 19:38:09 -     {cloudy:Variable<Dirichlet> ;
2018-11-05 19:38:09 -     sprinkler:VariableArray<Dirichlet> ;
2018-11-05 19:38:09 -     rain:VariableArray<Dirichlet> ;
2018-11-05 19:38:09 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2018-11-05 19:38:09 - type PosteriorDistributions =
2018-11-05 19:38:09 -     {cloudy:Dirichlet ;
2018-11-05 19:38:09 -     sprinkler:Dirichlet[] ;
2018-11-05 19:38:09 -     rain:Dirichlet[] ;
2018-11-05 19:38:09 -     wetGrass:Dirichlet[][] }
2018-11-05 19:38:10 - type Ranges = {c:Range;s:Range;r:Range;w:Range}
2018-11-05 19:38:10 - let engine =  InferenceEngine ()
2018-11-05 19:38:10 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-11-05 19:38:10 - let rN:Range = Range(numberOfExamples).Named("N")
2018-11-05 19:38:11 - let rC = Range(2).Named("C") // Cloudy
2018-11-05 19:38:11 - let rS = Range(2).Named("S") // Sprinkler
2018-11-05 19:38:11 - let rR = Range(2).Named("R") // Rain
2018-11-05 19:38:11 - let rW = Range(2).Named("W") // Wet
2018-11-05 19:38:11 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2018-11-05 19:38:11 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2018-11-05 19:38:11 - probCloudy.SetValueRange(rC)
2018-11-05 19:38:15 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2018-11-05 19:38:15 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2018-11-05 19:38:16 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2018-11-05 19:38:16 - cptSprinkler.SetValueRange(rS)
2018-11-05 19:38:16 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2018-11-05 19:38:16 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2018-11-05 19:38:16 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2018-11-05 19:38:16 - cptRain.SetValueRange(rR)
2018-11-05 19:38:18 - let cptWetGrassPrior= 
2018-11-05 19:38:18 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-11-05 19:38:18 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2018-11-05 19:38:18 - let cptWetGrass = 
2018-11-05 19:38:18 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-11-05 19:38:18 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2018-11-05 19:38:18 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2018-11-05 19:38:18 - cptWetGrass.SetValueRange(rW)
2018-11-05 19:38:19 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-11-05 19:38:19 - let priors:PriorDistributions = {
2018-11-05 19:38:19 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-11-05 19:38:19 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2018-11-05 19:38:19 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2018-11-05 19:38:19 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-11-05 19:38:19 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2018-11-05 19:38:19 - let parameters:DistributionParameters = {
2018-11-05 19:38:19 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2018-11-05 19:38:19 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2018-11-05 19:38:19 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2018-11-05 19:38:19 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-11-05 19:38:19 -                 Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2018-11-05 19:38:21 - parameters.cloudy.SetValueRange(ranges.c)
2018-11-05 19:38:21 - parameters.sprinkler.[ranges.c] <- Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c])
2018-11-05 19:38:21 - parameters.sprinkler.SetValueRange(ranges.s)
2018-11-05 19:38:21 - parameters.rain.[ranges.c] <- Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c])
2018-11-05 19:38:21 - parameters.rain.SetValueRange(ranges.r)
2018-11-05 19:38:21 - parameters.wetGrass.[ranges.s].[ranges.r] <- Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[ranges.s].[ranges.r])
2018-11-05 19:38:21 - parameters.wetGrass.SetValueRange(ranges.w)
2018-11-05 19:38:22 - let buildPriors (rg:Ranges) : PriorDistributions =
2018-11-05 19:38:22 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-11-05 19:38:22 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-11-05 19:38:22 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-11-05 19:38:22 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-11-05 19:38:22 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-11-05 19:38:22 - let priors = buildPriors ranges
2018-11-05 19:38:23 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-11-05 19:38:23 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-11-05 19:38:23 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-11-05 19:38:23 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-11-05 19:38:23 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-11-05 19:38:23 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-11-05 19:38:23 -     probCloudy.SetValueRange(rg.c)
2018-11-05 19:38:23 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-11-05 19:38:23 -     cptSprinkler.SetValueRange(rg.s)
2018-11-05 19:38:23 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-11-05 19:38:23 -     cptRain.SetValueRange(rg.r)
2018-11-05 19:38:23 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-11-05 19:38:23 -     cptWetGrass.SetValueRange(rg.w)
2018-11-05 19:38:23 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-11-05 19:38:23 - let parameters = buildDistributionParameters ranges priors
2018-11-05 19:38:26 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-11-05 19:38:26 - let rN:Range = Range(numberOfExamples).Named("N")
2018-11-05 19:38:27 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2018-11-05 19:38:27 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-11-05 19:38:27 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("sprinkler")
2018-11-05 19:38:27 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("rain")
2018-11-05 19:38:27 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("wetGrass")
2018-11-05 19:38:28 - let rvs:RandomVariables =
2018-11-05 19:38:28 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2018-11-05 19:38:28 -     vC.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2018-11-05 19:38:28 -     let vS = (AddChildFromOneParent vC cptSprinkler).Named("sprinkler")
2018-11-05 19:38:28 -     let vR = (AddChildFromOneParent vC cptRain).Named("rain")
2018-11-05 19:38:28 -     let vW = (AddChildFromTwoParents vS vR cptWetGrass).Named("wetGrass")
2018-11-05 19:38:28 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-11-05 19:38:29 - let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-11-05 19:38:29 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2018-11-05 19:38:29 -     vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-11-05 19:38:29 -     let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-11-05 19:38:29 -     let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2018-11-05 19:38:29 -     let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-11-05 19:38:29 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-11-05 19:38:30 - let numberOfExamples = Variable.New<int>().Named("NofE")
2018-11-05 19:38:30 - let rN = Range(numberOfExamples).Named("N")
2018-11-05 19:38:30 - let ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("W")}
2018-11-05 19:38:30 - let priors = buildPriors ranges
2018-11-05 19:38:30 - let parameters = buildDistributionParameters ranges priors
2018-11-05 19:38:31 - let rvs = buildRandomVariables rN parameters
2018-11-05 19:38:32 - let a:array<int> = [|3|]
2018-11-05 19:38:32 - let b:int[] =  [|3|]
2018-11-05 19:38:32 - let c:int[] = a
2018-11-05 19:38:32 - let d:Vector[][] = [|[|Vector.FromArray(2.,3.)|]|]
2018-11-05 19:38:32 - let e:array<array<Vector>> = [|[|Vector.FromArray(2.,3.)|]|]
2018-11-05 19:38:32 - let f:array<array<Vector>> = d
2018-11-05 19:38:33 - type WetGrassSprinklerRainModel() =
2018-11-05 19:38:33 -     
2018-11-05 19:38:33 -     // Private functions (used by constructor)
2018-11-05 19:38:33 -     let addChildFromOneParent 
2018-11-05 19:38:33 -             (parent:RandomVariable) 
2018-11-05 19:38:33 -             (cpt:ConditionalProbabilityTable) =
2018-11-05 19:38:33 -         let r = parent.Range
2018-11-05 19:38:33 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-11-05 19:38:33 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-11-05 19:38:33 -                            Variable.Discrete(cpt.[pi])))
2018-11-05 19:38:33 -         child
2018-11-05 19:38:33 -         
2018-11-05 19:38:33 -     let addChildFromTwoParents 
2018-11-05 19:38:33 -             (parent1:RandomVariable) 
2018-11-05 19:38:33 -             (parent2:RandomVariable) 
2018-11-05 19:38:33 -             (cpt:ConditionalProbabilityTable2D) = 
2018-11-05 19:38:33 -         let r = parent1.Range
2018-11-05 19:38:33 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-11-05 19:38:33 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-11-05 19:38:33 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-11-05 19:38:33 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-11-05 19:38:33 -         child    
2018-11-05 19:38:33 -         
2018-11-05 19:38:33 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-11-05 19:38:33 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-11-05 19:38:33 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-11-05 19:38:33 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-11-05 19:38:33 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-11-05 19:38:33 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-11-05 19:38:33 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-11-05 19:38:33 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-11-05 19:38:33 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-11-05 19:38:33 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-11-05 19:38:33 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-11-05 19:38:33 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-11-05 19:38:33 -         do probCloudy.SetValueRange(rg.c)
2018-11-05 19:38:33 -         do cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-11-05 19:38:33 -         do cptSprinkler.SetValueRange(rg.s)
2018-11-05 19:38:33 -         do cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-11-05 19:38:33 -         do cptRain.SetValueRange(rg.r)
2018-11-05 19:38:33 -         do cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-11-05 19:38:33 -         do cptWetGrass.SetValueRange(rg.w)
2018-11-05 19:38:33 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-11-05 19:38:33 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-11-05 19:38:33 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-11-05 19:38:33 -         do vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-11-05 19:38:33 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-11-05 19:38:33 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-11-05 19:38:33 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-11-05 19:38:33 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-11-05 19:38:33 -      
2018-11-05 19:38:33 -     // Private fields
2018-11-05 19:38:33 -     let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-11-05 19:38:33 -     let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-11-05 19:38:33 -     let rN:Range = Range(numberOfExamples).Named("N")
2018-11-05 19:38:33 -     let priors = buildPriors ranges
2018-11-05 19:38:33 -     let parameters = buildDistributionParameters ranges priors
2018-11-05 19:38:33 -     let primaryRandomVariables = buildRandomVariables rN parameters
2018-11-05 19:38:33 -     let engine = InferenceEngine ()
2018-11-05 19:38:33 -     
2018-11-05 19:38:33 -     // Properties
2018-11-05 19:38:33 -     member this.Ranges = ranges
2018-11-05 19:38:33 -     member this.NumberOfExamples = numberOfExamples
2018-11-05 19:38:33 -     member this.RangeN = rN
2018-11-05 19:38:33 -     member this.Priors = priors
2018-11-05 19:38:33 -     member this.Parameters = parameters
2018-11-05 19:38:33 -     member this.PrimaryRandomVariables = primaryRandomVariables
2018-11-05 19:38:33 -     member this.Engine = engine
2018-11-05 19:38:34 - let model = WetGrassSprinklerRainModel ()  
2018-11-05 19:38:35 - module WetGrassSprinklerRainModel2 =
2018-11-05 19:38:35 -     // Functions
2018-11-05 19:38:35 -     let addChildFromOneParent 
2018-11-05 19:38:35 -             (parent:RandomVariable) 
2018-11-05 19:38:35 -             (cpt:ConditionalProbabilityTable) =
2018-11-05 19:38:35 -         let r = parent.Range
2018-11-05 19:38:35 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-11-05 19:38:35 -                        Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2018-11-05 19:38:35 -                            Variable.Discrete(cpt.[pi])))
2018-11-05 19:38:35 -         child
2018-11-05 19:38:35 -         
2018-11-05 19:38:35 -     let addChildFromTwoParents 
2018-11-05 19:38:35 -             (parent1:RandomVariable) 
2018-11-05 19:38:35 -             (parent2:RandomVariable) 
2018-11-05 19:38:35 -             (cpt:ConditionalProbabilityTable2D) = 
2018-11-05 19:38:35 -         let r = parent1.Range
2018-11-05 19:38:35 -         let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2018-11-05 19:38:35 -                    Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2018-11-05 19:38:35 -                        Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2018-11-05 19:38:35 -                            Variable.Discrete(cpt.[pi1].[pi2]))))
2018-11-05 19:38:35 -         child    
2018-11-05 19:38:35 -     
2018-11-05 19:38:35 -     let buildPriors (rg:Ranges) : PriorDistributions =
2018-11-05 19:38:35 -         {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2018-11-05 19:38:35 -             sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2018-11-05 19:38:35 -             rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2018-11-05 19:38:35 -             wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2018-11-05 19:38:35 -                                     Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2018-11-05 19:38:35 -     let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2018-11-05 19:38:35 -         let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2018-11-05 19:38:35 -         let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2018-11-05 19:38:35 -         let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2018-11-05 19:38:35 -         let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2018-11-05 19:38:35 -                                 Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2018-11-05 19:38:35 -         probCloudy.SetValueRange(rg.c)
2018-11-05 19:38:35 -         cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2018-11-05 19:38:35 -         cptSprinkler.SetValueRange(rg.s)
2018-11-05 19:38:35 -         cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2018-11-05 19:38:35 -         cptRain.SetValueRange(rg.r)
2018-11-05 19:38:35 -         cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2018-11-05 19:38:35 -         cptWetGrass.SetValueRange(rg.w)
2018-11-05 19:38:35 -         {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2018-11-05 19:38:35 -     let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2018-11-05 19:38:35 -         let vC = Variable.Array<int>(rN).Named("cloudy")
2018-11-05 19:38:35 -         vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2018-11-05 19:38:35 -         let vS = (addChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2018-11-05 19:38:35 -         let vR = (addChildFromOneParent vC dp.rain).Named("rain")
2018-11-05 19:38:35 -         let vW = (addChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2018-11-05 19:38:35 -         {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2018-11-05 19:38:37 - open WetGrassSprinklerRainModel2
2018-11-05 19:38:37 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2018-11-05 19:38:37 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2018-11-05 19:38:37 - let rN:Range = Range(numberOfExamples).Named("N")
2018-11-05 19:38:37 - let priors = buildPriors ranges
2018-11-05 19:38:37 - let parameters = buildDistributionParameters ranges priors
2018-11-05 19:38:37 - let rvs = buildRandomVariables rN parameters
2018-11-05 19:38:37 - let engine =  InferenceEngine ()
2018-11-05 19:38:38 - let setDistributionParameterValues (): DistributionParameterValues =
2018-11-05 19:38:38 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2018-11-05 19:38:38 -     let cptSprinkler:Vector[] = 
2018-11-05 19:38:38 -         [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] 
2018-11-05 19:38:38 -         |> Array.map (fun a -> Vector.FromArray a)
2018-11-05 19:38:38 -     let cptRain:Vector[] =      
2018-11-05 19:38:38 -         [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] 
2018-11-05 19:38:38 -         |> Array.map (fun a -> Vector.FromArray a)
2018-11-05 19:38:38 -     let cptWetGrass:Vector[][] = 
2018-11-05 19:38:38 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2018-11-05 19:38:38 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2018-11-05 19:38:38 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2018-11-05 19:38:38 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2018-11-05 19:38:38 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2018-11-05 19:38:38 -     {cloudy=probCloudy; sprinkler=cptSprinkler; rain=cptRain; wetGrass=cptWetGrass}
2018-11-05 19:38:38 - let dpv = setDistributionParameterValues ()
2018-11-05 19:40:00 - dpv
2018-11-05 19:40:39 - let cloudy = Array.init 5 (fun _ -> Discrete.Sample(dpv.cloudy))
2018-11-05 19:40:39 - let sprinkler = Array.init 5 (fun _ -> Discrete.Sample(dpv.sprinkler.[cloudy]))
2018-11-05 19:40:39 - let rain = Array.init 5 (fun _ -> Discrete.Sample(dpv.rain.[cloudy]))
2018-11-05 19:40:39 - let wetGrass = Array.init 5 (fun _ -> Discrete.Sample(dpv.wetGrass.[sprinkler].[rain]))
2018-11-05 19:40:40 - This expression was expected to have type
2018-11-05 19:40:40 -     'int'    
2018-11-05 19:40:40 - but here has type
2018-11-05 19:40:40 -     'int []'    
2018-11-05 19:40:40 - This expression was expected to have type
2018-11-05 19:40:40 -     'int'    
2018-11-05 19:40:40 - but here has type
2018-11-05 19:40:40 -     'int []'    
2018-11-05 19:40:40 - This expression was expected to have type
2018-11-05 19:40:40 -     'int'    
2018-11-05 19:40:40 - but here has type
2018-11-05 19:40:40 -     'int []'    
2018-11-05 19:40:40 - This expression was expected to have type
2018-11-05 19:40:40 -     'int'    
2018-11-05 19:40:40 - but here has type
2018-11-05 19:40:40 -     'int []'    
2018-11-05 19:41:07 - let sample  (numData:int)
2018-11-05 19:41:07 -             (dpv:DistributionParameterValues) : int[][] =   
2018-11-05 19:41:07 -     Array.init numData (fun _ -> 
2018-11-05 19:41:07 -         let cloudy =  Discrete.Sample(dpv.cloudy)
2018-11-05 19:41:07 -         let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy])
2018-11-05 19:41:07 -         let rain = Discrete.Sample(dpv.rain.[cloudy])
2018-11-05 19:41:07 -         let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain])
2018-11-05 19:41:07 -         [|cloudy; sprinkler; rain; wetGrass|]
2018-11-05 19:41:08 - Unmatched '('
2018-11-05 19:41:21 - let sample  (numData:int)
2018-11-05 19:41:21 -             (dpv:DistributionParameterValues) : int[][] =   
2018-11-05 19:41:21 -     Array.init numData (fun _ -> 
2018-11-05 19:41:21 -         let cloudy =  Discrete.Sample(dpv.cloudy)
2018-11-05 19:41:21 -         let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy])
2018-11-05 19:41:21 -         let rain = Discrete.Sample(dpv.rain.[cloudy])
2018-11-05 19:41:21 -         let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain])
2018-11-05 19:41:21 -         [|cloudy; sprinkler; rain; wetGrass|])
2018-11-05 19:41:31 - sample 10 dpv
2018-11-05 19:51:48 - let arrayOfArrays = [| [| 1; 2; 3 |]; [|4; 5; 6 |] |]
2018-11-05 19:51:48 - let array2d = Array2D.init 2 3 (fun row column -> arrayOfArrays.[row].[column])     
2018-11-05 19:51:48 - let newArray = Array2D.init (array2d |> Array2D.length2) (array2d |> Array2D.length1) (fun r c -> array2d.[c,r])
2018-11-05 19:53:30 - let sample  (numData:int)
2018-11-05 19:53:30 -             (dpv:DistributionParameterValues) : int[][] =   
2018-11-05 19:53:30 -     let a = Array.init numData (fun _ -> 
2018-11-05 19:53:30 -         let cloudy =  Discrete.Sample(dpv.cloudy)
2018-11-05 19:53:30 -         let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy])
2018-11-05 19:53:30 -         let rain = Discrete.Sample(dpv.rain.[cloudy])
2018-11-05 19:53:30 -         let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain])
2018-11-05 19:53:30 -         [|cloudy; sprinkler; rain; wetGrass|])
2018-11-05 19:53:30 -     a
2018-11-05 19:53:41 - sample 10 dpv
2018-11-05 20:04:19 - let sample  (numData:int)
2018-11-05 20:04:19 -             (dpv:DistributionParameterValues) : int[][] =   
2018-11-05 20:04:19 -     let a = Array2d.init numData 4 (fun _ j -> 
2018-11-05 20:04:19 -         let cloudy =  Discrete.Sample(dpv.cloudy)
2018-11-05 20:04:19 -         let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy])
2018-11-05 20:04:19 -         let rain = Discrete.Sample(dpv.rain.[cloudy])
2018-11-05 20:04:19 -         let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain])
2018-11-05 20:04:19 -         [|cloudy; sprinkler; rain; wetGrass|].[j])
2018-11-05 20:04:19 -     a
2018-11-05 20:04:20 - The value, namespace, type or module 'Array2d' is not defined. Maybe you want one of the following:
2018-11-05 20:04:20 -    Array2D
2018-11-05 20:04:20 -    array2D
2018-11-05 20:04:20 -    array2d
2018-11-05 20:04:20 -    Array
2018-11-05 20:04:20 -    Array3D
2018-11-05 20:04:42 - let sample  (numData:int)
2018-11-05 20:04:42 -             (dpv:DistributionParameterValues) : int[][] =   
2018-11-05 20:04:42 -     let a = Array2D.init numData 4 (fun _ j -> 
2018-11-05 20:04:42 -         let cloudy =  Discrete.Sample(dpv.cloudy)
2018-11-05 20:04:42 -         let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy])
2018-11-05 20:04:42 -         let rain = Discrete.Sample(dpv.rain.[cloudy])
2018-11-05 20:04:42 -         let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain])
2018-11-05 20:04:42 -         [|cloudy; sprinkler; rain; wetGrass|].[j])
2018-11-05 20:04:42 -     a
2018-11-05 20:04:42 - This expression was expected to have type
2018-11-05 20:04:42 -     'int [] []'    
2018-11-05 20:04:42 - but here has type
2018-11-05 20:04:42 -     'int [,]'    
2018-11-05 20:05:40 - let sample  (numData:int)
2018-11-05 20:05:40 -             (dpv:DistributionParameterValues) : int[,] =   
2018-11-05 20:05:40 -     let a = Array2D.init numData 4 (fun _ j -> 
2018-11-05 20:05:40 -         let cloudy =  Discrete.Sample(dpv.cloudy)
2018-11-05 20:05:40 -         let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy])
2018-11-05 20:05:40 -         let rain = Discrete.Sample(dpv.rain.[cloudy])
2018-11-05 20:05:40 -         let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain])
2018-11-05 20:05:40 -         [|cloudy; sprinkler; rain; wetGrass|].[j])
2018-11-05 20:05:40 -     a
2018-11-05 20:07:36 - sample 10 dpv
2018-11-05 20:11:51 - type Sample =
2018-11-05 20:11:51 -     {cloudy:int[] ;
2018-11-05 20:11:51 -     sprinkler:int[] ;
2018-11-05 20:11:51 -     rain:int[] ;
2018-11-05 20:11:51 -     wetGrass:int[] }
2018-11-05 20:12:06 - let sample  (numData:int)
2018-11-05 20:12:06 -             (dpv:DistributionParameterValues) : Sample =   
2018-11-05 20:12:06 -     let z = Array2D.init numData 4 (fun _ j -> 
2018-11-05 20:12:06 -         let cloudy =  Discrete.Sample(dpv.cloudy)
2018-11-05 20:12:06 -         let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy])
2018-11-05 20:12:06 -         let rain = Discrete.Sample(dpv.rain.[cloudy])
2018-11-05 20:12:06 -         let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain])
2018-11-05 20:12:06 -         [|cloudy; sprinkler; rain; wetGrass|].[j])
2018-11-05 20:12:06 -     {cloudy = z.[0], sprinkler = z.[1], rain=z.[2], wetGrass = z.[3]}
2018-11-05 20:12:06 - This expression was expected to have type
2018-11-05 20:12:06 -     'int []'    
2018-11-05 20:12:06 - but here has type
2018-11-05 20:12:06 -     ''a * 'b * 'c * 'd'    
2018-11-05 20:12:06 - A ';' is used to separate field values in records. Consider replacing ',' with ';'.
2018-11-05 20:12:06 - No assignment given for field 'sprinkler' of type 'FSI_0210.Sample'
2018-11-05 20:12:44 - let sample  (numData:int)
2018-11-05 20:12:44 -             (dpv:DistributionParameterValues) : Sample =   
2018-11-05 20:12:44 -     let z = Array2D.init numData 4 (fun _ j -> 
2018-11-05 20:12:44 -         let cloudy =  Discrete.Sample(dpv.cloudy)
2018-11-05 20:12:44 -         let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy])
2018-11-05 20:12:44 -         let rain = Discrete.Sample(dpv.rain.[cloudy])
2018-11-05 20:12:44 -         let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain])
2018-11-05 20:12:44 -         [|cloudy; sprinkler; rain; wetGrass|].[j])
2018-11-05 20:12:44 -     {cloudy = z.[0]; sprinkler = z.[1]; rain=z.[2]; wetGrass = z.[3]}
2018-11-05 20:12:45 - This expression was expected to have type
2018-11-05 20:12:45 -     ''a []'    
2018-11-05 20:12:45 - but here has type
2018-11-05 20:12:45 -     'int [,]'    
2018-11-05 20:12:45 - This expression was expected to have type
2018-11-05 20:12:45 -     ''a []'    
2018-11-05 20:12:45 - but here has type
2018-11-05 20:12:45 -     'int [,]'    
2018-11-05 20:12:45 - This expression was expected to have type
2018-11-05 20:12:45 -     ''a []'    
2018-11-05 20:12:45 - but here has type
2018-11-05 20:12:45 -     'int [,]'    
2018-11-05 20:12:45 - This expression was expected to have type
2018-11-05 20:12:45 -     ''a []'    
2018-11-05 20:12:45 - but here has type
2018-11-05 20:12:45 -     'int [,]'    
2018-11-05 20:13:19 - let sample  (numData:int)
2018-11-05 20:13:19 -             (dpv:DistributionParameterValues) : Sample =   
2018-11-05 20:13:19 -     let z = Array2D.init numData 4 (fun _ j -> 
2018-11-05 20:13:19 -         let cloudy =  Discrete.Sample(dpv.cloudy)
2018-11-05 20:13:19 -         let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy])
2018-11-05 20:13:19 -         let rain = Discrete.Sample(dpv.rain.[cloudy])
2018-11-05 20:13:19 -         let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain])
2018-11-05 20:13:19 -         [|cloudy; sprinkler; rain; wetGrass|].[j])
2018-11-05 20:13:19 -     {cloudy = z.[0,*]; sprinkler = z.[1,*]; rain=z.[2,*]; wetGrass = z.[3,*]}
2018-11-05 20:13:37 - sample 10 dpv
2018-11-05 20:14:56 - let sample  (numData:int)
2018-11-05 20:14:56 -             (dpv:DistributionParameterValues) : Sample =   
2018-11-05 20:14:56 -     let z = Array2D.init numData 4 (fun _ j -> 
2018-11-05 20:14:56 -         let cloudy =  Discrete.Sample(dpv.cloudy)
2018-11-05 20:14:56 -         let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy])
2018-11-05 20:14:56 -         let rain = Discrete.Sample(dpv.rain.[cloudy])
2018-11-05 20:14:56 -         let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain])
2018-11-05 20:14:56 -         [|cloudy; sprinkler; rain; wetGrass|].[j])
2018-11-05 20:14:56 -     {cloudy = z.[*,0]; sprinkler = z.[*,1]; rain=z.[*,2]; wetGrass = z.[*,3]}
2018-11-05 20:15:05 - sample 10 dpv
2018-11-05 20:17:27 - type ObservedValues =
2018-11-05 20:17:27 -     {cloudy:array<int>;
2018-11-05 20:17:27 -     sprinkler:array<int>;
2018-11-05 20:17:27 -     rain:array<int>;
2018-11-05 20:17:27 -     wetGrass:array<int> }
2018-11-05 20:17:27 - type Sample = ObservedValues
2018-11-05 20:33:33 - let uniformPriors:PosteriorDistributions = 
2018-11-05 20:33:33 -     let probCloudyPrior = Dirichlet.Uniform(2)
2018-11-05 20:33:33 -     let dirUnifArray = Enumerable.Repeat(Dirichlet.Uniform(2), 2).ToArray()
2018-11-05 20:33:33 -     let dirUnifArrayArray = Enumerable.Repeat(dirUnifArray, 2).ToArray()
2018-11-05 20:33:33 -     {cloudy=probCloudyPrior;sprinkler=dirUnifArray;rain=dirUnifArray; wetGrass=dirUnifArrayArray}
2018-11-05 20:33:34 - The value, namespace, type or module 'Enumerable' is not defined. Maybe you want one of the following:
2018-11-05 20:33:34 -    Enum
2018-11-05 20:33:34 -    enum
2018-11-05 20:33:34 - The value, namespace, type or module 'Enumerable' is not defined. Maybe you want one of the following:
2018-11-05 20:33:34 -    Enum
2018-11-05 20:33:34 -    enum
2018-11-05 20:34:20 - let uniformPriors:PosteriorDistributions = 
2018-11-05 20:34:20 -     let probCloudyPrior = Dirichlet.Uniform(2)
2018-11-05 20:34:20 -     let dirUnifArray = Enumerable.Repeat(Dirichlet.Uniform(2), 2).ToArray()
2018-11-05 20:34:20 -     let dirUnifArrayArray = Enumerable.Repeat(dirUnifArray, 2).ToArray()
2018-11-05 20:34:20 -     {cloudy=probCloudyPrior; sprinkler=dirUnifArray; rain=dirUnifArray; wetGrass=dirUnifArrayArray}
2018-11-05 20:34:20 - The value, namespace, type or module 'Enumerable' is not defined. Maybe you want one of the following:
2018-11-05 20:34:20 -    Enum
2018-11-05 20:34:20 -    enum
2018-11-05 20:34:20 - The value, namespace, type or module 'Enumerable' is not defined. Maybe you want one of the following:
2018-11-05 20:34:20 -    Enum
2018-11-05 20:34:20 -    enum
2018-11-05 20:38:01 - let uniformPriors:PosteriorDistributions = 
2018-11-05 20:38:01 -     let probCloudyPrior = Dirichlet.Uniform(2)
2018-11-05 20:38:01 -     let dirUnifArray = Array.init 2 (fun _ -> Dirichlet.Uniform(2)) //Enumerable.Repeat(Dirichlet.Uniform(2), 2).ToArray()
2018-11-05 20:38:01 -     let dirUnifArrayArray = Array.init 2 (fun _ -> dirUnifArray) //Enumerable.Repeat(dirUnifArray, 2).ToArray()
2018-11-05 20:38:01 -     {cloudy=probCloudyPrior; sprinkler=dirUnifArray; rain=dirUnifArray; wetGrass=dirUnifArrayArray}
2018-11-05 20:38:02 - uniformPriors
2018-11-05 20:54:17 - engine
2018-11-05 20:54:24 - numberOfExamples
2018-11-05 20:54:35 - rvs
2018-11-05 20:56:12 - priors
2018-11-05 20:57:09 - let sample100 = sample 100 dpv
2018-11-05 20:57:13 - learnParameters engine numberOfExamples rvs priors sample100 uniformPriors
2018-11-05 20:57:14 - This expression was expected to have type
2018-11-05 20:57:14 -     'FSI_0019.RandomVariables'    
2018-11-05 20:57:14 - but here has type
2018-11-05 20:57:14 -     'FSI_0149.RandomVariables'    
2018-11-05 20:57:14 - This expression was expected to have type
2018-11-05 20:57:14 -     'FSI_0023.PriorDistributions'    
2018-11-05 20:57:14 - but here has type
2018-11-05 20:57:14 -     'FSI_0153.PriorDistributions'    
2018-11-05 20:57:14 - This expression was expected to have type
2018-11-05 20:57:14 -     'ObservedValues'    
2018-11-05 20:57:14 - but here has type
2018-11-05 20:57:14 -     'Sample'    
2018-11-05 20:57:14 - This expression was expected to have type
2018-11-05 20:57:14 -     'FSI_0024.PosteriorDistributions'    
2018-11-05 20:57:14 - but here has type
2018-11-05 20:57:14 -     'FSI_0154.PosteriorDistributions'    
2018-11-05 20:58:49 - type PosteriorDistributions =
2018-11-05 20:58:49 -     {cloudy:Dirichlet ;
2018-11-05 20:58:49 -     sprinkler:Dirichlet[] ;
2018-11-05 20:58:49 -     rain:Dirichlet[] ;
2018-11-05 20:58:49 -     wetGrass:Dirichlet[][] }
2018-11-05 20:59:03 - let uniformPriors:PosteriorDistributions = 
2018-11-05 20:59:03 -     let probCloudyPrior = Dirichlet.Uniform(2)
2018-11-05 20:59:03 -     let dirUnifArray = Array.init 2 (fun _ -> Dirichlet.Uniform(2)) 
2018-11-05 20:59:03 -     let dirUnifArrayArray = Array.init 2 (fun _ -> dirUnifArray) 
2018-11-05 20:59:03 -     {cloudy=probCloudyPrior; sprinkler=dirUnifArray; rain=dirUnifArray; wetGrass=dirUnifArrayArray}
2018-11-05 20:59:09 - learnParameters engine numberOfExamples rvs priors sample100 uniformPriors
2018-11-05 20:59:09 - This expression was expected to have type
2018-11-05 20:59:09 -     'FSI_0019.RandomVariables'    
2018-11-05 20:59:09 - but here has type
2018-11-05 20:59:09 -     'FSI_0149.RandomVariables'    
2018-11-05 20:59:09 - This expression was expected to have type
2018-11-05 20:59:09 -     'FSI_0023.PriorDistributions'    
2018-11-05 20:59:09 - but here has type
2018-11-05 20:59:09 -     'FSI_0153.PriorDistributions'    
2018-11-05 20:59:09 - This expression was expected to have type
2018-11-05 20:59:09 -     'ObservedValues'    
2018-11-05 20:59:09 - but here has type
2018-11-05 20:59:09 -     'Sample'    
2018-11-05 20:59:09 - This expression was expected to have type
2018-11-05 20:59:09 -     'FSI_0024.PosteriorDistributions'    
2018-11-05 20:59:09 - but here has type
2018-11-05 20:59:09 -     'FSI_0235.PosteriorDistributions'    
2019-01-25 15:42:19 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-01-25 15:42:19 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-01-25 15:42:19 - For help type #help;;
2019-01-25 15:42:19 - > val it :
2019-01-25 15:42:19 -   ResizeArray<System.Type *
2019-01-25 15:42:19 -               (obj ->
2019-01-25 15:42:19 -                  seq<string *
2019-01-25 15:42:19 -                      string> *
2019-01-25 15:42:19 -                  string)>
2019-01-25 15:42:19 - = seq []
2019-01-25 15:42:19 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2019-01-25 15:42:19 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-01-25 15:42:19 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2019-01-25 15:42:20 - Reporting 0 opened comms
2019-01-25 15:42:20 - #load "Paket.fsx"
2019-01-25 15:42:28 - Paket.Package
2019-01-25 15:42:28 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2019-01-25 15:42:28 -       "Microsoft.ML.Probabilistic"
2019-01-25 15:42:28 -       "Microsoft.ML.Probabilistic.Compiler"
2019-01-25 15:42:28 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2019-01-25 15:42:28 -       "NETStandard.Library"
2019-01-25 15:42:28 -   ]
2019-01-25 15:43:13 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2019-01-25 15:43:16 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2019-01-25 15:43:27 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2019-01-25 15:43:27 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2019-01-25 15:43:27 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2019-01-25 15:43:27 - #r "Microsoft.ML.Probabilistic"
2019-01-25 15:43:27 - #r "Microsoft.ML.Probabilistic.Compiler"
2019-01-25 15:43:27 - #r "netstandard"
2019-01-25 15:43:27 - open System
2019-01-25 15:43:28 - open Microsoft.ML.Probabilistic  
2019-01-25 15:43:28 - open Microsoft.ML.Probabilistic.Models  
2019-01-25 15:43:28 - open Microsoft.ML.Probabilistic.Distributions  
2019-01-25 15:43:28 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2019-01-25 15:43:28 - open Microsoft.ML.Probabilistic.Math
2019-01-25 15:43:28 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2019-01-25 15:43:29 - open Microsoft.ML.Probabilistic.FSharp
2019-01-25 15:43:29 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2019-01-25 15:43:29 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2019-01-25 15:43:29 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2019-01-25 15:43:29 - let AddChildFromOneParent 
2019-01-25 15:43:29 -         (parent:RandomVariable) 
2019-01-25 15:43:29 -         (cpt:ConditionalProbabilityTable) =
2019-01-25 15:43:29 -     let r = parent.Range
2019-01-25 15:43:29 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2019-01-25 15:43:29 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2019-01-25 15:43:29 -                        Variable.Discrete(cpt.[pi])))
2019-01-25 15:43:29 -     child
2019-01-25 15:43:29 - type ConditionalProbabilityTable2D = 
2019-01-25 15:43:29 -     VariableArray<VariableArray<Vector>, Vector[][]>
2019-01-25 15:43:29 - let AddChildFromTwoParents 
2019-01-25 15:43:29 -         (parent1:RandomVariable) 
2019-01-25 15:43:29 -         (parent2:RandomVariable) 
2019-01-25 15:43:29 -         (cpt:ConditionalProbabilityTable2D) = 
2019-01-25 15:43:29 -     let r = parent1.Range
2019-01-25 15:43:29 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2019-01-25 15:43:29 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2019-01-25 15:43:29 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2019-01-25 15:43:29 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2019-01-25 15:43:29 -     child       
2019-01-25 15:43:30 - type RandomVariables =
2019-01-25 15:43:30 -     {cloudy:VariableArray<int>;
2019-01-25 15:43:30 -     sprinkler:VariableArray<int>;
2019-01-25 15:43:30 -     rain:VariableArray<int>;
2019-01-25 15:43:30 -     wetGrass:VariableArray<int> }
2019-01-25 15:43:30 - type ObservedValues =
2019-01-25 15:43:30 -     {cloudy:array<int>;
2019-01-25 15:43:30 -     sprinkler:array<int>;
2019-01-25 15:43:30 -     rain:array<int>;
2019-01-25 15:43:30 -     wetGrass:array<int> }
2019-01-25 15:43:30 - type Sample = ObservedValues
2019-01-25 15:43:30 - type DistributionParameters =
2019-01-25 15:43:30 -     {cloudy:Variable<Vector> ;
2019-01-25 15:43:30 -     sprinkler:VariableArray<Vector> ;
2019-01-25 15:43:30 -     rain:VariableArray<Vector> ;
2019-01-25 15:43:30 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2019-01-25 15:43:30 - type DistributionParameterValues =  
2019-01-25 15:43:30 -     {cloudy:Vector;     // probCloudy     2-vector
2019-01-25 15:43:30 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2019-01-25 15:43:30 -     rain:Vector[];      // cptRain        2-vector * 2
2019-01-25 15:43:30 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2019-01-25 15:43:30 -     }
2019-01-25 15:43:30 - type PriorDistributions =
2019-01-25 15:43:30 -     {cloudy:Variable<Dirichlet> ;
2019-01-25 15:43:30 -     sprinkler:VariableArray<Dirichlet> ;
2019-01-25 15:43:30 -     rain:VariableArray<Dirichlet> ;
2019-01-25 15:43:30 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2019-01-25 15:43:30 - type PosteriorDistributions =
2019-01-25 15:43:30 -     {cloudy:Dirichlet ;
2019-01-25 15:43:30 -     sprinkler:Dirichlet[] ;
2019-01-25 15:43:30 -     rain:Dirichlet[] ;
2019-01-25 15:43:30 -     wetGrass:Dirichlet[][] }
2019-01-25 15:43:31 - let engine =  InferenceEngine ()
2019-01-25 15:43:31 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2019-01-25 15:43:31 - let rN:Range = Range(numberOfExamples).Named("N")
2019-01-25 15:43:31 - let rC = Range(2).Named("C") // Cloudy
2019-01-25 15:43:31 - let rS = Range(2).Named("S") // Sprinkler
2019-01-25 15:43:31 - let rR = Range(2).Named("R") // Rain
2019-01-25 15:43:31 - let rW = Range(2).Named("W") // Wet
2019-01-25 15:43:31 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2019-01-25 15:43:31 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2019-01-25 15:43:31 - probCloudy.SetValueRange(rC)
2019-01-25 15:43:32 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2019-01-25 15:43:32 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2019-01-25 15:43:32 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2019-01-25 15:43:32 - cptSprinkler.SetValueRange(rS)
2019-01-25 15:43:32 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2019-01-25 15:43:32 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2019-01-25 15:43:32 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2019-01-25 15:43:32 - cptRain.SetValueRange(rR)
2019-01-25 15:43:32 - let cptWetGrassPrior= 
2019-01-25 15:43:32 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2019-01-25 15:43:32 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2019-01-25 15:43:32 - let cptWetGrass = 
2019-01-25 15:43:32 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2019-01-25 15:43:32 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2019-01-25 15:43:32 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2019-01-25 15:43:32 - cptWetGrass.SetValueRange(rW)
2019-01-25 15:43:33 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2019-01-25 15:43:33 - The type 'Ranges' is not defined. Maybe you want one of the following:
2019-01-25 15:43:33 -    Range
2019-01-25 15:43:33 - The record label 'c' is not defined.
2019-01-25 15:43:33 - let buildPriors (rg:Ranges) : PriorDistributions =
2019-01-25 15:43:33 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2019-01-25 15:43:33 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2019-01-25 15:43:33 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2019-01-25 15:43:33 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2019-01-25 15:43:33 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2019-01-25 15:43:33 - The type 'Ranges' is not defined. Maybe you want one of the following:
2019-01-25 15:43:33 -    Range
2019-01-25 15:43:33 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-01-25 15:43:33 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2019-01-25 15:43:33 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-01-25 15:43:33 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2019-01-25 15:43:33 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-01-25 15:43:33 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2019-01-25 15:43:33 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-01-25 15:43:33 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(array: VariableArray<'TItem,'TArray>, r: Range) : VariableArray<VariableArray<'TItem,'TArray>,'TArray []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(itemPrototype: 'TItem, r: Range) : VariableArray<'TItem,'TArray>
2019-01-25 15:43:33 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2019-01-25 15:43:33 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2019-01-25 15:43:33 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2019-01-25 15:43:33 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2019-01-25 15:43:33 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2019-01-25 15:43:33 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2019-01-25 15:43:33 -     probCloudy.SetValueRange(rg.c)
2019-01-25 15:43:33 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2019-01-25 15:43:33 -     cptSprinkler.SetValueRange(rg.s)
2019-01-25 15:43:33 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2019-01-25 15:43:33 -     cptRain.SetValueRange(rg.r)
2019-01-25 15:43:33 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2019-01-25 15:43:33 -     cptWetGrass.SetValueRange(rg.w)
2019-01-25 15:43:33 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2019-01-25 15:43:33 - The type 'Ranges' is not defined. Maybe you want one of the following:
2019-01-25 15:43:33 -    Range
2019-01-25 15:43:33 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-01-25 15:43:33 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2019-01-25 15:43:33 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-01-25 15:43:33 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2019-01-25 15:43:33 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-01-25 15:43:33 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'T>(r: Range) : VariableArray<'T>, Variable.Array<'T>(ranges: Collections.Generic.IList<Range>) : IVariableArray
2019-01-25 15:43:33 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-01-25 15:43:33 - A unique overload for method 'Array' could not be determined based on type information prior to this program point. A type annotation may be needed. Candidates: Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(array: VariableArray<'TItem,'TArray>, r: Range) : VariableArray<VariableArray<'TItem,'TArray>,'TArray []>, Variable.Array<'TItem,'TArray when 'TItem :> Variable and 'TItem :> SettableTo<'TItem> and 'TItem :> ICloneable>(itemPrototype: 'TItem, r: Range) : VariableArray<'TItem,'TArray>
2019-01-25 15:43:33 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-01-25 15:43:33 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2019-01-25 15:43:33 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-01-25 15:43:33 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2019-01-25 15:43:33 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-01-25 15:43:33 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2019-01-25 15:43:33 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2019-01-25 15:43:33 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-01-25 15:43:34 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2019-01-25 15:43:34 - let rN:Range = Range(numberOfExamples).Named("N")
2019-01-25 15:43:34 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2019-01-25 15:43:34 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2019-01-25 15:43:34 - let setDistributionParameterValues (): DistributionParameterValues =
2019-01-25 15:43:34 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2019-01-25 15:43:34 -     let cptSprinkler:Vector[] = 
2019-01-25 15:43:34 -         [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] 
2019-01-25 15:43:34 -         |> Array.map (fun a -> Vector.FromArray a)
2019-01-25 15:43:34 -     let cptRain:Vector[] =      
2019-01-25 15:43:34 -         [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] 
2019-01-25 15:43:34 -         |> Array.map (fun a -> Vector.FromArray a)
2019-01-25 15:43:34 -     let cptWetGrass:Vector[][] = 
2019-01-25 15:43:34 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2019-01-25 15:43:34 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2019-01-25 15:43:34 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2019-01-25 15:43:34 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2019-01-25 15:43:34 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2019-01-25 15:43:34 -     {cloudy=probCloudy; sprinkler=cptSprinkler; rain=cptRain; wetGrass=cptWetGrass}
2019-01-25 15:43:34 - let sample  (numData:int)
2019-01-25 15:43:34 -             (dpv:DistributionParameterValues) : Sample =   
2019-01-25 15:43:34 -     let z = Array2D.init numData 4 (fun _ j -> 
2019-01-25 15:43:34 -         let cloudy =  Discrete.Sample(dpv.cloudy)
2019-01-25 15:43:34 -         let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy])
2019-01-25 15:43:34 -         let rain = Discrete.Sample(dpv.rain.[cloudy])
2019-01-25 15:43:34 -         let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain])
2019-01-25 15:43:34 -         [|cloudy; sprinkler; rain; wetGrass|].[j])
2019-01-25 15:43:34 -     {cloudy = z.[*,0]; sprinkler = z.[*,1]; rain=z.[*,2]; wetGrass = z.[*,3]}
2019-01-25 17:00:57 - #load "Paket.fsx"
2019-01-25 17:01:08 - Paket.Package
2019-01-25 17:01:08 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2019-01-25 17:01:08 -       "Microsoft.ML.Probabilistic"
2019-01-25 17:01:08 -       "Microsoft.ML.Probabilistic.Compiler"
2019-01-25 17:01:08 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2019-01-25 17:01:08 -       "NETStandard.Library"
2019-01-25 17:01:08 -   ]
2019-01-25 17:01:24 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2019-01-25 17:01:25 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2019-01-25 17:01:32 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2019-01-25 17:01:32 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2019-01-25 17:01:32 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2019-01-25 17:01:32 - #r "Microsoft.ML.Probabilistic"
2019-01-25 17:01:32 - #r "Microsoft.ML.Probabilistic.Compiler"
2019-01-25 17:01:32 - #r "netstandard"
2019-01-25 17:01:33 - open System
2019-01-25 17:01:34 - open Microsoft.ML.Probabilistic  
2019-01-25 17:01:34 - open Microsoft.ML.Probabilistic.Models  
2019-01-25 17:01:34 - open Microsoft.ML.Probabilistic.Distributions  
2019-01-25 17:01:34 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2019-01-25 17:01:34 - open Microsoft.ML.Probabilistic.Math
2019-01-25 17:01:35 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2019-01-25 17:01:35 - open Microsoft.ML.Probabilistic.FSharp
2019-01-25 17:01:44 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2019-01-25 17:01:44 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2019-01-25 17:01:45 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2019-01-25 17:01:46 - let AddChildFromOneParent 
2019-01-25 17:01:46 -         (parent:RandomVariable) 
2019-01-25 17:01:46 -         (cpt:ConditionalProbabilityTable) =
2019-01-25 17:01:46 -     let r = parent.Range
2019-01-25 17:01:46 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2019-01-25 17:01:46 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2019-01-25 17:01:46 -                        Variable.Discrete(cpt.[pi])))
2019-01-25 17:01:46 -     child
2019-01-25 17:01:52 - type ConditionalProbabilityTable2D = 
2019-01-25 17:01:52 -     VariableArray<VariableArray<Vector>, Vector[][]>
2019-01-25 17:01:53 - let AddChildFromTwoParents 
2019-01-25 17:01:53 -         (parent1:RandomVariable) 
2019-01-25 17:01:53 -         (parent2:RandomVariable) 
2019-01-25 17:01:53 -         (cpt:ConditionalProbabilityTable2D) = 
2019-01-25 17:01:53 -     let r = parent1.Range
2019-01-25 17:01:53 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2019-01-25 17:01:53 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2019-01-25 17:01:53 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2019-01-25 17:01:53 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2019-01-25 17:01:53 -     child       
2019-01-25 17:01:58 - type RandomVariables =
2019-01-25 17:01:58 -     {cloudy:VariableArray<int>;
2019-01-25 17:01:58 -     sprinkler:VariableArray<int>;
2019-01-25 17:01:58 -     rain:VariableArray<int>;
2019-01-25 17:01:58 -     wetGrass:VariableArray<int> }
2019-01-25 17:02:05 - type ObservedValues =
2019-01-25 17:02:05 -     {cloudy:array<int>;
2019-01-25 17:02:05 -     sprinkler:array<int>;
2019-01-25 17:02:05 -     rain:array<int>;
2019-01-25 17:02:05 -     wetGrass:array<int> }
2019-01-25 17:02:05 - type Sample = ObservedValues
2019-01-25 17:02:07 - type DistributionParameters =
2019-01-25 17:02:07 -     {cloudy:Variable<Vector> ;
2019-01-25 17:02:07 -     sprinkler:VariableArray<Vector> ;
2019-01-25 17:02:07 -     rain:VariableArray<Vector> ;
2019-01-25 17:02:07 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2019-01-25 17:02:09 - type DistributionParameterValues =  
2019-01-25 17:02:09 -     {cloudy:Vector;     // probCloudy     2-vector
2019-01-25 17:02:09 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2019-01-25 17:02:09 -     rain:Vector[];      // cptRain        2-vector * 2
2019-01-25 17:02:09 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2019-01-25 17:02:09 -     }
2019-01-25 17:02:12 - type PriorDistributions =
2019-01-25 17:02:12 -     {cloudy:Variable<Dirichlet> ;
2019-01-25 17:02:12 -     sprinkler:VariableArray<Dirichlet> ;
2019-01-25 17:02:12 -     rain:VariableArray<Dirichlet> ;
2019-01-25 17:02:12 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2019-01-25 17:02:17 - type PosteriorDistributions =
2019-01-25 17:02:17 -     {cloudy:Dirichlet ;
2019-01-25 17:02:17 -     sprinkler:Dirichlet[] ;
2019-01-25 17:02:17 -     rain:Dirichlet[] ;
2019-01-25 17:02:17 -     wetGrass:Dirichlet[][] }
2019-01-25 17:02:20 - type Ranges = {c:Range;s:Range;r:Range;w:Range}
2019-01-25 17:02:25 - let engine =  InferenceEngine ()
2019-01-25 17:02:27 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2019-01-25 17:02:27 - let rN:Range = Range(numberOfExamples).Named("N")
2019-01-25 17:02:29 - let rC = Range(2).Named("C") // Cloudy
2019-01-25 17:02:29 - let rS = Range(2).Named("S") // Sprinkler
2019-01-25 17:02:29 - let rR = Range(2).Named("R") // Rain
2019-01-25 17:02:29 - let rW = Range(2).Named("W") // Wet
2019-01-25 17:02:34 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2019-01-25 17:02:34 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2019-01-25 17:02:34 - probCloudy.SetValueRange(rC)
2019-01-25 17:02:37 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2019-01-25 17:02:37 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2019-01-25 17:02:40 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2019-01-25 17:02:40 - cptSprinkler.SetValueRange(rS)
2019-01-25 17:02:42 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2019-01-25 17:02:42 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2019-01-25 17:02:42 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2019-01-25 17:02:42 - cptRain.SetValueRange(rR)
2019-01-25 17:02:46 - let cptWetGrassPrior= 
2019-01-25 17:02:46 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2019-01-25 17:02:46 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2019-01-25 17:02:46 - let cptWetGrass = 
2019-01-25 17:02:46 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2019-01-25 17:02:46 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2019-01-25 17:02:47 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2019-01-25 17:02:47 - cptWetGrass.SetValueRange(rW)
2019-01-25 17:02:54 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2019-01-25 17:02:56 - let priors:PriorDistributions = {
2019-01-25 17:02:56 -     cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2019-01-25 17:02:56 -     sprinkler= Variable.Array<Dirichlet>(ranges.c).Named("cptSprinklerPrior") ;
2019-01-25 17:02:56 -     rain= Variable.Array<Dirichlet>(ranges.c).Named("cptRainPrior");
2019-01-25 17:02:56 -     wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2019-01-25 17:02:56 -                     Variable.Array<Dirichlet>(ranges.r), ranges.s).Named("cptWetGrassPrior")}
2019-01-25 17:02:57 - let parameters:DistributionParameters = {
2019-01-25 17:02:57 -     cloudy= Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy");
2019-01-25 17:02:57 -     sprinkler= Variable.Array<Vector>(ranges.c).Named("cptSprinkler") ;
2019-01-25 17:02:57 -     rain= Variable.Array<Vector>(ranges.c).Named("cptRain");
2019-01-25 17:02:57 -     wetGrass= Variable.Array<VariableArray<Vector>, Vector[][]>(
2019-01-25 17:02:57 -                 Variable.Array<Vector>(ranges.r), ranges.s).Named("cptWetGrass")}
2019-01-25 17:03:02 - parameters.cloudy.SetValueRange(ranges.c)
2019-01-25 17:03:02 - parameters.sprinkler.[ranges.c] <- Variable<Vector>.Random<Dirichlet>(priors.sprinkler.[ranges.c])
2019-01-25 17:03:02 - parameters.sprinkler.SetValueRange(ranges.s)
2019-01-25 17:03:02 - parameters.rain.[ranges.c] <- Variable<Vector>.Random<Dirichlet>(priors.rain.[ranges.c])
2019-01-25 17:03:02 - parameters.rain.SetValueRange(ranges.r)
2019-01-25 17:03:02 - parameters.wetGrass.[ranges.s].[ranges.r] <- Variable<Vector>.Random<Dirichlet>(priors.wetGrass.[ranges.s].[ranges.r])
2019-01-25 17:03:02 - parameters.wetGrass.SetValueRange(ranges.w)
2019-01-25 17:03:09 - let buildPriors (rg:Ranges) : PriorDistributions =
2019-01-25 17:03:09 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2019-01-25 17:03:09 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2019-01-25 17:03:09 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2019-01-25 17:03:09 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2019-01-25 17:03:09 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2019-01-25 17:03:11 - let priors = buildPriors ranges
2019-01-25 17:03:16 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2019-01-25 17:03:16 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2019-01-25 17:03:16 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2019-01-25 17:03:16 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2019-01-25 17:03:16 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2019-01-25 17:03:16 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2019-01-25 17:03:16 -     probCloudy.SetValueRange(rg.c)
2019-01-25 17:03:16 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2019-01-25 17:03:16 -     cptSprinkler.SetValueRange(rg.s)
2019-01-25 17:03:16 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2019-01-25 17:03:16 -     cptRain.SetValueRange(rg.r)
2019-01-25 17:03:16 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2019-01-25 17:03:16 -     cptWetGrass.SetValueRange(rg.w)
2019-01-25 17:03:16 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2019-01-25 17:03:20 - let parameters = buildDistributionParameters ranges priors
2019-01-25 17:03:25 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2019-01-25 17:03:25 - let rN:Range = Range(numberOfExamples).Named("N")
2019-01-25 17:03:26 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2019-01-25 17:03:26 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2019-01-25 17:03:28 - let sprinkler:VariableArray<int> = (AddChildFromOneParent cloudy cptSprinkler).Named("sprinkler")
2019-01-25 17:03:28 - let rain:VariableArray<int> = (AddChildFromOneParent cloudy cptRain).Named("rain")
2019-01-25 17:03:28 - let wetGrass:VariableArray<int> = (AddChildFromTwoParents sprinkler rain cptWetGrass).Named("wetGrass")
2019-01-25 17:03:31 - let rvs:RandomVariables =
2019-01-25 17:03:31 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2019-01-25 17:03:31 -     vC.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2019-01-25 17:03:31 -     let vS = (AddChildFromOneParent vC cptSprinkler).Named("sprinkler")
2019-01-25 17:03:31 -     let vR = (AddChildFromOneParent vC cptRain).Named("rain")
2019-01-25 17:03:31 -     let vW = (AddChildFromTwoParents vS vR cptWetGrass).Named("wetGrass")
2019-01-25 17:03:31 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2019-01-25 17:03:35 - let buildRandomVariables (rN:Range) (dp:DistributionParameters) :RandomVariables =
2019-01-25 17:03:35 -     let vC = Variable.Array<int>(rN).Named("cloudy")
2019-01-25 17:03:35 -     vC.[rN] <- Variable.Discrete(dp.cloudy).ForEach(rN)
2019-01-25 17:03:35 -     let vS = (AddChildFromOneParent vC dp.sprinkler).Named("sprinkler")
2019-01-25 17:03:35 -     let vR = (AddChildFromOneParent vC dp.rain).Named("rain")
2019-01-25 17:03:35 -     let vW = (AddChildFromTwoParents vS vR dp.wetGrass).Named("wetGrass")
2019-01-25 17:03:35 -     {cloudy = vC; sprinkler =vS; rain = vR; wetGrass = vW}
2019-01-25 17:03:38 - let numberOfExamples = Variable.New<int>().Named("NofE")
2019-01-25 17:03:38 - let rN = Range(numberOfExamples).Named("N")
2019-01-25 17:03:38 - let ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("W")}
2019-01-25 17:03:38 - let priors = buildPriors ranges
2019-01-25 17:03:38 - let parameters = buildDistributionParameters ranges priors
2019-01-25 17:03:40 - let rvs = buildRandomVariables rN parameters
2019-01-25 19:23:04 - #load "Paket.fsx"
2019-01-25 19:23:06 - Paket.Package
2019-01-25 19:23:06 -   [   // "Infer.NET" (pre Oct 2018 namespace)
2019-01-25 19:23:06 -       "Microsoft.ML.Probabilistic"
2019-01-25 19:23:06 -       "Microsoft.ML.Probabilistic.Compiler"
2019-01-25 19:23:06 -       //"Microsoft.ML.Probabilistic.FSharp"  // Not on nuget, yet?
2019-01-25 19:23:06 -       "NETStandard.Library"
2019-01-25 19:23:06 -   ]
2019-01-25 19:23:29 - #load "Paket.Generated.Refs.fsx"  // Do we need this?
2019-01-25 19:23:31 - Paket.GitHub ["dotnet/infer src/FSharpWrapper/FSharpWrapper.fs"]
2019-01-25 19:23:42 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic/lib/netstandard2.0"
2019-01-25 19:23:42 - #I "/home/nbuser/IfSharp/bin/packages/Microsoft.ML.Probabilistic.Compiler/lib/netstandard2.0"
2019-01-25 19:23:42 - #I "/home/nbuser/IfSharp/bin/packages/NETStandard.Library/build/netstandard2.0/ref"
2019-01-25 19:23:42 - #r "Microsoft.ML.Probabilistic"
2019-01-25 19:23:42 - #r "Microsoft.ML.Probabilistic.Compiler"
2019-01-25 19:23:42 - #r "netstandard"
2019-01-25 19:23:42 - open System
2019-01-25 19:23:42 - open Microsoft.ML.Probabilistic  
2019-01-25 19:23:42 - open Microsoft.ML.Probabilistic.Models  
2019-01-25 19:23:42 - open Microsoft.ML.Probabilistic.Distributions  
2019-01-25 19:23:42 - open Microsoft.ML.Probabilistic.Factors  // From concept of "factor graph" - Applying functions and operators to variables
2019-01-25 19:23:42 - open Microsoft.ML.Probabilistic.Math
2019-01-25 19:23:42 - #load "/home/nbuser/IfSharp/bin/paket-files/github/dotnet/infer/src/FSharpWrapper/FSharpWrapper.fs"
2019-01-25 19:23:43 - open Microsoft.ML.Probabilistic.FSharp
2019-01-25 19:23:44 - type RandomVariable = VariableArray<int> // Random variables, e.g. for C (N),S (N*2),R (N*2),W (N*2*2)
2019-01-25 19:23:44 - type RandomVariableCase = Variable<int> // Could be for single experiment and/or outcome of driving variable
2019-01-25 19:23:44 - type ConditionalProbabilityTable = VariableArray<Vector> // Distribution params for S,R
2019-01-25 19:23:44 - let AddChildFromOneParent 
2019-01-25 19:23:44 -         (parent:RandomVariable) 
2019-01-25 19:23:44 -         (cpt:ConditionalProbabilityTable) =
2019-01-25 19:23:44 -     let r = parent.Range
2019-01-25 19:23:44 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2019-01-25 19:23:44 -                    Variable.SwitchExpr (parent.[i]) (fun (pi:RandomVariableCase) ->  
2019-01-25 19:23:44 -                        Variable.Discrete(cpt.[pi])))
2019-01-25 19:23:44 -     child
2019-01-25 19:23:44 - type ConditionalProbabilityTable2D = 
2019-01-25 19:23:44 -     VariableArray<VariableArray<Vector>, Vector[][]>
2019-01-25 19:23:44 - let AddChildFromTwoParents 
2019-01-25 19:23:44 -         (parent1:RandomVariable) 
2019-01-25 19:23:44 -         (parent2:RandomVariable) 
2019-01-25 19:23:44 -         (cpt:ConditionalProbabilityTable2D) = 
2019-01-25 19:23:44 -     let r = parent1.Range
2019-01-25 19:23:44 -     let (child:RandomVariable) = Variable.ArrayInit r (fun (i:Range)->  
2019-01-25 19:23:44 -                Variable.SwitchExpr (parent1.[i]) (fun (pi1:RandomVariableCase) ->  
2019-01-25 19:23:44 -                    Variable.SwitchExpr (parent2.[i]) (fun (pi2:RandomVariableCase) ->  
2019-01-25 19:23:44 -                        Variable.Discrete(cpt.[pi1].[pi2]))))
2019-01-25 19:23:44 -     child       
2019-01-25 19:23:44 - type RandomVariables =
2019-01-25 19:23:44 -     {cloudy:VariableArray<int>;
2019-01-25 19:23:44 -     sprinkler:VariableArray<int>;
2019-01-25 19:23:44 -     rain:VariableArray<int>;
2019-01-25 19:23:44 -     wetGrass:VariableArray<int> }
2019-01-25 19:23:44 - type ObservedValues =
2019-01-25 19:23:44 -     {cloudy:array<int>;
2019-01-25 19:23:44 -     sprinkler:array<int>;
2019-01-25 19:23:44 -     rain:array<int>;
2019-01-25 19:23:44 -     wetGrass:array<int> }
2019-01-25 19:23:44 - type Sample = ObservedValues
2019-01-25 19:23:44 - type DistributionParameters =
2019-01-25 19:23:44 -     {cloudy:Variable<Vector> ;
2019-01-25 19:23:44 -     sprinkler:VariableArray<Vector> ;
2019-01-25 19:23:44 -     rain:VariableArray<Vector> ;
2019-01-25 19:23:44 -     wetGrass:VariableArray<VariableArray<Vector>, Vector[][]> }
2019-01-25 19:23:45 - type DistributionParameterValues =  
2019-01-25 19:23:45 -     {cloudy:Vector;     // probCloudy     2-vector
2019-01-25 19:23:45 -     sprinkler:Vector[]; // cptSprinkler   2-vector * 2
2019-01-25 19:23:45 -     rain:Vector[];      // cptRain        2-vector * 2
2019-01-25 19:23:45 -     wetGrass:Vector[][] // cptWetGrass    2-vector * 2 * 2
2019-01-25 19:23:45 -     }
2019-01-25 19:23:45 - type PriorDistributions =
2019-01-25 19:23:45 -     {cloudy:Variable<Dirichlet> ;
2019-01-25 19:23:45 -     sprinkler:VariableArray<Dirichlet> ;
2019-01-25 19:23:45 -     rain:VariableArray<Dirichlet> ;
2019-01-25 19:23:45 -     wetGrass:VariableArray<VariableArray<Dirichlet>, Dirichlet[][]> }
2019-01-25 19:23:45 - type PosteriorDistributions =
2019-01-25 19:23:45 -     {cloudy:Dirichlet ;
2019-01-25 19:23:45 -     sprinkler:Dirichlet[] ;
2019-01-25 19:23:45 -     rain:Dirichlet[] ;
2019-01-25 19:23:45 -     wetGrass:Dirichlet[][] }
2019-01-25 19:23:45 - let engine =  InferenceEngine ()
2019-01-25 19:23:45 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2019-01-25 19:23:45 - let rN:Range = Range(numberOfExamples).Named("N")
2019-01-25 19:23:46 - let rC = Range(2).Named("C") // Cloudy
2019-01-25 19:23:46 - let rS = Range(2).Named("S") // Sprinkler
2019-01-25 19:23:46 - let rR = Range(2).Named("R") // Rain
2019-01-25 19:23:46 - let rW = Range(2).Named("W") // Wet
2019-01-25 19:23:46 - let probCloudyPrior:Variable<Dirichlet> = Variable.New<Dirichlet>().Named("probCloudyPrior")
2019-01-25 19:23:46 - let probCloudy:Variable<Vector> = Variable<Vector>.Random<Dirichlet>(probCloudyPrior).Named("probCloudy")
2019-01-25 19:23:46 - probCloudy.SetValueRange(rC)
2019-01-25 19:23:46 - let cptSprinklerPrior = Variable.Array<Dirichlet>(rC).Named("cptSprinklerPrior")
2019-01-25 19:23:46 - let cptSprinkler = Variable.Array<Vector>(rC).Named("cptSprinkler")
2019-01-25 19:23:46 - cptSprinkler.[rC] <- Variable<Vector>.Random<Dirichlet>(cptSprinklerPrior.[rC])
2019-01-25 19:23:46 - cptSprinkler.SetValueRange(rS)
2019-01-25 19:23:46 - let cptRainPrior = Variable.Array<Dirichlet>(rC).Named("cptRainPrior")
2019-01-25 19:23:46 - let cptRain = Variable.Array<Vector>(rC).Named("cptRain")
2019-01-25 19:23:46 - cptRain.[rC] <- Variable<Vector>.Random<Dirichlet>(cptRainPrior.[rC])
2019-01-25 19:23:46 - cptRain.SetValueRange(rR)
2019-01-25 19:23:47 - let cptWetGrassPrior= 
2019-01-25 19:23:47 -     Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2019-01-25 19:23:47 -         Variable.Array<Dirichlet>(rR), rS).Named("cptWetGrassPrior")
2019-01-25 19:23:47 - let cptWetGrass = 
2019-01-25 19:23:47 -     Variable.Array<VariableArray<Vector>, Vector[][]>(
2019-01-25 19:23:47 -         Variable.Array<Vector>(rR), rS).Named("cptWetGrass")
2019-01-25 19:23:47 - cptWetGrass.[rS].[rR] <- Variable<Vector>.Random<Dirichlet>(cptWetGrassPrior.[rS].[rR])
2019-01-25 19:23:47 - cptWetGrass.SetValueRange(rW)
2019-01-25 19:23:47 - let ranges:Ranges = {c=Range(2).Named("C"); s=Range(2).Named("S"); r=Range(2).Named("R"); w=Range(2).Named("R")}
2019-01-25 19:23:47 - let buildPriors (rg:Ranges) : PriorDistributions =
2019-01-25 19:23:47 -     {cloudy= Variable.New<Dirichlet>().Named("probCloudyPrior");
2019-01-25 19:23:47 -         sprinkler= Variable.Array<Dirichlet>(rg.c).Named("cptSprinklerPrior") ;
2019-01-25 19:23:47 -         rain= Variable.Array<Dirichlet>(rg.c).Named("cptRainPrior");
2019-01-25 19:23:47 -         wetGrass= Variable.Array<VariableArray<Dirichlet>, Dirichlet[][]>(
2019-01-25 19:23:47 -                                 Variable.Array<Dirichlet>(rg.r), rg.s).Named("cptWetGrassPrior")}
2019-01-25 19:23:47 - let buildDistributionParameters (rg:Ranges) (pd:PriorDistributions) : DistributionParameters =
2019-01-25 19:23:47 -     let probCloudy = Variable<Vector>.Random<Dirichlet>(pd.cloudy).Named("probCloudy")
2019-01-25 19:23:47 -     let cptSprinkler = Variable.Array<Vector>(rg.c).Named("cptSprinkler") 
2019-01-25 19:23:47 -     let cptRain = Variable.Array<Vector>(rg.c).Named("cptRain")
2019-01-25 19:23:47 -     let cptWetGrass = Variable.Array<VariableArray<Vector>, Vector[][]>(
2019-01-25 19:23:47 -                             Variable.Array<Vector>(rg.r), rg.s).Named("cptWetGrass")
2019-01-25 19:23:47 -     probCloudy.SetValueRange(rg.c)
2019-01-25 19:23:47 -     cptSprinkler.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.sprinkler.[rg.c])
2019-01-25 19:23:47 -     cptSprinkler.SetValueRange(rg.s)
2019-01-25 19:23:47 -     cptRain.[rg.c] <- Variable<Vector>.Random<Dirichlet>(pd.rain.[rg.c])
2019-01-25 19:23:47 -     cptRain.SetValueRange(rg.r)
2019-01-25 19:23:47 -     cptWetGrass.[rg.s].[rg.r] <- Variable<Vector>.Random<Dirichlet>(pd.wetGrass.[rg.s].[rg.r])
2019-01-25 19:23:47 -     cptWetGrass.SetValueRange(rg.w)
2019-01-25 19:23:47 -     {cloudy = probCloudy; sprinkler = cptSprinkler; rain = cptRain; wetGrass = cptWetGrass}        
2019-01-25 19:23:48 - let numberOfExamples:Variable<int> = Variable.New<int>().Named("NofE")
2019-01-25 19:23:48 - let rN:Range = Range(numberOfExamples).Named("N")
2019-01-25 19:23:48 - let cloudy = Variable.Array<int>(rN).Named("cloudy")
2019-01-25 19:23:48 - cloudy.[rN] <- Variable.Discrete(probCloudy).ForEach(rN)
2019-01-25 19:23:48 - let setDistributionParameterValues (): DistributionParameterValues =
2019-01-25 19:23:48 -     let probCloudy:Vector = Vector.FromArray(0.5, 0.5)
2019-01-25 19:23:48 -     let cptSprinkler:Vector[] = 
2019-01-25 19:23:48 -         [| [|0.1; 0.9|] (* cloudy *); [|0.5; 0.5|] (* not cloudy *) |] 
2019-01-25 19:23:48 -         |> Array.map (fun a -> Vector.FromArray a)
2019-01-25 19:23:48 -     let cptRain:Vector[] =      
2019-01-25 19:23:48 -         [| [|0.8; 0.2|] (* cloudy *); [|0.2; 0.8|] (* not cloudy *) |] 
2019-01-25 19:23:48 -         |> Array.map (fun a -> Vector.FromArray a)
2019-01-25 19:23:48 -     let cptWetGrass:Vector[][] = 
2019-01-25 19:23:48 -         [|  [|  [| 0.99; 0.01|] (* rain *); 
2019-01-25 19:23:48 -                 [| 0.9 ; 0.1 |] (* not rain *) |];     // Sprinkler
2019-01-25 19:23:48 -             [|  [| 0.9 ; 0.1 |] (* rain *); 
2019-01-25 19:23:48 -                 [| 0.0 ; 1.0 |] (* not rain *) |] |]   // Not sprinkler  
2019-01-25 19:23:48 -         |> Array.map (fun a -> a |> Array.map Vector.FromArray)
2019-01-25 19:23:48 -     {cloudy=probCloudy; sprinkler=cptSprinkler; rain=cptRain; wetGrass=cptWetGrass}
2019-01-25 19:23:48 - let sample  (numData:int)
2019-01-25 19:23:48 -             (dpv:DistributionParameterValues) : Sample =   
2019-01-25 19:23:48 -     let z = Array2D.init numData 4 (fun _ j -> 
2019-01-25 19:23:48 -         let cloudy =  Discrete.Sample(dpv.cloudy)
2019-01-25 19:23:48 -         let sprinkler = Discrete.Sample(dpv.sprinkler.[cloudy])
2019-01-25 19:23:48 -         let rain = Discrete.Sample(dpv.rain.[cloudy])
2019-01-25 19:23:48 -         let wetGrass = Discrete.Sample(dpv.wetGrass.[sprinkler].[rain])
2019-01-25 19:23:48 -         [|cloudy; sprinkler; rain; wetGrass|].[j])
2019-01-25 19:23:48 -     {cloudy = z.[*,0]; sprinkler = z.[*,1]; rain=z.[*,2]; wetGrass = z.[*,3]}
