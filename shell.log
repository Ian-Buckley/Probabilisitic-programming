2018-04-22 15:05:55 - // include directory, this will be replaced by the kernel
2018-04-22 15:05:55 - #I "/home/nbuser/IfSharp/bin"
2018-04-22 15:05:55 - // load base dlls
2018-04-22 15:05:55 - #r "IfSharp.Kernel.dll"
2018-04-22 15:05:55 - #r "NetMQ.dll"
2018-04-22 15:05:55 - // open the global functions and methods
2018-04-22 15:05:55 - open IfSharp.Kernel
2018-04-22 15:05:55 - open IfSharp.Kernel.Globals
2018-04-22 15:06:26 - F# Interactive for F# 4.1
2018-04-22 15:06:26 - Freely distributed under the Apache 2.0 Open Source License
2018-04-22 15:06:26 - For help type #help;;
2018-04-22 15:06:26 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-22 15:06:26 -   seq []
2018-04-22 15:06:26 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-22 15:06:26 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-22 15:06:26 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-22 15:06:34 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-22 15:07:03 - https://channel9.msdn.com/Events/FSharp-Events/fsharpConf-2018/06   
2018-04-22 15:07:03 - https://github.com/evelinag/probabilistic-programming/tree/master/code   
2018-04-22 15:07:03 - Unexpected symbol ':' in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2018-04-22 15:07:03 - parse error
2018-04-22 15:10:03 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-22 15:11:58 - open System
2018-04-22 15:11:58 - open MathNet.Numerics
2018-04-22 15:11:58 - open FSharp.Data
2018-04-22 15:11:58 - The namespace or module 'MathNet' is not defined. Maybe you want one of the following:
2018-04-22 15:11:58 -    Math
2018-04-22 15:14:49 - #load "paket-files/include-scripts/net45/include.main.group.fsx" 
2018-04-22 15:14:49 - Unable to find the file 'paket-files/include-scripts/net45/include.main.group.fsx' in any of
2018-04-22 15:14:49 -  /home/nbuser/IfSharp/bin
2018-04-22 15:14:49 -  /home/nbuser/library
2018-04-22 15:17:02 - // include directory, this will be replaced by the kernel
2018-04-22 15:17:02 - #I "/home/nbuser/IfSharp/bin"
2018-04-22 15:17:02 - // load base dlls
2018-04-22 15:17:02 - #r "IfSharp.Kernel.dll"
2018-04-22 15:17:02 - #r "NetMQ.dll"
2018-04-22 15:17:02 - // open the global functions and methods
2018-04-22 15:17:02 - open IfSharp.Kernel
2018-04-22 15:17:02 - open IfSharp.Kernel.Globals
2018-04-22 15:17:20 - // include directory, this will be replaced by the kernel
2018-04-22 15:17:20 - #I "/home/nbuser/IfSharp/bin"
2018-04-22 15:17:20 - // load base dlls
2018-04-22 15:17:20 - #r "IfSharp.Kernel.dll"
2018-04-22 15:17:20 - #r "NetMQ.dll"
2018-04-22 15:17:20 - // open the global functions and methods
2018-04-22 15:17:20 - open IfSharp.Kernel
2018-04-22 15:17:20 - open IfSharp.Kernel.Globals
2018-04-22 15:17:23 - F# Interactive for F# 4.1
2018-04-22 15:17:23 - Freely distributed under the Apache 2.0 Open Source License
2018-04-22 15:17:23 - For help type #help;;
2018-04-22 15:17:23 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-22 15:17:23 -   seq []
2018-04-22 15:17:23 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-22 15:17:23 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-22 15:17:23 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-22 15:17:42 - F# Interactive for F# 4.1
2018-04-22 15:17:42 - Freely distributed under the Apache 2.0 Open Source License
2018-04-22 15:17:42 - For help type #help;;
2018-04-22 15:17:42 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-22 15:17:42 -   seq []
2018-04-22 15:17:42 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-22 15:17:42 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-22 15:17:42 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-22 15:17:53 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-22 15:17:54 - #load "Paket.fsx"
2018-04-22 15:17:54 - Paket.Dependencies.Install """
2018-04-22 15:17:54 - frameworks: net45
2018-04-22 15:17:54 - source https://nuget.org/api/v2
2018-04-22 15:17:54 - nuget MathNet.Numerics
2018-04-22 15:17:54 - nuget MathNet.Numerics.FSharp
2018-04-22 15:17:54 - nuget FSharp.Data
2018-04-22 15:17:54 - nuget XPlot.Plotly
2018-04-22 15:17:54 - nuget Angara.Base
2018-04-22 15:17:54 - nuget Microsoft.Research.InferNET
2018-04-22 15:17:54 - github roguetrainer/Infer.NET-2.6 Infer.FSharp.dll
2018-04-22 15:17:54 - """
2018-04-22 15:17:54 - Paket.LoadingScripts.ScriptGeneration.generateScriptsForRootFolder 
2018-04-22 15:17:54 -    Paket.LoadingScripts.ScriptGeneration.FSharp
2018-04-22 15:17:54 -    (Paket.FrameworkIdentifier.DotNetFramework Paket.FrameworkVersion.V4_5)
2018-04-22 15:17:54 -    (System.IO.DirectoryInfo __SOURCE_DIRECTORY__)
2018-04-22 15:18:01 - This expression was expected to have type
2018-04-22 15:18:01 -     'Paket.Domain.GroupName list'    
2018-04-22 15:18:01 - but here has type
2018-04-22 15:18:01 -     'Paket.LoadingScripts.ScriptGeneration.ScriptType'    
2018-04-22 15:18:01 - This expression was expected to have type
2018-04-22 15:18:01 -     'Paket.LoadingScripts.ScriptGeneration.ScriptType'    
2018-04-22 15:18:01 - but here has type
2018-04-22 15:18:01 -     'Paket.FrameworkIdentifier'    
2018-04-22 15:18:01 - This expression was expected to have type
2018-04-22 15:18:01 -     'Paket.FrameworkIdentifier'    
2018-04-22 15:18:01 - but here has type
2018-04-22 15:18:01 -     'System.IO.DirectoryInfo'    
2018-04-22 15:19:29 - Paket.Package
2018-04-22 15:19:29 -   [ "MathNet.Numerics"
2018-04-22 15:19:29 -     "MathNet.Numerics.FSharp"
2018-04-22 15:19:29 -   ]
2018-04-22 15:19:30 - The value, namespace, type or module 'Paket' is not defined.
2018-04-22 15:20:11 - #load "Paket.fsx"
2018-04-22 15:20:20 - Paket.Package
2018-04-22 15:20:20 -   [ "MathNet.Numerics"
2018-04-22 15:20:20 -     "MathNet.Numerics.FSharp"
2018-04-22 15:20:20 -   ]
2018-04-22 15:20:36 - open System
2018-04-22 15:20:36 - open MathNet.Numerics
2018-04-22 15:20:36 - open FSharp.Data
2018-04-22 15:20:36 - The namespace or module 'MathNet' is not defined. Maybe you want one of the following:
2018-04-22 15:20:36 -    Math
2018-04-22 15:21:36 - #load "Paket.Generated.Refs.fsx"
2018-04-22 15:21:43 - open System
2018-04-22 15:21:43 - open MathNet.Numerics
2018-04-22 15:21:43 - open FSharp.Data
2018-04-22 15:22:09 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-22 15:46:55 - type Door = Goat | Car
2018-04-22 15:46:57 - type MontyHallValue = {
2018-04-22 15:46:57 -     Value: Door
2018-04-22 15:46:57 -     Probability: float }
2018-04-22 15:46:57 - type Distribution = MontyHallValue seq
2018-04-22 16:07:40 - #### Run always
2018-04-22 16:07:40 - Unexpected symbol # in directive. Expected identifier or other token.
2018-04-22 16:07:40 - parse error
2018-04-22 16:12:06 - #load "Paket.Generated.Refs.fsx2"
2018-04-22 16:12:06 - Unable to find the file 'Paket.Generated.Refs.fsx2' in any of
2018-04-22 16:12:06 -  /home/nbuser/IfSharp/bin
2018-04-22 16:12:06 -  /home/nbuser/library
2018-04-22 16:12:25 - #load "Paket.Generated.Refs.fsx"
2018-04-22 16:13:37 - #load "Paket.Generated.Refs.fsx"
2018-04-22 16:13:38 - open System
2018-04-22 16:13:38 - open MathNet.Numerics
2018-04-22 16:13:38 - open FSharp.Data
2018-04-22 16:13:38 - type Door = Goat | Car
2018-04-22 16:13:38 - type MontyHallValue = {
2018-04-22 16:13:38 -     Value: Door
2018-04-22 16:13:38 -     Probability: float }
2018-04-22 16:13:38 - type Distribution = MontyHallValue seq
2018-04-22 16:13:38 - let uniformDistribution (values: Door seq) = 
2018-04-22 16:13:38 -     let l = float (Seq.length values)
2018-04-22 16:13:38 -     values |> Seq.map (fun v -> {Value=v; Probability = 1.0/l})
2018-04-22 16:13:38 - let certainly value = seq [{Value=value; Probability =1.0}]
2018-04-22 16:13:39 - type ProbabilisticComputation<'T> = 
2018-04-22 16:13:39 -   | Sample of Distribution * (Door -> ProbabilisticComputation<'T>)
2018-04-22 16:13:39 -   | Return of 'T   
2018-04-22 16:13:39 - type ProbabilisticComputationBuilder() = 
2018-04-22 16:13:39 -   member x.Return(v) = Return v
2018-04-22 16:13:39 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-22 16:13:39 - let prob = ProbabilisticComputationBuilder()
2018-04-22 16:13:39 - let montyHallStay = prob {
2018-04-22 16:13:39 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 16:13:39 -     return initialDoor}
2018-04-22 16:13:39 - let montyHallSwitch = prob {
2018-04-22 16:13:39 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 16:13:39 -     let! switchedDoor = 
2018-04-22 16:13:39 -         match initialDoor with
2018-04-22 16:13:39 -         | Car -> certainly Goat
2018-04-22 16:13:39 -         | Goat -> certainly Car
2018-04-22 16:13:39 -     return switchedDoor}
2018-04-22 16:13:40 - let rec enumerate values comp = seq {
2018-04-22 16:13:40 -     match comp with 
2018-04-22 16:13:40 -     | Sample(dist,f) ->
2018-04-22 16:13:40 -         for option in dist do 
2018-04-22 16:13:40 -             yield! enumerate (option::values)(f option.Value)
2018-04-22 16:13:40 -     | Return v ->
2018-04-22 16:13:40 -         // Print what's happening
2018-04-22 16:13:40 -         printfn "-----"
2018-04-22 16:13:40 -         values |> List.rev
2018-04-22 16:13:40 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-22 16:13:40 -         yield v,
2018-04-22 16:13:40 -             (1.0, values)
2018-04-22 16:13:40 -             |> List.fold (fun acc x -> acc * x.Probability)}
2018-04-22 16:13:40 - The type 'float' does not match the type 'float * MontyHallValue list'
2018-04-22 16:13:40 - let summarize dist = 
2018-04-22 16:13:40 -     dist
2018-04-22 16:13:40 -     |> Seq.groupBy fst
2018-04-22 16:13:40 -     |> Seq.map (fun (value, xs:('a * float) seq) ->
2018-04-22 16:13:40 -         value, xs |> Seq.sumBy snd)
2018-04-22 16:13:40 -     |> List.ofSeq
2018-04-22 16:13:52 - let rec enumerate values comp = seq {
2018-04-22 16:13:52 -     match comp with 
2018-04-22 16:13:52 -     | Sample(dist,f) ->
2018-04-22 16:13:52 -         for option in dist do 
2018-04-22 16:13:52 -             yield! enumerate (option::values)(f option.Value)
2018-04-22 16:13:52 -     | Return v ->
2018-04-22 16:13:52 -         // Print what's happening
2018-04-22 16:13:52 -         printfn "-----"
2018-04-22 16:13:52 -         values |> List.rev
2018-04-22 16:13:52 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-22 16:13:52 -         yield v,
2018-04-22 16:13:52 -             (1.0, values)
2018-04-22 16:13:52 -             |> List.fold (fun acc x -> acc * x.Probability)}
2018-04-22 16:13:52 - The type 'float' does not match the type 'float * MontyHallValue list'
2018-04-22 16:14:07 - let summarize dist = 
2018-04-22 16:14:07 -     dist
2018-04-22 16:14:07 -     |> Seq.groupBy fst
2018-04-22 16:14:07 -     |> Seq.map (fun (value, xs:('a * float) seq) ->
2018-04-22 16:14:07 -         value, xs |> Seq.sumBy snd)
2018-04-22 16:14:07 -     |> List.ofSeq
2018-04-22 16:14:11 - let resultStay = enumerate [] montyHallStay |> summarize
2018-04-22 16:14:11 - let resultSwitch = enumerate [] montyHallSwitch |> summarize
2018-04-22 16:14:11 - The value or constructor 'enumerate' is not defined. Maybe you want one of the following:
2018-04-22 16:14:11 -    Enum
2018-04-22 16:14:11 -    enum
2018-04-22 16:14:11 -    Generate
2018-04-22 16:14:11 - The value or constructor 'enumerate' is not defined. Maybe you want one of the following:
2018-04-22 16:14:11 -    Enum
2018-04-22 16:14:11 -    enum
2018-04-22 16:14:11 -    Generate
2018-04-22 16:18:43 - shutdown request
2018-04-22 16:18:45 - // include directory, this will be replaced by the kernel
2018-04-22 16:18:45 - #I "/home/nbuser/IfSharp/bin"
2018-04-22 16:18:45 - // load base dlls
2018-04-22 16:18:45 - #r "IfSharp.Kernel.dll"
2018-04-22 16:18:45 - #r "NetMQ.dll"
2018-04-22 16:18:45 - // open the global functions and methods
2018-04-22 16:18:45 - open IfSharp.Kernel
2018-04-22 16:18:45 - open IfSharp.Kernel.Globals
2018-04-22 16:18:54 - F# Interactive for F# 4.1
2018-04-22 16:18:54 - Freely distributed under the Apache 2.0 Open Source License
2018-04-22 16:18:54 - For help type #help;;
2018-04-22 16:18:54 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-22 16:18:54 -   seq []
2018-04-22 16:18:54 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-22 16:18:54 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-22 16:18:54 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-22 16:18:54 - #load "Paket.Generated.Refs.fsx"
2018-04-22 16:18:55 - #load "Paket.Generated.Refs.fsx"
2018-04-22 16:18:55 - open System
2018-04-22 16:18:55 - open MathNet.Numerics
2018-04-22 16:18:55 - open FSharp.Data
2018-04-22 16:18:56 - type Door = Goat | Car
2018-04-22 16:18:57 - type MontyHallValue = {
2018-04-22 16:18:57 -     Value: Door
2018-04-22 16:18:57 -     Probability: float }
2018-04-22 16:18:57 - type Distribution = MontyHallValue seq
2018-04-22 16:18:58 - let uniformDistribution (values: Door seq) = 
2018-04-22 16:18:58 -     let l = float (Seq.length values)
2018-04-22 16:18:58 -     values |> Seq.map (fun v -> {Value=v; Probability = 1.0/l})
2018-04-22 16:18:58 - let certainly value = seq [{Value=value; Probability =1.0}]
2018-04-22 16:18:58 - type ProbabilisticComputation<'T> = 
2018-04-22 16:18:58 -   | Sample of Distribution * (Door -> ProbabilisticComputation<'T>)
2018-04-22 16:18:58 -   | Return of 'T   
2018-04-22 16:18:58 - type ProbabilisticComputationBuilder() = 
2018-04-22 16:18:58 -   member x.Return(v) = Return v
2018-04-22 16:18:58 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-22 16:18:59 - let prob = ProbabilisticComputationBuilder()
2018-04-22 16:18:59 - let montyHallStay = prob {
2018-04-22 16:18:59 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 16:18:59 -     return initialDoor}
2018-04-22 16:18:59 - let montyHallSwitch = prob {
2018-04-22 16:18:59 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 16:18:59 -     let! switchedDoor = 
2018-04-22 16:18:59 -         match initialDoor with
2018-04-22 16:18:59 -         | Car -> certainly Goat
2018-04-22 16:18:59 -         | Goat -> certainly Car
2018-04-22 16:18:59 -     return switchedDoor}
2018-04-22 16:18:59 - let rec enumerate values comp = seq {
2018-04-22 16:18:59 -     match comp with 
2018-04-22 16:18:59 -     | Sample(dist,f) ->
2018-04-22 16:18:59 -         for option in dist do 
2018-04-22 16:18:59 -             yield! enumerate (option::values)(f option.Value)
2018-04-22 16:18:59 -     | Return v ->
2018-04-22 16:18:59 -         // Print what's happening
2018-04-22 16:18:59 -         printfn "-----"
2018-04-22 16:18:59 -         values |> List.rev
2018-04-22 16:18:59 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-22 16:18:59 -         yield v,
2018-04-22 16:18:59 -             (1.0, values)
2018-04-22 16:18:59 -             |> List.fold (fun acc x -> acc * x.Probability)}
2018-04-22 16:18:59 - The type 'float' does not match the type 'float * MontyHallValue list'
2018-04-22 16:19:00 - let summarize dist = 
2018-04-22 16:19:00 -     dist
2018-04-22 16:19:00 -     |> Seq.groupBy fst
2018-04-22 16:19:00 -     |> Seq.map (fun (value, xs:('a * float) seq) ->
2018-04-22 16:19:00 -         value, xs |> Seq.sumBy snd)
2018-04-22 16:19:00 -     |> List.ofSeq
2018-04-22 16:31:02 - !ls
2018-04-22 16:31:02 - The value or constructor 'ls' is not defined. Maybe you want one of the following:
2018-04-22 16:31:02 -    List
2018-04-22 16:31:02 -    list
2018-04-22 16:31:02 -    MS
2018-04-22 16:36:44 - Paket.Package
2018-04-22 16:36:44 -   [ "MathNet.Numerics"
2018-04-22 16:36:44 -     "MathNet.Numerics.FSharp"
2018-04-22 16:36:44 -     "FSharp.Data"
2018-04-22 16:36:44 -   ]
2018-04-22 16:36:44 - The value, constructor, namespace or type 'Package' is not defined.
2018-04-22 16:36:51 - #load "Paket.fsx"
2018-04-22 16:36:55 - Paket.Package
2018-04-22 16:36:55 -   [ "MathNet.Numerics"
2018-04-22 16:36:55 -     "MathNet.Numerics.FSharp"
2018-04-22 16:36:55 -     "FSharp.Data"
2018-04-22 16:36:55 -   ]
2018-04-22 16:37:04 - #load "Paket.Generated.Refs.fsx"
2018-04-22 16:37:16 - #r "packages/MathNet.Numerics/lib/net40/MathNet.Numerics.dll"
2018-04-22 16:37:16 - #r "packages/FSharp.Data/lib/net40/FSharp.Data.dll"
2018-04-22 16:37:16 - Unable to find the file 'packages/FSharp.Data/lib/net40/FSharp.Data.dll' in any of
2018-04-22 16:37:16 -  /usr/lib/mono/4.5
2018-04-22 16:37:16 -  /usr/lib/mono/4.5/Facades
2018-04-22 16:37:16 -  /home/nbuser/IfSharp/bin
2018-04-22 16:37:16 -  /home/nbuser/library
2018-04-22 16:37:16 -  /home/nbuser/IfSharp/bin/
2018-04-22 16:39:23 - #r "packages/MathNet.Numerics/lib/net40/MathNet.Numerics.dll"
2018-04-22 16:39:23 - #r "packages/FSharp.Data/lib/net45/FSharp.Data.dll"
2018-04-22 16:41:17 - open System
2018-04-22 16:41:17 - open MathNet.Numerics
2018-04-22 16:41:17 - open FSharp.Data
2018-04-22 16:41:19 - type Door = Goat | Car
2018-04-22 16:41:20 - type MontyHallValue = {
2018-04-22 16:41:20 -     Value: Door
2018-04-22 16:41:20 -     Probability: float }
2018-04-22 16:41:20 - type Distribution = MontyHallValue seq
2018-04-22 16:41:20 - let uniformDistribution (values: Door seq) = 
2018-04-22 16:41:20 -     let l = float (Seq.length values)
2018-04-22 16:41:20 -     values |> Seq.map (fun v -> {Value=v; Probability = 1.0/l})
2018-04-22 16:41:20 - let certainly value = seq [{Value=value; Probability =1.0}]
2018-04-22 16:41:26 - type ProbabilisticComputation<'T> = 
2018-04-22 16:41:26 -   | Sample of Distribution * (Door -> ProbabilisticComputation<'T>)
2018-04-22 16:41:26 -   | Return of 'T   
2018-04-22 16:41:27 - type ProbabilisticComputationBuilder() = 
2018-04-22 16:41:27 -   member x.Return(v) = Return v
2018-04-22 16:41:27 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-22 16:41:27 - let prob = ProbabilisticComputationBuilder()
2018-04-22 16:41:29 - let montyHallStay = prob {
2018-04-22 16:41:29 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 16:41:29 -     return initialDoor}
2018-04-22 16:41:29 - let montyHallSwitch = prob {
2018-04-22 16:41:29 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 16:41:29 -     let! switchedDoor = 
2018-04-22 16:41:29 -         match initialDoor with
2018-04-22 16:41:29 -         | Car -> certainly Goat
2018-04-22 16:41:29 -         | Goat -> certainly Car
2018-04-22 16:41:29 -     return switchedDoor}
2018-04-22 16:41:31 - let rec enumerate values comp = seq {
2018-04-22 16:41:31 -     match comp with 
2018-04-22 16:41:31 -     | Sample(dist,f) ->
2018-04-22 16:41:31 -         for option in dist do 
2018-04-22 16:41:31 -             yield! enumerate (option::values)(f option.Value)
2018-04-22 16:41:31 -     | Return v ->
2018-04-22 16:41:31 -         // Print what's happening
2018-04-22 16:41:31 -         printfn "-----"
2018-04-22 16:41:31 -         values |> List.rev
2018-04-22 16:41:31 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-22 16:41:31 -         yield v,
2018-04-22 16:41:31 -             (1.0, values)
2018-04-22 16:41:31 -             |> List.fold (fun acc x -> acc * x.Probability)}
2018-04-22 16:41:32 - The type 'float' does not match the type 'float * MontyHallValue list'
2018-04-22 16:57:19 - let rec enumerate values comp = seq {
2018-04-22 16:57:19 -     match comp with 
2018-04-22 16:57:19 -     | Sample(dist,f) ->
2018-04-22 16:57:19 -         for option in dist do 
2018-04-22 16:57:19 -             yield! enumerate (option::values)(f option.Value)
2018-04-22 16:57:19 -     | Return v ->
2018-04-22 16:57:19 -         // Print what's happening
2018-04-22 16:57:19 -         printfn "-----"
2018-04-22 16:57:19 -         values |> List.rev
2018-04-22 16:57:19 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-22 16:57:19 -         yield v,
2018-04-22 16:57:19 -             (1.0, values)
2018-04-22 16:57:19 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-22 16:57:33 - let rec enumerate values comp = seq {
2018-04-22 16:57:33 -     match comp with 
2018-04-22 16:57:33 -     | Sample(dist,f) ->
2018-04-22 16:57:33 -         for option in dist do 
2018-04-22 16:57:33 -             yield! enumerate (option::values)(f option.Value)
2018-04-22 16:57:33 -     | Return v ->
2018-04-22 16:57:33 -         // Print what's happening
2018-04-22 16:57:33 -         printfn "-----"
2018-04-22 16:57:33 -         values |> List.rev
2018-04-22 16:57:33 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-22 16:57:33 -         yield v,
2018-04-22 16:57:33 -             (1.0, values)
2018-04-22 16:57:33 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-22 16:57:35 - let summarize dist = 
2018-04-22 16:57:35 -     dist
2018-04-22 16:57:35 -     |> Seq.groupBy fst
2018-04-22 16:57:35 -     |> Seq.map (fun (value, xs:('a * float) seq) ->
2018-04-22 16:57:35 -         value, xs |> Seq.sumBy snd)
2018-04-22 16:57:35 -     |> List.ofSeq
2018-04-22 16:57:37 - let resultStay = enumerate [] montyHallStay |> summarize
2018-04-22 16:57:37 - let resultSwitch = enumerate [] montyHallSwitch |> summarize
2018-04-22 16:57:45 - printfn "Probability of winning if stay: %f" ifStay
2018-04-22 16:57:45 - printfn "Probability of winning if switch: %f" ifSwitch
2018-04-22 16:57:45 - The value or constructor 'ifStay' is not defined.
2018-04-22 16:57:45 - The value or constructor 'ifSwitch' is not defined.
2018-04-22 16:58:01 - printfn "Probability of winning if stay: %f" resultStay
2018-04-22 16:58:01 - printfn "Probability of winning if switch: %f" resultSwitch
2018-04-22 16:58:01 - The type '(Door * float) list' is not compatible with any of the types float,float32,Decimal, arising from the use of a printf-style format string
2018-04-22 16:58:01 - The type '(Door * float) list' is not compatible with any of the types float,float32,Decimal, arising from the use of a printf-style format string
2018-04-22 16:58:37 - let resultStay = enumerate [] montyHallStay |> summarize
2018-04-22 16:58:39 - let resultSwitch = enumerate [] montyHallSwitch |> summarize
2018-04-22 17:02:09 - montyHallStay
2018-04-22 17:04:53 - Sample
2018-04-22 17:05:01 - help Sample
2018-04-22 17:05:02 - The value or constructor 'help' is not defined. Maybe you want one of the following:
2018-04-22 17:05:02 -    Help
2018-04-22 17:05:08 - Help Sample
2018-04-22 17:37:44 - Syme, Don, Adam Granicz, and Antonio Cisternino. Expert F# 4.0. Apress, 2015.
2018-04-22 17:37:45 - Unexpected keyword 'and' in expression
2018-04-22 17:37:45 - Identifiers followed by '#' are reserved for future use
2018-04-22 17:49:39 - // include directory, this will be replaced by the kernel
2018-04-22 17:49:39 - #I "/home/nbuser/IfSharp/bin"
2018-04-22 17:49:39 - // load base dlls
2018-04-22 17:49:39 - #r "IfSharp.Kernel.dll"
2018-04-22 17:49:39 - #r "NetMQ.dll"
2018-04-22 17:49:39 - // open the global functions and methods
2018-04-22 17:49:39 - open IfSharp.Kernel
2018-04-22 17:49:39 - open IfSharp.Kernel.Globals
2018-04-22 17:50:05 - F# Interactive for F# 4.1
2018-04-22 17:50:05 - Freely distributed under the Apache 2.0 Open Source License
2018-04-22 17:50:05 - For help type #help;;
2018-04-22 17:50:05 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-22 17:50:05 -   seq []
2018-04-22 17:50:05 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-22 17:50:05 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-22 17:50:05 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-22 17:50:27 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-22 17:54:30 - type Attempt<'T> = (unit -> 'T option)
2018-04-22 17:54:30 - let succeed x = (fun () -> Some(x)) : Attempt<'T>
2018-04-22 17:54:30 - let fail = (fun () -> None) : Attempt<'T>
2018-04-22 17:54:30 - let runAttempt (a : Attempt<'T>) = a()
2018-04-22 17:54:51 - let succeed x = (fun () -> Some(x))
2018-04-22 17:54:51 - let fail = (fun () -> None)
2018-04-22 17:54:51 - let runAttempt (a : Attempt<'T>) = a()
2018-04-22 17:54:51 - let bind p rest = match runAttempt p with None -> fail | Some r -> (rest r)
2018-04-22 17:54:51 - let delay f = (fun () -> runAttempt (f()))
2018-04-22 17:54:51 - let combine p1 p2 = (fun () -> match p1() with None -> p2() | res -> res)
2018-04-22 17:55:02 - type AttemptBuilder() =
2018-04-22 17:55:02 -     /// Used to de-sugar uses of 'let!' inside computation expressions.
2018-04-22 17:55:02 -     member b.Bind(p, rest) = bind p rest
2018-04-22 17:55:02 -     /// Delays the construction of an attempt until just before it is executed
2018-04-22 17:55:02 -     member b.Delay(f) = delay f
2018-04-22 17:55:02 -     /// Used to de-sugar uses of 'return' inside computation expressions.
2018-04-22 17:55:02 -     member b.Return(x) = succeed x
2018-04-22 17:55:02 -     /// Used to de-sugar uses of 'return!' inside computation expressions.
2018-04-22 17:55:02 -     member b.ReturnFrom(x : Attempt<'T>) = x
2018-04-22 17:55:02 -     /// Used to de-sugar uses of 'c1; c2' inside computation expressions.
2018-04-22 17:55:02 -     member b.Combine(p1 : Attempt<'T>, p2 : Attempt<'T>) = combine p1 p2
2018-04-22 17:55:02 -     /// Used to de-sugar uses of 'if .. then ..' inside computation expressions when
2018-04-22 17:55:02 -     /// the 'else' branch is empty
2018-04-22 17:55:02 -     member b.Zero() = fail
2018-04-22 17:55:34 - type AttemptBuilder() =
2018-04-22 17:55:34 -     /// Used to de-sugar uses of 'let!' inside computation expressions.
2018-04-22 17:55:34 -     member b.Bind(p, rest) = bind p rest
2018-04-22 17:55:34 -     /// Delays the construction of an attempt until just before it is executed
2018-04-22 17:55:34 -     member b.Delay(f) = delay f
2018-04-22 17:55:34 -     /// Used to de-sugar uses of 'return' inside computation expressions.
2018-04-22 17:55:34 -     member b.Return(x) = succeed x
2018-04-22 17:55:34 -     /// Used to de-sugar uses of 'return!' inside computation expressions.
2018-04-22 17:55:34 -     member b.ReturnFrom(x : Attempt<'T>) = x
2018-04-22 17:55:34 -     /// Used to de-sugar uses of 'c1; c2' inside computation expressions.
2018-04-22 17:55:34 -     member b.Combine(p1 : Attempt<'T>, p2 : Attempt<'T>) = combine p1 p2
2018-04-22 17:55:34 -     /// Used to de-sugar uses of 'if .. then ..' inside computation expressions when
2018-04-22 17:55:34 -     /// the 'else' branch is empty
2018-04-22 17:55:34 -     member b.Zero() = fail
2018-04-22 17:55:35 - let attempt = new AttemptBuilder()
2018-04-22 17:55:49 - let alwaysOne = attempt { return 1 }
2018-04-22 17:55:49 - let alwaysPair = attempt { return (1,"two") }
2018-04-22 17:55:49 - let failIfBig n = attempt {if n > 1000 then return! fail else return n}
2018-04-22 17:55:49 - let failIfEitherBig (inp1, inp2) = 
2018-04-22 17:55:49 -     attempt {
2018-04-22 17:55:49 -         let! n1 = failIfBig inp1
2018-04-22 17:55:49 -         let! n2 = failIfBig inp2
2018-04-22 17:55:49 -         return (n1, n2)}
2018-04-22 18:01:43 - let succeed x = (fun () -> Some(x)) : Attempt<'T>
2018-04-22 18:01:43 - let fail = (fun () -> None) : Attempt<'T>
2018-04-22 18:01:43 - let runAttempt (a : Attempt<'T>) = a()
2018-04-22 18:01:54 - let succeed x = (fun () -> Some(x))
2018-04-22 18:01:54 - let fail = (fun () -> None)
2018-04-22 18:01:54 - let runAttempt (a : Attempt<'T>) = a()
2018-04-22 18:01:54 - let bind p rest = match runAttempt p with None -> fail | Some r -> (rest r)
2018-04-22 18:01:54 - let delay f = (fun () -> runAttempt (f()))
2018-04-22 18:01:54 - let combine p1 p2 = (fun () -> match p1() with None -> p2() | res -> res)
2018-04-22 18:48:40 - #load "Paket.Generated.Refs.fsx"
2018-04-22 18:48:41 - open System
2018-04-22 18:48:41 - open MathNet.Numerics
2018-04-22 18:48:41 - open FSharp.Data
2018-04-22 18:48:41 - type Door = Goat | Car
2018-04-22 18:48:41 - type MontyHallValue = {
2018-04-22 18:48:41 -     Value: Door
2018-04-22 18:48:41 -     Probability: float }
2018-04-22 18:48:41 - type Distribution = MontyHallValue seq
2018-04-22 18:48:41 - let uniformDistribution (values: Door seq) = 
2018-04-22 18:48:41 -     let l = float (Seq.length values)
2018-04-22 18:48:41 -     values |> Seq.map (fun v -> {Value=v; Probability = 1.0/l})
2018-04-22 18:48:41 - let certainly value = seq [{Value=value; Probability =1.0}]
2018-04-22 18:48:41 - type ProbabilisticComputation<'T> = 
2018-04-22 18:48:41 -   | Sample of Distribution * (Door -> ProbabilisticComputation<'T>)
2018-04-22 18:48:41 -   | Return of 'T   
2018-04-22 18:48:42 - type ProbabilisticComputationBuilder() = 
2018-04-22 18:48:42 -   member x.Return(v) = Return v
2018-04-22 18:48:42 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-22 18:48:42 - let prob = ProbabilisticComputationBuilder()
2018-04-22 18:48:42 - let montyHallStay = prob {
2018-04-22 18:48:42 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 18:48:42 -     return initialDoor}
2018-04-22 18:48:42 - let montyHallSwitch = prob {
2018-04-22 18:48:42 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 18:48:42 -     let! switchedDoor = 
2018-04-22 18:48:42 -         match initialDoor with
2018-04-22 18:48:42 -         | Car -> certainly Goat
2018-04-22 18:48:42 -         | Goat -> certainly Car
2018-04-22 18:48:42 -     return switchedDoor}
2018-04-22 18:48:42 - let rec enumerate values comp = seq {
2018-04-22 18:48:42 -     match comp with 
2018-04-22 18:48:42 -     | Sample(dist,f) ->
2018-04-22 18:48:42 -         for option in dist do 
2018-04-22 18:48:42 -             yield! enumerate (option::values)(f option.Value)
2018-04-22 18:48:42 -     | Return v ->
2018-04-22 18:48:42 -         // Print what's happening
2018-04-22 18:48:42 -         printfn "-----"
2018-04-22 18:48:42 -         values |> List.rev
2018-04-22 18:48:42 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-22 18:48:42 -         yield v,
2018-04-22 18:48:42 -             (1.0, values)
2018-04-22 18:48:42 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-22 18:48:42 - let summarize dist = 
2018-04-22 18:48:42 -     dist
2018-04-22 18:48:42 -     |> Seq.groupBy fst
2018-04-22 18:48:42 -     |> Seq.map (fun (value, xs:('a * float) seq) ->
2018-04-22 18:48:42 -         value, xs |> Seq.sumBy snd)
2018-04-22 18:48:42 -     |> List.ofSeq
2018-04-22 18:55:26 - type MontyHallValue = {
2018-04-22 18:55:26 -     Value: Door
2018-04-22 18:55:26 -     Probability: float }
2018-04-22 19:18:41 - let resultStay = enumerate [] montyHallStay |> summarize
2018-04-22 19:18:44 - let resultSwitch = enumerate [] montyHallSwitch |> summarize
2018-04-22 19:19:01 - #load "Paket.Generated.Refs.fsx"
2018-04-22 19:19:01 - open System
2018-04-22 19:19:01 - open MathNet.Numerics
2018-04-22 19:19:01 - open FSharp.Data
2018-04-22 19:19:02 - type Door = Goat | Car
2018-04-22 19:19:02 - type MontyHallValue = {
2018-04-22 19:19:02 -     Value: Door
2018-04-22 19:19:02 -     Probability: float }
2018-04-22 19:19:02 - type Distribution = MontyHallValue seq
2018-04-22 19:19:02 - let uniformDistribution (values: Door seq) = 
2018-04-22 19:19:02 -     let l = float (Seq.length values)
2018-04-22 19:19:02 -     values |> Seq.map (fun v -> {Value=v; Probability = 1.0/l})
2018-04-22 19:19:02 - let certainly value = seq [{Value=value; Probability =1.0}]
2018-04-22 19:19:03 - type ProbabilisticComputation<'T> = 
2018-04-22 19:19:03 -   | Sample of Distribution * (Door -> ProbabilisticComputation<'T>)
2018-04-22 19:19:03 -   | Return of 'T   
2018-04-22 19:19:03 - type ProbabilisticComputationBuilder() = 
2018-04-22 19:19:03 -   member x.Return(v) = Return v
2018-04-22 19:19:03 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-22 19:19:03 - let prob = ProbabilisticComputationBuilder()
2018-04-22 19:19:03 - let montyHallStay = prob {
2018-04-22 19:19:03 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 19:19:03 -     return initialDoor}
2018-04-22 19:19:03 - let montyHallSwitch = prob {
2018-04-22 19:19:03 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 19:19:03 -     let! switchedDoor = 
2018-04-22 19:19:03 -         match initialDoor with
2018-04-22 19:19:03 -         | Car -> certainly Goat
2018-04-22 19:19:03 -         | Goat -> certainly Car
2018-04-22 19:19:03 -     return switchedDoor}
2018-04-22 19:19:04 - let rec enumerate values comp = seq {
2018-04-22 19:19:04 -     match comp with 
2018-04-22 19:19:04 -     | Sample(dist,f) ->
2018-04-22 19:19:04 -         // Loop over the MontyHallValues in the Distribution
2018-04-22 19:19:04 -         for option in dist do 
2018-04-22 19:19:04 -             yield! enumerate (option::values)(f option.Value)
2018-04-22 19:19:04 -     | Return v ->
2018-04-22 19:19:04 -         // Print what's happening
2018-04-22 19:19:04 -         printfn "-----"
2018-04-22 19:19:04 -         values |> List.rev
2018-04-22 19:19:04 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-22 19:19:04 -         yield v,
2018-04-22 19:19:04 -             (1.0, values)
2018-04-22 19:19:04 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-22 19:19:04 - let summarize dist = 
2018-04-22 19:19:04 -     dist
2018-04-22 19:19:04 -     |> Seq.groupBy fst   // Want two bins: for Car & Goat
2018-04-22 19:19:04 -     |> Seq.map (fun (value, xs:('a * float) seq) ->
2018-04-22 19:19:04 -         value, xs |> Seq.sumBy snd)
2018-04-22 19:19:04 -     |> List.ofSeq
2018-04-22 19:20:08 - montyHallSwitch
2018-04-22 20:20:35 - montyHallStay.Sample
2018-04-22 20:20:35 - The syntax 'expr.id' may only be used with record labels, properties and fields
2018-04-22 20:21:12 - montyHallStay |> snd
2018-04-22 20:21:12 - Type mismatch. Expecting a
2018-04-22 20:21:12 -     'ProbabilisticComputation<Door> -> obj'    
2018-04-22 20:21:12 - but given a
2018-04-22 20:21:12 -     'obj * obj -> obj'    
2018-04-22 20:21:12 - The type 'ProbabilisticComputation<Door>' does not match the type 'obj * obj'
2018-04-22 20:23:09 - snd montyHallStay
2018-04-22 20:23:09 - This expression was expected to have type
2018-04-22 20:23:09 -     'obj * obj'    
2018-04-22 20:23:09 - but here has type
2018-04-22 20:23:09 -     'ProbabilisticComputation<Door>'    
2018-04-22 20:24:07 - type ProbabilisticComputation<'T> = 
2018-04-22 20:24:07 -   | Sample of Distribution * ('T -> ProbabilisticComputation<'T>)
2018-04-22 20:24:07 -   | Return of 'T   
2018-04-22 20:24:20 - type ProbabilisticComputation<'T> = 
2018-04-22 20:24:20 -   | Sample of Distribution * (Door -> ProbabilisticComputation<'T>)
2018-04-22 20:24:20 -   | Return of 'T   
2018-04-22 20:25:17 - montyHallStay.Sample
2018-04-22 20:25:17 - The syntax 'expr.id' may only be used with record labels, properties and fields
2018-04-22 20:25:26 - snd montyHallStay.Sample
2018-04-22 20:25:26 - The syntax 'expr.id' may only be used with record labels, properties and fields
2018-04-22 20:25:31 - montyHallStay
2018-04-22 20:28:24 - let Sample(s,fn) = montyHallStay.Sample
2018-04-22 20:28:25 - The syntax 'expr.id' may only be used with record labels, properties and fields
2018-04-22 20:28:25 - let Sample(s,fn) = montyHallStay
2018-04-22 20:28:29 - let Sample(s,fn) = montyHallStay
2018-04-22 20:28:36 - fn
2018-04-22 20:28:36 - The value or constructor 'fn' is not defined. Maybe you want one of the following:
2018-04-22 20:28:36 -    Func
2018-04-22 20:28:47 - let Sample(s,fn) = montyHallStay
2018-04-22 20:28:57 - s
2018-04-22 20:28:58 - The value or constructor 's' is not defined. Maybe you want one of the following:
2018-04-22 20:28:58 -    SR
2018-04-22 20:28:58 -    MS
2018-04-22 20:29:11 - montyHallStay
2018-04-22 21:19:22 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-22 21:20:28 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-22 21:26:27 - let random = new System.Random()
2018-04-22 21:26:27 - let rand() = random.NextDouble()
2018-04-22 21:26:27 - let randomNumberInCircle = attempt {
2018-04-22 21:26:27 -     let x, y = rand(), rand()
2018-04-22 21:26:27 -     condition (x * x + y * y < 1.0)
2018-04-22 21:26:27 -     return (x, y)}
2018-04-22 21:26:28 - The value or constructor 'condition' is not defined.
2018-04-22 21:28:21 - let condition p guard = (fun () -> 
2018-04-22 21:28:21 -     match p() with 
2018-04-22 21:28:21 -     | Some x when guard x -> Some x 
2018-04-22 21:28:21 -     | _ -> None)
2018-04-22 21:28:21 - type AttemptBuilder with
2018-04-22 21:28:21 -     [<CustomOperation("condition",MaintainsVariableSpaceUsingBind = true)>]
2018-04-22 21:28:21 -     member x.Condition(p, [<ProjectionParameter>] b) = condition p b
2018-04-22 21:28:22 - let attempt2 = new AttemptBuilder()
2018-04-22 21:28:29 - let random = new System.Random()
2018-04-22 21:28:29 - let rand() = random.NextDouble()
2018-04-22 21:28:29 - let randomNumberInCircle = attempt {
2018-04-22 21:28:29 -     let x, y = rand(), rand()
2018-04-22 21:28:29 -     condition (x * x + y * y < 1.0)
2018-04-22 21:28:29 -     return (x, y)}
2018-04-22 21:28:31 - type Distribution<'T when 'T : comparison> =
2018-04-22 21:28:31 -     abstract Sample : 'T
2018-04-22 21:28:31 -     abstract Support : Set<'T>
2018-04-22 21:28:31 -     abstract Expectation: ('T -> float) -> float
2018-04-22 21:28:35 - let always x =
2018-04-22 21:28:35 -     { new Distribution<'T> with
2018-04-22 21:28:35 -           member d.Sample = x
2018-04-22 21:28:35 -           member d.Support = Set.singleton x
2018-04-22 21:28:35 -           member d.Expectation(H) = H(x) }
2018-04-22 21:36:29 - #load "Paket.Generated.Refs.fsx"
2018-04-22 21:36:30 - open System
2018-04-22 21:36:30 - open MathNet.Numerics
2018-04-22 21:36:30 - open FSharp.Data
2018-04-22 21:36:30 - type Door = Goat | Car
2018-04-22 21:36:31 - type MontyHallValue = {
2018-04-22 21:36:31 -     Value: Door
2018-04-22 21:36:31 -     Probability: float }
2018-04-22 21:36:31 - type Distribution = MontyHallValue seq
2018-04-22 21:36:31 - let uniformDistribution (values: Door seq) = 
2018-04-22 21:36:31 -     let l = float (Seq.length values)
2018-04-22 21:36:31 -     values |> Seq.map (fun v -> {Value=v; Probability = 1.0/l})
2018-04-22 21:36:31 - let certainly value = seq [{Value=value; Probability =1.0}]
2018-04-22 21:36:31 - type ProbabilisticComputation<'T> = 
2018-04-22 21:36:31 -   | Sample of Distribution * (Door -> ProbabilisticComputation<'T>)
2018-04-22 21:36:31 -   | Return of 'T   
2018-04-22 21:36:32 - type ProbabilisticComputationBuilder() = 
2018-04-22 21:36:32 -   member x.Return(v) = Return v
2018-04-22 21:36:32 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-22 21:36:32 - let prob = ProbabilisticComputationBuilder()
2018-04-22 21:36:32 - let montyHallStay = prob {
2018-04-22 21:36:32 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 21:36:32 -     return initialDoor}
2018-04-22 21:36:32 - let montyHallSwitch = prob {
2018-04-22 21:36:32 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 21:36:32 -     let! switchedDoor = 
2018-04-22 21:36:32 -         match initialDoor with
2018-04-22 21:36:32 -         | Car -> certainly Goat
2018-04-22 21:36:32 -         | Goat -> certainly Car
2018-04-22 21:36:32 -     return switchedDoor}
2018-04-22 21:36:32 - let rec enumerate values comp = seq {
2018-04-22 21:36:32 -     match comp with 
2018-04-22 21:36:32 -     | Sample(dist:Distribution,f) ->
2018-04-22 21:36:32 -         // Loop over the MontyHallValues in the Distribution
2018-04-22 21:36:32 -         for option in dist do 
2018-04-22 21:36:32 -             yield! enumerate (option::values)(f option.Value)
2018-04-22 21:36:32 -     | Return v ->
2018-04-22 21:36:32 -         // Print what's happening
2018-04-22 21:36:32 -         printfn "-----"
2018-04-22 21:36:32 -         values |> List.rev
2018-04-22 21:36:32 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-22 21:36:32 -         yield v,
2018-04-22 21:36:32 -             (1.0, values)
2018-04-22 21:36:32 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-22 21:36:33 - let summarize dist = 
2018-04-22 21:36:33 -     dist
2018-04-22 21:36:33 -     |> Seq.groupBy fst   // Want two bins: for Car & Goat
2018-04-22 21:36:33 -     |> Seq.map (fun (value, xs:('a * float) seq) ->
2018-04-22 21:36:33 -         value, xs |> Seq.sumBy snd)
2018-04-22 21:36:33 -     |> List.ofSeq
2018-04-22 21:39:24 - // include directory, this will be replaced by the kernel
2018-04-22 21:39:24 - #I "/home/nbuser/IfSharp/bin"
2018-04-22 21:39:24 - // load base dlls
2018-04-22 21:39:24 - #r "IfSharp.Kernel.dll"
2018-04-22 21:39:24 - #r "NetMQ.dll"
2018-04-22 21:39:24 - // open the global functions and methods
2018-04-22 21:39:24 - open IfSharp.Kernel
2018-04-22 21:39:24 - open IfSharp.Kernel.Globals
2018-04-22 21:39:40 - F# Interactive for F# 4.1
2018-04-22 21:39:40 - Freely distributed under the Apache 2.0 Open Source License
2018-04-22 21:39:40 - For help type #help;;
2018-04-22 21:39:40 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-22 21:39:40 -   seq []
2018-04-22 21:39:40 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-22 21:39:40 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-22 21:39:40 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-22 21:39:47 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-22 21:46:24 - // include directory, this will be replaced by the kernel
2018-04-22 21:46:24 - #I "/home/nbuser/IfSharp/bin"
2018-04-22 21:46:24 - // load base dlls
2018-04-22 21:46:24 - #r "IfSharp.Kernel.dll"
2018-04-22 21:46:24 - #r "NetMQ.dll"
2018-04-22 21:46:24 - // open the global functions and methods
2018-04-22 21:46:24 - open IfSharp.Kernel
2018-04-22 21:46:24 - open IfSharp.Kernel.Globals
2018-04-22 21:46:40 - F# Interactive for F# 4.1
2018-04-22 21:46:40 - Freely distributed under the Apache 2.0 Open Source License
2018-04-22 21:46:40 - For help type #help;;
2018-04-22 21:46:40 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-22 21:46:40 -   seq []
2018-04-22 21:46:40 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-22 21:46:40 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-22 21:46:40 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-22 21:46:49 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-22 21:47:43 - // include directory, this will be replaced by the kernel
2018-04-22 21:47:43 - #I "/home/nbuser/IfSharp/bin"
2018-04-22 21:47:43 - // load base dlls
2018-04-22 21:47:43 - #r "IfSharp.Kernel.dll"
2018-04-22 21:47:43 - #r "NetMQ.dll"
2018-04-22 21:47:43 - // open the global functions and methods
2018-04-22 21:47:43 - open IfSharp.Kernel
2018-04-22 21:47:43 - open IfSharp.Kernel.Globals
2018-04-22 21:47:59 - F# Interactive for F# 4.1
2018-04-22 21:47:59 - Freely distributed under the Apache 2.0 Open Source License
2018-04-22 21:47:59 - For help type #help;;
2018-04-22 21:47:59 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-22 21:47:59 -   seq []
2018-04-22 21:47:59 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-22 21:47:59 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-22 21:47:59 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-22 21:48:07 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-22 21:52:13 - #load "Paket.fsx"
2018-04-22 21:52:13 - Paket.Package ["Infer.NET"]
2018-04-22 21:52:20 - Expression evaluation failed: Could not find versions for package Infer.NET on https://www.nuget.org/api/v2.
2018-04-22 21:52:20 - ExceptionCould not find versions for package Infer.NET on https://www.nuget.org/api/v2.
2018-04-22 21:52:20 -   at Paket.NuGetV2+versions@892-5.Invoke (System.String message) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Core.PrintfImpl+StringPrintfEnv`1[TResult].Finalize () [0x00012] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Core.PrintfImpl+Final2@235[TState,TResidue,TResult,A,B].Invoke (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] env, A a, B b) [0x0005a] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Core.OptimizedClosures+Invoke@3266-1[T2,T3,TResult,T1].Invoke (T2 u, T3 v) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Core.OptimizedClosures+Invoke@3253[T2,TResult,T1].Invoke (T2 u) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Paket.NuGetV2+versions@892-7.Invoke (System.String arg20) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2) [0x0001f] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Paket.NuGetV2.GetVersions (System.Boolean force, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot, System.String root, System.Collections.Generic.IEnumerable`1[T] sources, Paket.Domain+PackageName packageName) [0x000a5] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Paket.UpdateProcess+SelectiveUpdate@210.Invoke (Paket.ResolverStrategy resolverStrategy, Paket.Domain+GroupName groupName, Paket.Domain+PackageName packageName) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Core.OptimizedClosures+Invoke@3266-1[T2,T3,TResult,T1].Invoke (T2 u, T3 v) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Core.OptimizedClosures+Invoke@3253[T2,TResult,T1].Invoke (T2 u) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Paket.UpdateProcess+SelectiveUpdate@210-5.Invoke (Paket.Domain+PackageName arg30) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2) [0x0001f] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0003d] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W,X] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3, W arg4) [0x00065] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Paket.UpdateProcess.getSortedAndCachedVersionsF@15 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSortedVersionsF, System.Collections.Generic.Dictionary`2[TKey,TValue] allVersions, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.ResolverStrategy resolverStrategy, Paket.Domain+GroupName groupName, Paket.Domain+PackageName packageName) [0x0003b] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Paket.UpdateProcess+getVersionsF@126-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x0013a] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].MoveNextImpl () [0x00017] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].System-Collections-IEnumerator-MoveNext () [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Collections.SeqModule.oneStepTo@986[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i) [0x00045] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Collections.SeqModule.f@4734-2[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i, Microsoft.FSharp.Core.Unit unitVar0) [0x0001f] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Collections.SeqModule+result@1002[T].Invoke (System.Int32 i) [0x00010] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+unfold@199[b,a].DoMoveNext (b& ) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000c] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Collections.Internal+IEnumerator.next@187[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, System.Collections.Generic.IEnumerator`1[T] e, Microsoft.FSharp.Core.FSharpRef`1[T] started, Microsoft.FSharp.Core.Unit unitVar0) [0x00014] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+filter@182[T].System-Collections-IEnumerator-MoveNext () [0x00016] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Collections.SeqModule.IsEmpty[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00063] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Paket.PackageResolver.getCompatibleVersions$cont@432 (Paket.PackageResolver+ResolverStep currentStep, Paket.Domain+GroupName groupName, Paket.Requirements+PackageRequirement currentRequirement, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, System.Boolean globalOverride, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Microsoft.FSharp.Core.Unit unitVar) [0x000d3] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Paket.PackageResolver.getCompatibleVersions (Paket.PackageResolver+ResolverStep currentStep, Paket.Domain+GroupName groupName, Paket.Requirements+PackageRequirement currentRequirement, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, System.Boolean globalOverride, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives) [0x000dc] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Paket.PackageResolver.step@652 (Paket.PackageResolver+UpdateMode updateMode, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Microsoft.FSharp.Core.FSharpOption`1[T] packageFilter, System.Collections.Generic.IDictionary`2[TKey,TValue] rootSettings, Paket.PackageResolver+Stage stage, Paket.PackageResolver+StackPack stackpack, System.Collections.Generic.IEnumerable`1[T] compatibleVersions, Paket.PackageResolver+StepFlags flags) [0x00374] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Paket.PackageResolver.Resolve (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Collections.FSharpSet`1[T] rootDependencies, Paket.PackageResolver+UpdateMode updateMode) [0x00156] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at <StartupCode$Paket-Core>.$DependenciesFile+resolveGroup@173-1[b].Invoke (Paket.Domain+GroupName groupName, b _arg1) [0x000f3] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x0002a] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00014] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-04-22 21:52:20 -   at Paket.DependenciesFile.Resolve[a] (System.Boolean force, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSha1, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] groupsToResolve, Paket.PackageResolver+UpdateMode updateMode) [0x0000f] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Paket.UpdateProcess.selectiveUpdate (System.Boolean force, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSha1, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSortedVersionsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Paket.LockFile lockFile, Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode) [0x00227] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Paket.UpdateProcess.SelectiveUpdate (Paket.DependenciesFile dependenciesFile, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean force) [0x000e0] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Paket.AddProcess.add (System.Boolean installToProjects, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter) [0x00062] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Paket.AddProcess.Add (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean interactive, System.Boolean installAfter) [0x00023] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at <StartupCode$Paket-Core>.$PublicAPI+Add@146-17.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0006f] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String rootFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00084] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs) [0x00025] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-04-22 21:52:20 -   at FSI_0004.Paket.add (System.String package, System.String version) [0x00051] in <5d93af3f45d14473a73a1466133bc198>:0 
2018-04-22 21:52:20 -   at FSI_0004.Paket.Package (System.Collections.Generic.IEnumerable`1[T] list) [0x00025] in <5d93af3f45d14473a73a1466133bc198>:0 
2018-04-22 21:52:20 -   at <StartupCode$FSI_0005>.$FSI_0005.main@ () [0x00010] in <5d93af3f45d14473a73a1466133bc198>:0 
2018-04-22 21:52:20 -   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-04-22 21:52:20 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-04-22 21:52:52 - let wc = new System.Net.WebClient()
2018-04-22 21:52:52 - wc.DownloadFile(
2018-04-22 21:52:52 -     "https://download.microsoft.com/download/D/C/4/DC44E915-26FE-48AB-BD7C-AC1D92B23230/Infer.NET%202.6.zip", 
2018-04-22 21:52:52 -     "/home/nbcommon/IfSharp/bin/packages/infer.zip")
2018-04-22 21:52:53 - Expression evaluation failed: An exception occurred during a WebClient request.
2018-04-22 21:52:53 - WebExceptionAn exception occurred during a WebClient request.
2018-04-22 21:52:53 -   at System.Net.WebClient.DownloadFile (System.Uri address, System.String fileName) [0x000ad] in <2736c63206b04ee9bdd526624de6640b>:0 
2018-04-22 21:52:53 -   at System.Net.WebClient.DownloadFile (System.String address, System.String fileName) [0x00016] in <2736c63206b04ee9bdd526624de6640b>:0 
2018-04-22 21:52:53 -   at (wrapper remoting-invoke-with-check) System.Net.WebClient:DownloadFile (string,string)
2018-04-22 21:52:53 -   at <StartupCode$FSI_0006>.$FSI_0006.main@ () [0x00010] in <5d93af3f45d14473a73a1466133bc198>:0 
2018-04-22 21:52:53 -   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-04-22 21:52:53 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-04-22 21:52:53 - DirectoryNotFoundExceptionCould not find a part of the path "/home/nbcommon/IfSharp/bin/packages/infer.zip".
2018-04-22 21:52:53 -   at System.IO.FileStream..ctor (System.String path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Int32 bufferSize, System.Boolean anonymous, System.IO.FileOptions options) [0x00164] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-04-22 21:52:53 -   at System.IO.FileStream..ctor (System.String path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Int32 bufferSize, System.Boolean isAsync, System.Boolean anonymous) [0x00000] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-04-22 21:52:53 -   at System.IO.FileStream..ctor (System.String path, System.IO.FileMode mode, System.IO.FileAccess access) [0x00000] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-04-22 21:52:53 -   at (wrapper remoting-invoke-with-check) System.IO.FileStream:.ctor (string,System.IO.FileMode,System.IO.FileAccess)
2018-04-22 21:52:53 -   at System.Net.WebClient.DownloadFile (System.Uri address, System.String fileName) [0x00034] in <2736c63206b04ee9bdd526624de6640b>:0 
2018-04-22 21:57:49 - #load "Paket.Generated.Refs.fsx"
2018-04-22 21:57:50 - open System
2018-04-22 21:57:50 - open MathNet.Numerics
2018-04-22 21:57:50 - open FSharp.Data
2018-04-22 21:57:50 - type Door = Goat | Car
2018-04-22 21:57:51 - type MontyHallValue = {
2018-04-22 21:57:51 -     Value: Door
2018-04-22 21:57:51 -     Probability: float }
2018-04-22 21:57:51 - type Distribution = MontyHallValue seq
2018-04-22 21:57:51 - let uniformDistribution (values: Door seq) = 
2018-04-22 21:57:51 -     let l = float (Seq.length values)
2018-04-22 21:57:51 -     values |> Seq.map (fun v -> {Value=v; Probability = 1.0/l})
2018-04-22 21:57:51 - let certainly value = seq [{Value=value; Probability =1.0}]
2018-04-22 21:57:52 - type ProbabilisticComputation<'T> = 
2018-04-22 21:57:52 -   | Sample of Distribution * (Door -> ProbabilisticComputation<'T>)
2018-04-22 21:57:52 -   | Return of 'T   
2018-04-22 21:57:52 - type ProbabilisticComputationBuilder() = 
2018-04-22 21:57:52 -   member x.Return(v) = Return v
2018-04-22 21:57:52 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-22 21:57:52 - let prob = ProbabilisticComputationBuilder()
2018-04-22 21:57:52 - let montyHallStay = prob {
2018-04-22 21:57:52 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 21:57:52 -     return initialDoor}
2018-04-22 21:57:52 - let montyHallSwitch = prob {
2018-04-22 21:57:52 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 21:57:52 -     let! switchedDoor = 
2018-04-22 21:57:52 -         match initialDoor with
2018-04-22 21:57:52 -         | Car -> certainly Goat
2018-04-22 21:57:52 -         | Goat -> certainly Car
2018-04-22 21:57:52 -     return switchedDoor}
2018-04-22 21:57:53 - let rec enumerate values comp = seq {
2018-04-22 21:57:53 -     match comp with 
2018-04-22 21:57:53 -     | Sample(dist:Distribution,f) ->
2018-04-22 21:57:53 -         // Loop over the MontyHallValues in the Distribution
2018-04-22 21:57:53 -         for option in dist do 
2018-04-22 21:57:53 -             yield! enumerate (option::values)(f option.Value)
2018-04-22 21:57:53 -     | Return v ->
2018-04-22 21:57:53 -         // Print what's happening
2018-04-22 21:57:53 -         printfn "-----"
2018-04-22 21:57:53 -         values |> List.rev
2018-04-22 21:57:53 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-22 21:57:53 -         yield v,
2018-04-22 21:57:53 -             (1.0, values)
2018-04-22 21:57:53 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-22 21:57:53 - let summarize dist = 
2018-04-22 21:57:53 -     dist
2018-04-22 21:57:53 -     |> Seq.groupBy fst   // Want two bins: for Car & Goat
2018-04-22 21:57:53 -     |> Seq.map (fun (value, xs:('a * float) seq) ->
2018-04-22 21:57:53 -         value, xs |> Seq.sumBy snd)
2018-04-22 21:57:53 -     |> List.ofSeq
2018-04-22 21:58:07 - let wc = new System.Net.WebClient()
2018-04-22 21:58:07 - wc.DownloadFile(
2018-04-22 21:58:07 -     "https://download.microsoft.com/download/D/C/4/DC44E915-26FE-48AB-BD7C-AC1D92B23230/Infer.NET%202.7.1803.1901.zip", 
2018-04-22 21:58:07 -     "/home/nbcommon/IfSharp/bin/packages/infer.zip")
2018-04-22 21:58:07 - Expression evaluation failed: An exception occurred during a WebClient request.
2018-04-22 21:58:07 - WebExceptionAn exception occurred during a WebClient request.
2018-04-22 21:58:07 -   at System.Net.WebClient.DownloadFile (System.Uri address, System.String fileName) [0x000ad] in <2736c63206b04ee9bdd526624de6640b>:0 
2018-04-22 21:58:07 -   at System.Net.WebClient.DownloadFile (System.String address, System.String fileName) [0x00016] in <2736c63206b04ee9bdd526624de6640b>:0 
2018-04-22 21:58:07 -   at (wrapper remoting-invoke-with-check) System.Net.WebClient:DownloadFile (string,string)
2018-04-22 21:58:07 -   at <StartupCode$FSI_0007>.$FSI_0007.main@ () [0x00010] in <5d93af3f45d14473a73a1466133bc198>:0 
2018-04-22 21:58:07 -   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-04-22 21:58:07 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-04-22 21:58:07 - DirectoryNotFoundExceptionCould not find a part of the path "/home/nbcommon/IfSharp/bin/packages/infer.zip".
2018-04-22 21:58:07 -   at System.IO.FileStream..ctor (System.String path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Int32 bufferSize, System.Boolean anonymous, System.IO.FileOptions options) [0x00164] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-04-22 21:58:07 -   at System.IO.FileStream..ctor (System.String path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Int32 bufferSize, System.Boolean isAsync, System.Boolean anonymous) [0x00000] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-04-22 21:58:07 -   at System.IO.FileStream..ctor (System.String path, System.IO.FileMode mode, System.IO.FileAccess access) [0x00000] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-04-22 21:58:07 -   at (wrapper remoting-invoke-with-check) System.IO.FileStream:.ctor (string,System.IO.FileMode,System.IO.FileAccess)
2018-04-22 21:58:07 -   at System.Net.WebClient.DownloadFile (System.Uri address, System.String fileName) [0x00034] in <2736c63206b04ee9bdd526624de6640b>:0 
2018-04-22 22:03:06 - let wc = new System.Net.WebClient()
2018-04-22 22:03:06 - wc.DownloadFile(
2018-04-22 22:03:06 -     "https://download.microsoft.com/download/D/C/4/DC44E915-26FE-48AB-BD7C-AC1D92B23230/Infer.NET%202.7.1803.1901.zip", 
2018-04-22 22:03:06 -     "/home/nbuser/IfSharp/bin/packages/infer.zip")
2018-04-22 22:03:25 - open System.Diagnostics
2018-04-22 22:03:25 - let ps = 
2018-04-22 22:03:25 -     ProcessStartInfo(
2018-04-22 22:03:25 -         FileName="unzip", 
2018-04-22 22:03:25 -         Arguments="/home/nbuser/IfSharp/bin/packages/infer.zip -d /home/nbuser/IfSharp/bin/packages/infer",
2018-04-22 22:03:25 -         RedirectStandardOutput=true,UseShellExecute=false)
2018-04-22 22:03:25 - let p = Process.Start(ps)
2018-04-22 22:03:25 - p.StandardOutput.ReadToEnd()
2018-04-22 22:03:58 - open System.Diagnostics
2018-04-22 22:03:58 - let ps = 
2018-04-22 22:03:58 -     ProcessStartInfo(
2018-04-22 22:03:58 -         FileName="unzip", 
2018-04-22 22:03:58 -         Arguments="/home/nbuser/IfSharp/bin/packages/infer.zip -d /home/nbuser/IfSharp/bin/packages/infer",
2018-04-22 22:03:58 -         RedirectStandardOutput=true,UseShellExecute=false)
2018-04-22 22:03:58 - let p = Process.Start(ps)
2018-04-22 22:03:58 - p.StandardOutput.ReadToEnd()
2018-04-22 22:04:11 - #r "/home/nbcommon/IfSharp/bin/packages/infer/Bin/Infer.FSharp.dll"
2018-04-22 22:04:11 - Unable to find the file '/home/nbcommon/IfSharp/bin/packages/infer/Bin/Infer.FSharp.dll' in any of
2018-04-22 22:04:11 -  /usr/lib/mono/4.5
2018-04-22 22:04:11 -  /usr/lib/mono/4.5/Facades
2018-04-22 22:04:11 -  /home/nbuser/IfSharp/bin
2018-04-22 22:04:11 -  /home/nbuser/library
2018-04-22 22:04:11 -  /home/nbuser/IfSharp/bin/
2018-04-22 22:04:19 - #r "/home/nbuser/IfSharp/bin/packages/infer/Bin/Infer.FSharp.dll"
2018-04-22 22:04:41 - open System
2018-04-22 22:04:41 - open MicrosoftResearch.Infer
2018-04-22 22:04:41 - open MicrosoftResearch.Infer.FSharp
2018-04-22 22:04:43 - [<ReflectedDefinition>]
2018-04-22 22:04:43 - let mystery (): bool*bool =
2018-04-22 22:04:43 -   let aliceDunnit = random (Bernoulli 0.30)
2018-04-22 22:04:43 -   let withGun = if aliceDunnit then random (Bernoulli 0.03) else random (Bernoulli 0.80)
2018-04-22 22:04:43 -   aliceDunnit, withGun
2018-04-22 22:04:43 - The value or constructor 'random' is not defined. Maybe you want one of the following:
2018-04-22 22:04:43 -    Random
2018-04-22 22:04:43 - The value or constructor 'random' is not defined. Maybe you want one of the following:
2018-04-22 22:04:43 -    Random
2018-04-22 22:04:43 - The value or constructor 'random' is not defined. Maybe you want one of the following:
2018-04-22 22:04:43 -    Random
2018-04-22 22:05:15 - open MicrosoftResearch.Infer.Distributions
2018-04-22 22:05:15 - The namespace 'Distributions' is not defined.
2018-04-22 22:05:17 - [<ReflectedDefinition>]
2018-04-22 22:05:17 - let mystery (): bool*bool =
2018-04-22 22:05:17 -   let aliceDunnit = random (Bernoulli 0.30)
2018-04-22 22:05:17 -   let withGun = if aliceDunnit then random (Bernoulli 0.03) else random (Bernoulli 0.80)
2018-04-22 22:05:17 -   aliceDunnit, withGun
2018-04-22 22:05:18 - The value or constructor 'random' is not defined. Maybe you want one of the following:
2018-04-22 22:05:18 -    Random
2018-04-22 22:05:18 - The value or constructor 'random' is not defined. Maybe you want one of the following:
2018-04-22 22:05:18 -    Random
2018-04-22 22:05:18 - The value or constructor 'random' is not defined. Maybe you want one of the following:
2018-04-22 22:05:18 -    Random
2018-04-22 22:35:05 - #load "Paket.Generated.Refs.fsx"
2018-04-22 22:35:05 - open System
2018-04-22 22:35:05 - open MathNet.Numerics
2018-04-22 22:35:05 - open FSharp.Data
2018-04-22 22:35:05 - type Door = Goat | Car
2018-04-22 22:35:06 - type MontyHallValue = {
2018-04-22 22:35:06 -     Value: Door
2018-04-22 22:35:06 -     Probability: float }
2018-04-22 22:35:06 - type Distribution = MontyHallValue seq
2018-04-22 22:35:06 - let uniformDistribution (values: Door seq) = 
2018-04-22 22:35:06 -     let l = float (Seq.length values)
2018-04-22 22:35:06 -     values |> Seq.map (fun v -> {Value=v; Probability = 1.0/l})
2018-04-22 22:35:06 - let certainly value = seq [{Value=value; Probability =1.0}]
2018-04-22 22:35:06 - type ProbabilisticComputation<'T> = 
2018-04-22 22:35:06 -   | Sample of Distribution * (Door -> ProbabilisticComputation<'T>)
2018-04-22 22:35:06 -   | Return of 'T   
2018-04-22 22:35:06 - type ProbabilisticComputationBuilder() = 
2018-04-22 22:35:06 -   member x.Return(v) = Return v
2018-04-22 22:35:06 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-22 22:35:07 - let prob = ProbabilisticComputationBuilder()
2018-04-22 22:35:07 - let montyHallStay = prob {
2018-04-22 22:35:07 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 22:35:07 -     return initialDoor}
2018-04-22 22:35:07 - let montyHallSwitch = prob {
2018-04-22 22:35:07 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-22 22:35:07 -     let! switchedDoor = 
2018-04-22 22:35:07 -         match initialDoor with
2018-04-22 22:35:07 -         | Car -> certainly Goat
2018-04-22 22:35:07 -         | Goat -> certainly Car
2018-04-22 22:35:07 -     return switchedDoor}
2018-04-22 22:35:07 - let rec enumerate values comp = seq {
2018-04-22 22:35:07 -     match comp with 
2018-04-22 22:35:07 -     | Sample(dist:Distribution,f) ->
2018-04-22 22:35:07 -         // Loop over the MontyHallValues in the Distribution
2018-04-22 22:35:07 -         for option in dist do 
2018-04-22 22:35:07 -             yield! enumerate (option::values)(f option.Value)
2018-04-22 22:35:07 -     | Return v ->
2018-04-22 22:35:07 -         // Print what's happening
2018-04-22 22:35:07 -         printfn "-----"
2018-04-22 22:35:07 -         values |> List.rev
2018-04-22 22:35:07 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-22 22:35:07 -         yield v,
2018-04-22 22:35:07 -             (1.0, values)
2018-04-22 22:35:07 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-22 22:35:07 - let summarize dist = 
2018-04-22 22:35:07 -     dist
2018-04-22 22:35:07 -     |> Seq.groupBy fst   // Want two bins: for Car & Goat
2018-04-22 22:35:07 -     |> Seq.map (fun (value, xs:('a * float) seq) ->
2018-04-22 22:35:07 -         value, xs |> Seq.sumBy snd)
2018-04-22 22:35:07 -     |> List.ofSeq
2018-04-22 22:35:09 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-22 22:41:07 - // include directory, this will be replaced by the kernel
2018-04-22 22:41:07 - #I "/home/nbuser/IfSharp/bin"
2018-04-22 22:41:07 - // load base dlls
2018-04-22 22:41:07 - #r "IfSharp.Kernel.dll"
2018-04-22 22:41:07 - #r "NetMQ.dll"
2018-04-22 22:41:07 - // open the global functions and methods
2018-04-22 22:41:07 - open IfSharp.Kernel
2018-04-22 22:41:07 - open IfSharp.Kernel.Globals
2018-04-22 22:41:22 - F# Interactive for F# 4.1
2018-04-22 22:41:22 - Freely distributed under the Apache 2.0 Open Source License
2018-04-22 22:41:22 - For help type #help;;
2018-04-22 22:41:22 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-22 22:41:22 -   seq []
2018-04-22 22:41:22 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-22 22:41:22 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-22 22:41:22 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-22 22:41:28 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-23 15:05:39 - // include directory, this will be replaced by the kernel
2018-04-23 15:05:39 - #I "/home/nbuser/IfSharp/bin"
2018-04-23 15:05:39 - // load base dlls
2018-04-23 15:05:39 - #r "IfSharp.Kernel.dll"
2018-04-23 15:05:39 - #r "NetMQ.dll"
2018-04-23 15:05:39 - // open the global functions and methods
2018-04-23 15:05:39 - open IfSharp.Kernel
2018-04-23 15:05:39 - open IfSharp.Kernel.Globals
2018-04-23 15:05:49 - F# Interactive for F# 4.1
2018-04-23 15:05:49 - Freely distributed under the Apache 2.0 Open Source License
2018-04-23 15:05:49 - For help type #help;;
2018-04-23 15:05:49 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-23 15:05:49 -   seq []
2018-04-23 15:05:49 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-23 15:05:49 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-23 15:05:49 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-23 15:05:50 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-23 15:07:55 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-23 19:25:29 - // include directory, this will be replaced by the kernel
2018-04-23 19:25:29 - #I "/home/nbuser/IfSharp/bin"
2018-04-23 19:25:29 - // load base dlls
2018-04-23 19:25:29 - #r "IfSharp.Kernel.dll"
2018-04-23 19:25:29 - #r "NetMQ.dll"
2018-04-23 19:25:29 - // open the global functions and methods
2018-04-23 19:25:29 - open IfSharp.Kernel
2018-04-23 19:25:29 - open IfSharp.Kernel.Globals
2018-04-23 19:25:40 - F# Interactive for F# 4.1
2018-04-23 19:25:40 - Freely distributed under the Apache 2.0 Open Source License
2018-04-23 19:25:40 - For help type #help;;
2018-04-23 19:25:40 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-23 19:25:40 -   seq []
2018-04-23 19:25:40 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-23 19:25:40 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-23 19:25:40 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-23 19:25:40 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-23 19:40:02 - Paket.Package
2018-04-23 19:40:02 -   [ "MathNet.Numerics"
2018-04-23 19:40:02 -     "MathNet.Numerics.FSharp"
2018-04-23 19:40:02 -     "FSharp.Data"
2018-04-23 19:40:02 -   ]
2018-04-23 19:40:03 - The value, namespace, type or module 'Paket' is not defined.
2018-04-23 19:40:06 - #load "Paket.fsx"
2018-04-23 19:40:09 - Paket.Package
2018-04-23 19:40:09 -   [ "MathNet.Numerics"
2018-04-23 19:40:09 -     "MathNet.Numerics.FSharp"
2018-04-23 19:40:09 -     "FSharp.Data"
2018-04-23 19:40:09 -   ]
2018-04-23 19:40:28 - #load "Paket.Generated.Refs.fsx"
2018-04-23 19:41:52 - // On Azure, use the terminal window to find these files in ~/IfSharp/bin/
2018-04-23 19:41:52 - #r "packages/MathNet.Numerics/lib/net40/MathNet.Numerics.dll"
2018-04-23 19:41:52 - #r "packages/FSharp.Data/lib/net45/FSharp.Data.dll"
2018-04-23 20:50:29 - // include directory, this will be replaced by the kernel
2018-04-23 20:50:29 - #I "/home/nbuser/IfSharp/bin"
2018-04-23 20:50:29 - // load base dlls
2018-04-23 20:50:29 - #r "IfSharp.Kernel.dll"
2018-04-23 20:50:29 - #r "NetMQ.dll"
2018-04-23 20:50:29 - // open the global functions and methods
2018-04-23 20:50:29 - open IfSharp.Kernel
2018-04-23 20:50:29 - open IfSharp.Kernel.Globals
2018-04-23 20:50:42 - F# Interactive for F# 4.1
2018-04-23 20:50:42 - Freely distributed under the Apache 2.0 Open Source License
2018-04-23 20:50:42 - For help type #help;;
2018-04-23 20:50:42 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-23 20:50:42 -   seq []
2018-04-23 20:50:42 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-23 20:50:42 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-23 20:50:42 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-23 20:50:48 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-23 20:51:20 - // include directory, this will be replaced by the kernel
2018-04-23 20:51:20 - #I "/home/nbuser/IfSharp/bin"
2018-04-23 20:51:20 - // load base dlls
2018-04-23 20:51:20 - #r "IfSharp.Kernel.dll"
2018-04-23 20:51:20 - #r "NetMQ.dll"
2018-04-23 20:51:20 - // open the global functions and methods
2018-04-23 20:51:20 - open IfSharp.Kernel
2018-04-23 20:51:20 - open IfSharp.Kernel.Globals
2018-04-23 20:51:36 - F# Interactive for F# 4.1
2018-04-23 20:51:36 - Freely distributed under the Apache 2.0 Open Source License
2018-04-23 20:51:36 - For help type #help;;
2018-04-23 20:51:36 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-23 20:51:36 -   seq []
2018-04-23 20:51:36 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-23 20:51:36 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-23 20:51:36 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-23 20:51:36 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-23 20:52:27 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-23 20:59:23 - type 'a Outcome = {
2018-04-23 20:59:23 -     Value: 'a
2018-04-23 20:59:23 -     Probability : Double  }
2018-04-23 20:59:23 - The type 'Double' is not defined. Maybe you want one of the following:
2018-04-23 20:59:23 -    double
2018-04-23 20:59:23 - The type 'Double' is not defined. Maybe you want one of the following:
2018-04-23 20:59:23 -    double
2018-04-23 20:59:30 - type 'a Outcome = {
2018-04-23 20:59:30 -     Value: 'a
2018-04-23 20:59:30 -     Probability : double  }
2018-04-23 21:00:20 - type Distribution<'a> = Outcome<'a> seq
2018-04-23 21:00:58 - // P(A AND B) = P(A | B) * P(B)
2018-04-23 21:00:58 - let bindD (dist: Distribution<'b>) (f: 'b -> Distribution<'a >) =
2018-04-23 21:00:58 -     dist 
2018-04-23 21:00:58 -         |> Seq.map (fun p1 -> 
2018-04-23 21:00:58 -                 f p1.Value
2018-04-23 21:00:58 -                 |> Seq.map (fun p2 -> 
2018-04-23 21:00:58 -                         { Value = p2.Value; 
2018-04-23 21:00:58 -                             Probability = 
2018-04-23 21:00:58 -                               p1.Probability * p2.Probability}))
2018-04-23 21:00:58 -         |> Seq.concat : Distribution<'a >
2018-04-23 21:01:23 - let returnD (value:'a) : Distribution<'a > =   
2018-04-23 21:01:23 -     Seq.singleton { Value = value ; Probability = 1N/1N }
2018-04-23 21:01:23 - This numeric literal requires that a module 'NumericLiteralN' defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope
2018-04-23 21:01:23 - This numeric literal requires that a module 'NumericLiteralN' defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope
2018-04-23 21:02:13 - let returnD (value:'a) : Distribution<'a > =   
2018-04-23 21:02:13 -     Seq.singleton { Value = value ; Probability = 1.0 }
2018-04-23 21:02:17 - type DistributionMonadBuilder() =
2018-04-23 21:02:17 -     member this.Bind (r, f) = bindD r f
2018-04-23 21:02:17 -     member this.Return x = returnD x
2018-04-23 21:02:17 -     member this.ReturnFrom m = m
2018-04-23 21:02:18 - let distribution = DistributionMonadBuilder()type 'a Outcome = {
2018-04-23 21:02:18 -     Value: 'a
2018-04-23 21:02:18 -     Probability : BigRational  }
2018-04-23 21:02:19 - Unexpected keyword 'type' in binding. Expected incomplete structured construct at or before this point or other token.
2018-04-23 21:02:19 - Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.
2018-04-23 21:02:19 - Possible incorrect indentation: this token is offside of context started at position (1:46). Try indenting this token further or using standard formatting conventions.
2018-04-23 21:02:19 - Possible incorrect indentation: this token is offside of context started at position (1:46). Try indenting this token further or using standard formatting conventions.
2018-04-23 21:02:19 - Possible incorrect indentation: this token is offside of context started at position (1:46). Try indenting this token further or using standard formatting conventions.
2018-04-23 21:02:19 - Possible incorrect indentation: this token is offside of context started at position (1:46). Try indenting this token further or using standard formatting conventions.
2018-04-23 21:02:19 - Incomplete structured construct at or before this point in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2018-04-23 21:02:19 - parse error
2018-04-23 21:03:07 - let distribution = DistributionMonadBuilder()
2018-04-24 13:40:51 - // include directory, this will be replaced by the kernel
2018-04-24 13:40:51 - #I "/home/nbuser/IfSharp/bin"
2018-04-24 13:40:51 - // load base dlls
2018-04-24 13:40:51 - #r "IfSharp.Kernel.dll"
2018-04-24 13:40:51 - #r "NetMQ.dll"
2018-04-24 13:40:51 - // open the global functions and methods
2018-04-24 13:40:51 - open IfSharp.Kernel
2018-04-24 13:40:51 - open IfSharp.Kernel.Globals
2018-04-24 13:41:11 - F# Interactive for F# 4.1
2018-04-24 13:41:11 - Freely distributed under the Apache 2.0 Open Source License
2018-04-24 13:41:11 - For help type #help;;
2018-04-24 13:41:11 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-24 13:41:11 -   seq []
2018-04-24 13:41:11 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-24 13:41:11 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-24 13:41:11 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-24 13:41:22 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-24 14:08:54 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-24 14:09:27 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-24 15:29:39 - #load "Paket.Generated.Refs.fsx"
2018-04-24 15:29:39 - Could not load file '/home/nbuser/IfSharp/bin/.paket/load/main.group.fsx' because it does not exist or is inaccessible
2018-04-24 15:29:39 - open System
2018-04-24 15:29:39 - open MathNet.Numerics
2018-04-24 15:29:39 - open FSharp.Data
2018-04-24 15:29:40 - The namespace or module 'MathNet' is not defined. Maybe you want one of the following:
2018-04-24 15:29:40 -    Math
2018-04-24 15:29:40 - type Door = Goat | Car
2018-04-24 15:29:41 - type MontyHallValue = {
2018-04-24 15:29:41 -     Value: Door
2018-04-24 15:29:41 -     Probability: float }
2018-04-24 15:29:41 - type Distribution = MontyHallValue seq
2018-04-24 15:29:41 - let uniformDistribution (values: Door seq) = 
2018-04-24 15:29:41 -     let l = float (Seq.length values)
2018-04-24 15:29:41 -     values |> Seq.map (fun v -> {Value=v; Probability = 1.0/l})
2018-04-24 15:29:41 - let certainly value = seq [{Value=value; Probability =1.0}]
2018-04-24 15:29:42 - type ProbabilisticComputation<'T> = 
2018-04-24 15:29:42 -   | Sample of Distribution * (Door -> ProbabilisticComputation<'T>)
2018-04-24 15:29:42 -   | Return of 'T   
2018-04-24 15:29:42 - type ProbabilisticComputationBuilder() = 
2018-04-24 15:29:42 -   member x.Return(v) = Return v
2018-04-24 15:29:42 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-24 15:29:42 - let prob = ProbabilisticComputationBuilder()
2018-04-24 15:29:42 - let montyHallStay = prob {
2018-04-24 15:29:42 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-24 15:29:42 -     return initialDoor}
2018-04-24 15:29:42 - let montyHallSwitch = prob {
2018-04-24 15:29:42 -     let! initialDoor = uniformDistribution [Car;Goat;Goat]
2018-04-24 15:29:42 -     let! switchedDoor = 
2018-04-24 15:29:42 -         match initialDoor with
2018-04-24 15:29:42 -         | Car -> certainly Goat
2018-04-24 15:29:42 -         | Goat -> certainly Car
2018-04-24 15:29:42 -     return switchedDoor}
2018-04-24 15:29:43 - let rec enumerate values comp = seq {
2018-04-24 15:29:43 -     match comp with 
2018-04-24 15:29:43 -     | Sample(dist:Distribution,f) ->
2018-04-24 15:29:43 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 15:29:43 -         for option in dist do 
2018-04-24 15:29:43 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 15:29:43 -     | Return v ->
2018-04-24 15:29:43 -         // Print what's happening
2018-04-24 15:29:43 -         printfn "-----"
2018-04-24 15:29:43 -         values |> List.rev
2018-04-24 15:29:43 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 15:29:43 -         yield v,
2018-04-24 15:29:43 -             (1.0, values)
2018-04-24 15:29:43 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 15:29:43 - let summarize dist = 
2018-04-24 15:29:43 -     dist
2018-04-24 15:29:43 -     |> Seq.groupBy fst   // Want two bins: for Car & Goat
2018-04-24 15:29:43 -     |> Seq.map (fun (value, xs:('a * float) seq) ->
2018-04-24 15:29:43 -         value, xs |> Seq.sumBy snd)
2018-04-24 15:29:43 -     |> List.ofSeq
2018-04-24 15:29:55 - type(resultStay)
2018-04-24 15:29:55 - Unexpected identifier in type name. Expected infix operator, quote symbol or other token.
2018-04-24 15:29:55 - parse error
2018-04-24 15:30:13 - let resultStay = enumerate [] montyHallStay |> summarize
2018-04-24 15:30:16 - resultStay
2018-04-24 15:30:45 - resultSwitch
2018-04-24 15:30:45 - The value or constructor 'resultSwitch' is not defined. Maybe you want one of the following:
2018-04-24 15:30:45 -    Result
2018-04-24 15:30:45 -    resultStay
2018-04-24 15:30:49 - let resultSwitch = enumerate [] montyHallSwitch |> summarize
2018-04-24 15:30:53 - resultSwitch
2018-04-24 15:33:02 - enumerate [] montyHallStay
2018-04-24 15:42:44 - let rec enumerate values comp = seq {
2018-04-24 15:42:44 -     match comp with 
2018-04-24 15:42:44 -     | Sample(dist:Distribution,f) ->
2018-04-24 15:42:44 -         printfn "comp is a Sample!"
2018-04-24 15:42:44 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 15:42:44 -         for option in dist do 
2018-04-24 15:42:44 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 15:42:44 -     | Return v ->
2018-04-24 15:42:44 -         // Print what's happening
2018-04-24 15:42:44 -         printfn "comp is a value"
2018-04-24 15:42:44 -         printfn "-----"
2018-04-24 15:42:44 -         values |> List.rev
2018-04-24 15:42:44 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 15:42:44 -         yield v,
2018-04-24 15:42:44 -             (1.0, values)
2018-04-24 15:42:44 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 15:42:45 - enumerate [] montyHallStay
2018-04-24 15:43:41 - let rec enumerate values comp = seq {
2018-04-24 15:43:41 -     match comp with 
2018-04-24 15:43:41 -     | Sample(dist:Distribution,f) ->
2018-04-24 15:43:41 -         printfn "comp is a Sample, with Distribution %A" + dist
2018-04-24 15:43:41 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 15:43:41 -         for option in dist do 
2018-04-24 15:43:41 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 15:43:41 -     | Return v ->
2018-04-24 15:43:41 -         // Print what's happening
2018-04-24 15:43:41 -         printfn "comp is a value"
2018-04-24 15:43:41 -         printfn "-----"
2018-04-24 15:43:41 -         values |> List.rev
2018-04-24 15:43:41 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 15:43:41 -         yield v,
2018-04-24 15:43:41 -             (1.0, values)
2018-04-24 15:43:41 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 15:43:41 - Expecting a type supporting the operator '+' but given a function type. You may be missing an argument to a function.
2018-04-24 15:43:41 - The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.
2018-04-24 15:44:05 - let rec enumerate values comp = seq {
2018-04-24 15:44:05 -     match comp with 
2018-04-24 15:44:05 -     | Sample(dist:Distribution,f) ->
2018-04-24 15:44:05 -         printfn "comp is a Sample, with Distribution %A", dist
2018-04-24 15:44:05 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 15:44:05 -         for option in dist do 
2018-04-24 15:44:05 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 15:44:05 -     | Return v ->
2018-04-24 15:44:05 -         // Print what's happening
2018-04-24 15:44:05 -         printfn "comp is a value"
2018-04-24 15:44:05 -         printfn "-----"
2018-04-24 15:44:05 -         values |> List.rev
2018-04-24 15:44:05 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 15:44:05 -         yield v,
2018-04-24 15:44:05 -             (1.0, values)
2018-04-24 15:44:05 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 15:44:05 - The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.
2018-04-24 15:44:05 - enumerate [] montyHallStay
2018-04-24 15:44:38 - let rec enumerate values comp = seq {
2018-04-24 15:44:38 -     match comp with 
2018-04-24 15:44:38 -     | Sample(dist:Distribution,f) ->
2018-04-24 15:44:38 -         printfn "comp is a Sample, with Distribution %A", dist |> ignore
2018-04-24 15:44:38 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 15:44:38 -         for option in dist do 
2018-04-24 15:44:38 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 15:44:38 -     | Return v ->
2018-04-24 15:44:38 -         // Print what's happening
2018-04-24 15:44:38 -         printfn "comp is a value"
2018-04-24 15:44:38 -         printfn "-----"
2018-04-24 15:44:38 -         values |> List.rev
2018-04-24 15:44:38 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 15:44:38 -         yield v,
2018-04-24 15:44:38 -             (1.0, values)
2018-04-24 15:44:38 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 15:44:38 - The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.
2018-04-24 15:44:39 - enumerate [] montyHallStay
2018-04-24 15:45:02 - let rec enumerate values comp = seq {
2018-04-24 15:45:02 -     match comp with 
2018-04-24 15:45:02 -     | Sample(dist:Distribution,f) ->
2018-04-24 15:45:02 -         printfn "comp is a Sample"//, with Distribution %A", dist |> ignore
2018-04-24 15:45:02 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 15:45:02 -         for option in dist do 
2018-04-24 15:45:02 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 15:45:02 -     | Return v ->
2018-04-24 15:45:02 -         // Print what's happening
2018-04-24 15:45:02 -         printfn "comp is a value"
2018-04-24 15:45:02 -         printfn "-----"
2018-04-24 15:45:02 -         values |> List.rev
2018-04-24 15:45:02 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 15:45:02 -         yield v,
2018-04-24 15:45:02 -             (1.0, values)
2018-04-24 15:45:02 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 15:45:06 - enumerate [] montyHallStay
2018-04-24 15:46:08 - let rec enumerate values comp = seq {
2018-04-24 15:46:08 -     match comp with 
2018-04-24 15:46:08 -     | Sample(dist:Distribution,f) ->
2018-04-24 15:46:08 -         printfn "comp is a Sample"//, with Distribution %A", dist |> ignore
2018-04-24 15:46:08 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 15:46:08 -         for option in dist do 
2018-04-24 15:46:08 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 15:46:08 -     | Return v ->
2018-04-24 15:46:08 -         // Print what's happening
2018-04-24 15:46:08 -         //printfn "comp is a value"
2018-04-24 15:46:08 -         printfn "-----"
2018-04-24 15:46:08 -         values |> List.rev
2018-04-24 15:46:08 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 15:46:08 -         yield v,
2018-04-24 15:46:08 -             (1.0, values)
2018-04-24 15:46:08 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 15:46:10 - enumerate [] montyHallStay
2018-04-24 15:47:48 - let rec enumerate values comp = seq {
2018-04-24 15:47:48 -     match comp with 
2018-04-24 15:47:48 -     | Sample(dist:Distribution,f) ->
2018-04-24 15:47:48 -         printfn "comp is a Sample"
2018-04-24 15:47:48 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 15:47:48 -         for option in dist do 
2018-04-24 15:47:48 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 15:47:48 -     | Return v ->
2018-04-24 15:47:48 -         // Print what's happening
2018-04-24 15:47:48 -         //printfn "comp is a value"
2018-04-24 15:47:48 -         printfn "-----"
2018-04-24 15:47:48 -         values |> List.rev
2018-04-24 15:47:48 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 15:47:48 -         yield v,
2018-04-24 15:47:48 -             (1.0, values)
2018-04-24 15:47:48 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 15:48:04 - enumerate.GetType()
2018-04-24 15:48:51 - typeof<enumerate.
2018-04-24 15:48:52 - Missing qualification after '.'
2018-04-24 15:48:55 - typeof<enumerate>
2018-04-24 15:48:55 - The type 'enumerate' is not defined.
2018-04-24 15:49:13 - typeof<enumerate>
2018-04-24 15:49:13 - The type 'enumerate' is not defined.
2018-04-24 15:49:56 - enumerate.GetType().FullName
2018-04-24 15:50:15 - enumerate.GetType()
2018-04-24 15:52:12 - val enumerate :
2018-04-24 15:52:12 -   values:MontyHallValue list ->
2018-04-24 15:52:12 -     comp:ProbabilisticComputation<'a> -> seq<'a * float>
2018-04-24 15:52:13 - Unexpected keyword 'val' in interaction
2018-04-24 15:52:13 - parse error
2018-04-24 16:54:43 - let rec enumerate values comp = seq {
2018-04-24 16:54:43 -     match comp with 
2018-04-24 16:54:43 -     | Sample(dist:Distribution,f) ->
2018-04-24 16:54:43 -         printfn "============ comp is a Sample"
2018-04-24 16:54:43 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 16:54:43 -         for option in dist do 
2018-04-24 16:54:43 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 16:54:43 -     | Return v ->
2018-04-24 16:54:43 -         // Print what's happening
2018-04-24 16:54:43 -         //printfn "comp is a value"
2018-04-24 16:54:43 -         printfn "-----"
2018-04-24 16:54:43 -         values |> List.rev
2018-04-24 16:54:43 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 16:54:43 -         yield v,
2018-04-24 16:54:43 -             (1.0, values)
2018-04-24 16:54:43 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 16:54:43 - enumerate [] montyHallStay
2018-04-24 16:55:21 - let rec enumerate values comp = seq {
2018-04-24 16:55:21 -     match comp with 
2018-04-24 16:55:21 -     | Sample(dist:Distribution,f) ->
2018-04-24 16:55:21 -         printfn "============ comp is a Sample"
2018-04-24 16:55:21 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 16:55:21 -         for option in dist do 
2018-04-24 16:55:21 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 16:55:21 -     | Return v ->
2018-04-24 16:55:21 -         // Print what's happening
2018-04-24 16:55:21 -         //printfn "comp is a value"
2018-04-24 16:55:21 -         values |> List.rev
2018-04-24 16:55:21 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 16:55:21 -         yield v,
2018-04-24 16:55:21 -             (1.0, values)
2018-04-24 16:55:21 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 16:55:24 - let rec enumerate values comp = seq {
2018-04-24 16:55:24 -     match comp with 
2018-04-24 16:55:24 -     | Sample(dist:Distribution,f) ->
2018-04-24 16:55:24 -         printfn "============ comp is a Sample"
2018-04-24 16:55:24 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 16:55:24 -         for option in dist do 
2018-04-24 16:55:24 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 16:55:24 -     | Return v ->
2018-04-24 16:55:24 -         // Print what's happening
2018-04-24 16:55:24 -         values |> List.rev
2018-04-24 16:55:24 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 16:55:24 -         yield v,
2018-04-24 16:55:24 -             (1.0, values)
2018-04-24 16:55:24 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 16:55:27 - enumerate [] montyHallStay
2018-04-24 16:57:11 - let rec enumerate values comp = seq {
2018-04-24 16:57:11 -     match comp with 
2018-04-24 16:57:11 -     | Sample (dist:Distribution,f) ->
2018-04-24 16:57:11 -         printfn "============ comp is a Sample"
2018-04-24 16:57:11 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 16:57:11 -         for option in dist do 
2018-04-24 16:57:11 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 16:57:11 -     | Return v ->
2018-04-24 16:57:11 -         // Print what's happening
2018-04-24 16:57:11 -         values |> List.rev
2018-04-24 16:57:11 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 16:57:11 -         yield v,
2018-04-24 16:57:11 -             (1.0, values)
2018-04-24 16:57:11 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 16:57:15 - enumerate [] montyHallStay
2018-04-24 16:58:10 - let rec enumerate values comp = seq {
2018-04-24 16:58:10 -     match comp with 
2018-04-24 16:58:10 -     | Sample (dist:Distribution,f) ->
2018-04-24 16:58:10 -         printfn "============ comp is a Sample"
2018-04-24 16:58:10 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 16:58:10 -         for option in dist do 
2018-04-24 16:58:10 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 16:58:10 -     | Return v ->
2018-04-24 16:58:10 -         printfn "v is %A" v
2018-04-24 16:58:10 -         // Print what's happening
2018-04-24 16:58:10 -         values |> List.rev
2018-04-24 16:58:10 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 16:58:10 -         yield v,
2018-04-24 16:58:10 -             (1.0, values)
2018-04-24 16:58:10 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 16:58:14 - enumerate [] montyHallStay
2018-04-24 16:59:12 - let rec enumerate values comp = seq {
2018-04-24 16:59:12 -     match comp with 
2018-04-24 16:59:12 -     | Sample (dist:Distribution,f) ->
2018-04-24 16:59:12 -         printfn "============ comp is a Sample"
2018-04-24 16:59:12 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 16:59:12 -         for option in dist do 
2018-04-24 16:59:12 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 16:59:12 -     | Return (v:Door) ->
2018-04-24 16:59:12 -         printfn "v is %A" v
2018-04-24 16:59:12 -         // Print what's happening
2018-04-24 16:59:12 -         values |> List.rev
2018-04-24 16:59:12 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 16:59:12 -         yield v,
2018-04-24 16:59:12 -             (1.0, values)
2018-04-24 16:59:12 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 17:04:12 - let rec enumerate values comp = seq {
2018-04-24 17:04:12 -     match comp with 
2018-04-24 17:04:12 -     | Sample (dist:Distribution,f) ->
2018-04-24 17:04:12 -         printfn "============ comp is a Sample"
2018-04-24 17:04:12 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 17:04:12 -         for option in dist do 
2018-04-24 17:04:12 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 17:04:12 -     | Return (v:Door) ->
2018-04-24 17:04:12 -         // Print what's happening
2018-04-24 17:04:12 -         values |> List.rev
2018-04-24 17:04:12 -         |> List.iteri (fun i mh -> printfn "%d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 17:04:12 -         // Yield a tuple with the outcome (Car/Goat) & it's probability
2018-04-24 17:04:12 -         yield v,
2018-04-24 17:04:12 -             (1.0, values)
2018-04-24 17:04:12 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 17:04:14 - let summarize dist = 
2018-04-24 17:04:14 -     dist
2018-04-24 17:04:14 -     |> Seq.groupBy fst   // Want two bins: for Car & Goat
2018-04-24 17:04:14 -     |> Seq.map (fun (value, xs:('a * float) seq) ->
2018-04-24 17:04:14 -         value, xs |> Seq.sumBy snd)
2018-04-24 17:04:14 -     |> List.ofSeq
2018-04-24 17:04:20 - enumerate [] montyHallStay
2018-04-24 17:04:43 - let resultStay = enumerate [] montyHallStay |> summarize
2018-04-24 17:05:31 - let resultStay = (enumerate [] montyHallStay) |> summarize
2018-04-24 17:05:49 - enumerate [] montyHallStay
2018-04-24 17:05:55 - let resultStay = enumerate [] montyHallStay |> summarize
2018-04-24 17:06:07 - resultStay
2018-04-24 17:06:09 - let resultSwitch = enumerate [] montyHallSwitch |> summarize
2018-04-24 17:07:51 - let resultStay = enumerate [] montyHallStay |> summarize
2018-04-24 17:09:29 - seq [(Car, 0.3333333333); (Goat, 0.3333333333); (Goat, 0.3333333333)]
2018-04-24 17:09:48 - (seq [(Car, 0.3333333333); (Goat, 0.3333333333); (Goat, 0.3333333333)]).GetType()
2018-04-24 17:15:07 - let rec enumerate values comp = seq {
2018-04-24 17:15:07 -     match comp with 
2018-04-24 17:15:07 -     | Sample (dist:Distribution,f) ->
2018-04-24 17:15:07 -         printfn "============ ProbabilisticComputation is a Sample"
2018-04-24 17:15:07 -         // Loop over the MontyHallValues in the Distribution
2018-04-24 17:15:07 -         for option in dist do 
2018-04-24 17:15:07 -             yield! enumerate (option::values)(f option.Value)
2018-04-24 17:15:07 -     | Return (v:Door) ->
2018-04-24 17:15:07 -         // Print what's happening
2018-04-24 17:15:07 -         values |> List.rev
2018-04-24 17:15:07 -         |> List.iteri (fun i mh -> printfn "PC is a Return %d: %A(%f)" (i+1) mh.Value mh.Probability)
2018-04-24 17:15:07 -         // Yield a tuple with the outcome (Car/Goat) & it's probability
2018-04-24 17:15:07 -         yield v,
2018-04-24 17:15:07 -             (1.0, values)
2018-04-24 17:15:07 -             ||> List.fold (fun acc x -> acc * x.Probability)}
2018-04-24 17:15:10 - enumerate [] montyHallStay
2018-04-24 17:36:45 - // include directory, this will be replaced by the kernel
2018-04-24 17:36:45 - #I "/home/nbuser/IfSharp/bin"
2018-04-24 17:36:45 - // load base dlls
2018-04-24 17:36:45 - #r "IfSharp.Kernel.dll"
2018-04-24 17:36:45 - #r "NetMQ.dll"
2018-04-24 17:36:45 - // open the global functions and methods
2018-04-24 17:36:45 - open IfSharp.Kernel
2018-04-24 17:36:45 - open IfSharp.Kernel.Globals
2018-04-24 17:37:06 - F# Interactive for F# 4.1
2018-04-24 17:37:06 - Freely distributed under the Apache 2.0 Open Source License
2018-04-24 17:37:06 - For help type #help;;
2018-04-24 17:37:06 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-24 17:37:06 -   seq []
2018-04-24 17:37:06 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-24 17:37:06 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-24 17:37:06 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-24 17:37:18 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-24 18:11:19 - #load "Paket.fsx"
2018-04-24 18:11:27 - Paket.Package
2018-04-24 18:11:27 -   [ "MathNet.Numerics"
2018-04-24 18:11:27 -     "MathNet.Numerics.FSharp"
2018-04-24 18:11:27 -     "FSharp.Data"
2018-04-24 18:11:27 -   ]
2018-04-24 18:11:51 - #load "Paket.Generated.Refs.fsx"
2018-04-24 18:12:05 - // On Azure, use the (Unix) terminal window to find these files in ~/IfSharp/bin/
2018-04-24 18:12:05 - #r "packages/MathNet.Numerics/lib/net40/MathNet.Numerics.dll"
2018-04-24 18:12:05 - #r "packages/FSharp.Data/lib/net45/FSharp.Data.dll"
2018-04-24 18:12:10 - open System
2018-04-24 18:12:10 - open MathNet.Numerics
2018-04-24 18:12:10 - open FSharp.Data
2018-04-24 18:14:20 - Discrete versions of the distributions - bin the support region of the distribution  
2018-04-24 18:14:20 - Returns discretized value and it's probability of occuring
2018-04-24 18:14:20 - Unexpected keyword 'of' in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2018-04-24 18:14:20 - parse error
2018-04-24 18:14:34 - Go through a distribution and obtain the probability for individual bins  
2018-04-24 18:14:34 - Uses the computational expression to go through the distributions in our model
2018-04-24 18:14:34 - Unexpected keyword 'and' in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2018-04-24 18:14:34 - parse error
2018-04-24 19:02:20 - type Distribution = 
2018-04-24 19:02:20 -   | Gaussian of mean:float * variance:float
2018-04-24 19:02:20 -   | Bernoulli of probability:float
2018-04-24 19:49:49 - #load "Paket.Generated.Refs.fsx"
2018-04-24 19:49:49 - open System
2018-04-24 19:49:49 - open MathNet.Numerics
2018-04-24 19:49:49 - open FSharp.Data
2018-04-24 19:49:50 - let binSize = 1000.0
2018-04-24 19:49:50 - let roundToBin x =
2018-04-24 19:49:50 -   let m = x % binSize
2018-04-24 19:49:50 -   if m >= binSize/2.0 then // round up
2018-04-24 19:49:50 -     x + binSize - m
2018-04-24 19:49:50 -   else // round down
2018-04-24 19:49:50 -     x - m
2018-04-24 19:49:50 - type DistributionValue = float
2018-04-24 19:49:50 - type Distribution = 
2018-04-24 19:49:50 -   | Gaussian of mean:float * variance:float
2018-04-24 19:49:50 -   | Bernoulli of probability:float
2018-04-24 19:49:50 - type ProbabilisticComputation<'T> = 
2018-04-24 19:49:50 -   | Sample of Distribution * (DistributionValue -> ProbabilisticComputation<'T>)
2018-04-24 19:49:50 -   | Return of 'T   
2018-04-24 19:49:50 - type ProbabilisticComputationBuilder() = 
2018-04-24 19:49:50 -   member x.Return(v) = Return v
2018-04-24 19:49:50 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-24 19:49:50 - let prob = ProbabilisticComputationBuilder()
2018-04-24 19:49:51 - let salaries = Gaussian(1000.0, 200.0)
2018-04-24 19:49:51 - let mistake = Bernoulli(0.1)
2018-04-24 19:49:51 - let model = 
2018-04-24 19:49:51 -   prob {
2018-04-24 19:49:51 -     let! yearlySalary = Gaussian(20000.0, 10000.0)
2018-04-24 19:49:51 -     let! mistake = Bernoulli(0.5)
2018-04-24 19:49:51 -     if mistake = 1.0 then 
2018-04-24 19:49:51 -       return yearlySalary / 12.0
2018-04-24 19:49:51 -     else 
2018-04-24 19:49:51 -       return yearlySalary
2018-04-24 19:49:51 -   }  
2018-04-24 19:49:51 - let varyParameters dist =
2018-04-24 19:49:51 -   match dist with
2018-04-24 19:49:51 -   | Gaussian(m, v) ->
2018-04-24 19:49:51 -      [ for mean in 0.0 .. 2000.0 .. 30000.0 do
2018-04-24 19:49:51 -         for var in 10000000.0 .. 1000000.0 .. 100000000.0 do 
2018-04-24 19:49:51 -           yield Gaussian(mean, var) ]
2018-04-24 19:49:51 -   | Bernoulli(_) ->
2018-04-24 19:49:51 -       [ for pt in 0.0 .. 0.05 .. 1.0 do
2018-04-24 19:49:51 -           yield Bernoulli(pt) ]
2018-04-24 19:49:51 - let discretize dist =
2018-04-24 19:49:51 -   match dist with 
2018-04-24 19:49:51 -   | Bernoulli(prob) -> 
2018-04-24 19:49:51 -       [1.0, prob; 0.0, (1.0 - prob) ]
2018-04-24 19:49:51 -   | Gaussian(mean, var) -> 
2018-04-24 19:49:51 -       [ for x in 0.0 .. binSize .. 110000.0 -> 
2018-04-24 19:49:51 -         // CDF (cummulative density function):   p(x <= N(mean,var)) 
2018-04-24 19:49:51 -         x, Distributions.Normal.CDF(mean, sqrt(var), x)]
2018-04-24 19:49:51 -       |> List.windowed 2
2018-04-24 19:49:51 -       |> List.map (fun w -> 
2018-04-24 19:49:51 -           fst w.[1], snd w.[1] - snd w.[0])
2018-04-24 19:49:52 - let rec enumerate dists choices model = seq {
2018-04-24 19:49:52 -   match model with
2018-04-24 19:49:52 -   | Sample(dist, f) ->
2018-04-24 19:49:52 -      for dist in varyParameters dist do
2018-04-24 19:49:52 -        for v, p in discretize dist do 
2018-04-24 19:49:52 -          yield! enumerate (dist::dists) ((v,p)::choices) (f v)
2018-04-24 19:49:52 -   | Return v -> 
2018-04-24 19:49:52 -       yield List.rev dists, (v, List.rev choices) }
2018-04-24 19:49:52 - let histograms = 
2018-04-24 19:49:52 -   enumerate [] [] model
2018-04-24 19:49:52 -   |> Seq.map (fun (dist, (value, trace)) ->
2018-04-24 19:49:52 -       dist, (roundToBin value, trace))
2018-04-24 19:49:52 -   |> Seq.distinct
2018-04-24 19:49:52 -   |> Seq.map (fun (dist, (value, trace)) -> 
2018-04-24 19:49:52 -     let logp = 
2018-04-24 19:49:52 -       trace 
2018-04-24 19:49:52 -       |> List.map (fun (_, p) -> if p = 0.0 then 1e-10 else p)
2018-04-24 19:49:52 -       |> List.map log
2018-04-24 19:49:52 -       |> List.fold (+) 0.0
2018-04-24 19:49:52 -     dist, value, logp)
2018-04-24 19:49:52 -   |> Seq.groupBy (fun (dist, _, _) -> dist)
2018-04-24 19:49:52 -   |> Seq.map (fun (dist, values) ->
2018-04-24 19:49:52 -       dist, 
2018-04-24 19:49:52 -       values |> Seq.map (fun (_, v, p) -> v, p)
2018-04-24 19:49:52 -       |> Array.ofSeq
2018-04-24 19:49:52 -       |> Array.sortBy fst)
2018-04-24 19:49:52 -   |> Array.ofSeq  
2018-04-24 20:13:31 - Expression evaluation failed: Object reference not set to an instance of an object
2018-04-24 20:13:31 - NullReferenceExceptionObject reference not set to an instance of an object
2018-04-24 20:13:31 -   at Microsoft.FSharp.Core.Operators.FailurePattern (System.Exception error) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x0002d] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d2] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.StopProcessingRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000b5] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00033] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.ExecInteraction (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate, Microsoft.FSharp.Compiler.Ast+ParsedFsiInteraction action, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger) [0x00010] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.execParsedInteractions (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate, Microsoft.FSharp.Core.FSharpOption`1[T] action, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpOption`1[T] lastResult) [0x002a4] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.Interactive.Shell+clo@2089-298.Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x00003] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0000d] in <5939249c904cf4daa74503839c243959>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.mainThreadProcessAction[a,b] (a ctok, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action, b istate) [0x0004a] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x00040] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d2] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.StopProcessingRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000b5] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.mainThreadProcessAction[a,b] (a ctok, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action, b istate) [0x00104] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.mainThreadProcessParsedInteractions (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpOption`1[T] action, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x0000b] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.Interactive.Shell+EvalInteraction@2232.Invoke (Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x00013] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00018] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x00040] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d2] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.StopProcessingRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000b5] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00033] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.EvalInteraction (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, System.String sourceText, System.String scriptFileName, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger) [0x00058] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiEvaluationSession.EvalInteractionNonThrowing (System.String code) [0x0001c] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:13:31 -   at IfSharp.Kernel.IfSharpKernel.executeRequest (IfSharp.Kernel.KernelMessage msg, IfSharp.Kernel.ExecuteRequest content) [0x00096] in <5ad0f80e1b085d3da74503830ef8d05a>:0 
2018-04-24 20:13:32 - let compareDataHistogram (dist, values) data =
2018-04-24 20:13:32 -   let histLogProbability = 
2018-04-24 20:13:32 -     values
2018-04-24 20:13:32 -     |> Array.append [| (0.0, 0.0) |]
2018-04-24 20:13:32 -     |> Array.windowed 2
2018-04-24 20:13:32 -     |> Array.map (fun bin ->
2018-04-24 20:13:32 -         let p = bin.[1] |> snd
2018-04-24 20:13:32 -         p, 
2018-04-24 20:13:32 -         data 
2018-04-24 20:13:32 -         |> Array.filter (fun x -> 
2018-04-24 20:13:32 -             x > fst bin.[0] && x <= fst bin.[1])
2018-04-24 20:13:32 -         |> Array.length
2018-04-24 20:13:32 -         |> float)
2018-04-24 20:13:32 -     |> Array.fold (fun pAcc (logp, x) -> x * logp + pAcc) 0.0
2018-04-24 20:13:32 -   dist, histLogProbability
2018-04-24 20:13:32 - let mostLikelyDistribution hists data =
2018-04-24 20:13:32 -   hists
2018-04-24 20:13:32 -   |> Array.map (fun distributionHist -> compareDataHistogram distributionHist data)
2018-04-24 20:13:32 -   |> Array.sortByDescending snd
2018-04-24 20:13:32 -   |> Array.take 10
2018-04-24 20:13:35 - #load "Paket.Generated.Refs.fsx"
2018-04-24 20:13:35 - open System
2018-04-24 20:13:35 - open MathNet.Numerics
2018-04-24 20:13:35 - open FSharp.Data
2018-04-24 20:13:35 - let binSize = 1000.0
2018-04-24 20:13:35 - let roundToBin x =
2018-04-24 20:13:35 -   let m = x % binSize
2018-04-24 20:13:35 -   if m >= binSize/2.0 then // round up
2018-04-24 20:13:35 -     x + binSize - m
2018-04-24 20:13:35 -   else // round down
2018-04-24 20:13:35 -     x - m
2018-04-24 20:13:35 - type DistributionValue = float
2018-04-24 20:13:35 - type Distribution = 
2018-04-24 20:13:35 -   | Gaussian of mean:float * variance:float
2018-04-24 20:13:35 -   | Bernoulli of probability:float
2018-04-24 20:13:36 - type ProbabilisticComputation<'T> = 
2018-04-24 20:13:36 -   | Sample of Distribution * (DistributionValue -> ProbabilisticComputation<'T>)
2018-04-24 20:13:36 -   | Return of 'T   
2018-04-24 20:13:36 - type ProbabilisticComputationBuilder() = 
2018-04-24 20:13:36 -   member x.Return(v) = Return v
2018-04-24 20:13:36 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-24 20:13:36 - let prob = ProbabilisticComputationBuilder()
2018-04-24 20:13:36 - let salaries = Gaussian(1000.0, 200.0)
2018-04-24 20:13:36 - let mistake = Bernoulli(0.1)
2018-04-24 20:13:37 - let model = 
2018-04-24 20:13:37 -   prob {
2018-04-24 20:13:37 -     let! yearlySalary = Gaussian(20000.0, 10000.0)
2018-04-24 20:13:37 -     let! mistake = Bernoulli(0.5)
2018-04-24 20:13:37 -     if mistake = 1.0 then 
2018-04-24 20:13:37 -       return yearlySalary / 12.0
2018-04-24 20:13:37 -     else 
2018-04-24 20:13:37 -       return yearlySalary
2018-04-24 20:13:37 -   }  
2018-04-24 20:13:37 - let varyParameters dist =
2018-04-24 20:13:37 -   match dist with
2018-04-24 20:13:37 -   | Gaussian(m, v) ->
2018-04-24 20:13:37 -      [ for mean in 0.0 .. 2000.0 .. 30000.0 do
2018-04-24 20:13:37 -         for var in 10000000.0 .. 1000000.0 .. 100000000.0 do 
2018-04-24 20:13:37 -           yield Gaussian(mean, var) ]
2018-04-24 20:13:37 -   | Bernoulli(_) ->
2018-04-24 20:13:37 -       [ for pt in 0.0 .. 0.05 .. 1.0 do
2018-04-24 20:13:37 -           yield Bernoulli(pt) ]
2018-04-24 20:13:37 - let discretize dist =
2018-04-24 20:13:37 -   match dist with 
2018-04-24 20:13:37 -   | Bernoulli(prob) -> 
2018-04-24 20:13:37 -       [1.0, prob; 0.0, (1.0 - prob) ]
2018-04-24 20:13:37 -   | Gaussian(mean, var) -> 
2018-04-24 20:13:37 -       [ for x in 0.0 .. binSize .. 110000.0 -> 
2018-04-24 20:13:37 -         // CDF (cummulative density function):   p(x <= N(mean,var)) 
2018-04-24 20:13:37 -         x, Distributions.Normal.CDF(mean, sqrt(var), x)]
2018-04-24 20:13:37 -       |> List.windowed 2
2018-04-24 20:13:37 -       |> List.map (fun w -> 
2018-04-24 20:13:37 -           fst w.[1], snd w.[1] - snd w.[0])
2018-04-24 20:13:37 - let rec enumerate dists choices model = seq {
2018-04-24 20:13:37 -   match model with
2018-04-24 20:13:37 -   | Sample(dist, f) ->
2018-04-24 20:13:37 -      for dist in varyParameters dist do
2018-04-24 20:13:37 -        for v, p in discretize dist do 
2018-04-24 20:13:37 -          yield! enumerate (dist::dists) ((v,p)::choices) (f v)
2018-04-24 20:13:37 -   | Return v -> 
2018-04-24 20:13:37 -       yield List.rev dists, (v, List.rev choices) }
2018-04-24 20:13:37 - let histograms = 
2018-04-24 20:13:37 -   enumerate [] [] model
2018-04-24 20:13:37 -   |> Seq.map (fun (dist, (value, trace)) ->
2018-04-24 20:13:37 -       dist, (roundToBin value, trace))
2018-04-24 20:13:37 -   |> Seq.distinct
2018-04-24 20:13:37 -   |> Seq.map (fun (dist, (value, trace)) -> 
2018-04-24 20:13:37 -     let logp = 
2018-04-24 20:13:37 -       trace 
2018-04-24 20:13:37 -       |> List.map (fun (_, p) -> if p = 0.0 then 1e-10 else p)
2018-04-24 20:13:37 -       |> List.map log
2018-04-24 20:13:37 -       |> List.fold (+) 0.0
2018-04-24 20:13:37 -     dist, value, logp)
2018-04-24 20:13:37 -   |> Seq.groupBy (fun (dist, _, _) -> dist)
2018-04-24 20:13:37 -   |> Seq.map (fun (dist, values) ->
2018-04-24 20:13:37 -       dist, 
2018-04-24 20:13:37 -       values |> Seq.map (fun (_, v, p) -> v, p)
2018-04-24 20:13:37 -       |> Array.ofSeq
2018-04-24 20:13:37 -       |> Array.sortBy fst)
2018-04-24 20:13:37 -   |> Array.ofSeq  
2018-04-24 20:15:33 - // include directory, this will be replaced by the kernel
2018-04-24 20:15:33 - #I "/home/nbuser/IfSharp/bin"
2018-04-24 20:15:33 - // load base dlls
2018-04-24 20:15:33 - #r "IfSharp.Kernel.dll"
2018-04-24 20:15:33 - #r "NetMQ.dll"
2018-04-24 20:15:33 - // open the global functions and methods
2018-04-24 20:15:33 - open IfSharp.Kernel
2018-04-24 20:15:33 - open IfSharp.Kernel.Globals
2018-04-24 20:15:40 - F# Interactive for F# 4.1
2018-04-24 20:15:40 - Freely distributed under the Apache 2.0 Open Source License
2018-04-24 20:15:40 - For help type #help;;
2018-04-24 20:15:40 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-24 20:15:40 -   seq []
2018-04-24 20:15:40 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-24 20:15:40 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-24 20:15:40 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-24 20:32:20 - #load "Paket.Generated.Refs.fsx"
2018-04-24 20:32:23 - open System
2018-04-24 20:32:23 - open MathNet.Numerics
2018-04-24 20:32:23 - open FSharp.Data
2018-04-24 20:32:23 - let binSize = 1000.0
2018-04-24 20:32:23 - let roundToBin x =
2018-04-24 20:32:23 -   let m = x % binSize
2018-04-24 20:32:23 -   if m >= binSize/2.0 then // round up
2018-04-24 20:32:23 -     x + binSize - m
2018-04-24 20:32:23 -   else // round down
2018-04-24 20:32:23 -     x - m
2018-04-24 20:32:23 - type DistributionValue = float
2018-04-24 20:32:23 - type Distribution = 
2018-04-24 20:32:23 -   | Gaussian of mean:float * variance:float
2018-04-24 20:32:23 -   | Bernoulli of probability:float
2018-04-24 20:32:24 - type ProbabilisticComputation<'T> = 
2018-04-24 20:32:24 -   | Sample of Distribution * (DistributionValue -> ProbabilisticComputation<'T>)
2018-04-24 20:32:24 -   | Return of 'T   
2018-04-24 20:32:24 - type ProbabilisticComputationBuilder() = 
2018-04-24 20:32:24 -   member x.Return(v) = Return v
2018-04-24 20:32:24 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-24 20:32:24 - let prob = ProbabilisticComputationBuilder()
2018-04-24 20:32:25 - let salaries = Gaussian(1000.0, 200.0)
2018-04-24 20:32:25 - let mistake = Bernoulli(0.1)
2018-04-24 20:32:25 - let model = 
2018-04-24 20:32:25 -   prob {
2018-04-24 20:32:25 -     let! yearlySalary = Gaussian(20000.0, 10000.0)
2018-04-24 20:32:25 -     let! mistake = Bernoulli(0.5)
2018-04-24 20:32:25 -     if mistake = 1.0 then 
2018-04-24 20:32:25 -       return yearlySalary / 12.0
2018-04-24 20:32:25 -     else 
2018-04-24 20:32:25 -       return yearlySalary
2018-04-24 20:32:25 -   }  
2018-04-24 20:32:25 - let varyParameters dist =
2018-04-24 20:32:25 -   match dist with
2018-04-24 20:32:25 -   | Gaussian(m, v) ->
2018-04-24 20:32:25 -      [ for mean in 0.0 .. 2000.0 .. 30000.0 do
2018-04-24 20:32:25 -         for var in 10000000.0 .. 1000000.0 .. 100000000.0 do 
2018-04-24 20:32:25 -           yield Gaussian(mean, var) ]
2018-04-24 20:32:25 -   | Bernoulli(_) ->
2018-04-24 20:32:25 -       [ for pt in 0.0 .. 0.05 .. 1.0 do
2018-04-24 20:32:25 -           yield Bernoulli(pt) ]
2018-04-24 20:32:25 - let discretize dist =
2018-04-24 20:32:25 -   match dist with 
2018-04-24 20:32:25 -   | Bernoulli(prob) -> 
2018-04-24 20:32:25 -       [1.0, prob; 0.0, (1.0 - prob) ]
2018-04-24 20:32:25 -   | Gaussian(mean, var) -> 
2018-04-24 20:32:25 -       [ for x in 0.0 .. binSize .. 110000.0 -> 
2018-04-24 20:32:25 -         // CDF (cummulative density function):   p(x <= N(mean,var)) 
2018-04-24 20:32:25 -         x, Distributions.Normal.CDF(mean, sqrt(var), x)]
2018-04-24 20:32:25 -       |> List.windowed 2
2018-04-24 20:32:25 -       |> List.map (fun w -> 
2018-04-24 20:32:25 -           fst w.[1], snd w.[1] - snd w.[0])
2018-04-24 20:32:25 - let rec enumerate dists choices model = seq {
2018-04-24 20:32:25 -   match model with
2018-04-24 20:32:25 -   | Sample(dist, f) ->
2018-04-24 20:32:25 -      for dist in varyParameters dist do
2018-04-24 20:32:25 -        for v, p in discretize dist do 
2018-04-24 20:32:25 -          yield! enumerate (dist::dists) ((v,p)::choices) (f v)
2018-04-24 20:32:25 -   | Return v -> 
2018-04-24 20:32:25 -       yield List.rev dists, (v, List.rev choices) }
2018-04-24 20:32:25 - let histograms = 
2018-04-24 20:32:25 -   enumerate [] [] model
2018-04-24 20:32:25 -   |> Seq.map (fun (dist, (value, trace)) ->
2018-04-24 20:32:25 -       dist, (roundToBin value, trace))
2018-04-24 20:32:25 -   |> Seq.distinct
2018-04-24 20:32:25 -   |> Seq.map (fun (dist, (value, trace)) -> 
2018-04-24 20:32:25 -     let logp = 
2018-04-24 20:32:25 -       trace 
2018-04-24 20:32:25 -       |> List.map (fun (_, p) -> if p = 0.0 then 1e-10 else p)
2018-04-24 20:32:25 -       |> List.map log
2018-04-24 20:32:25 -       |> List.fold (+) 0.0
2018-04-24 20:32:25 -     dist, value, logp)
2018-04-24 20:32:25 -   |> Seq.groupBy (fun (dist, _, _) -> dist)
2018-04-24 20:32:25 -   |> Seq.map (fun (dist, values) ->
2018-04-24 20:32:25 -       dist, 
2018-04-24 20:32:25 -       values |> Seq.map (fun (_, v, p) -> v, p)
2018-04-24 20:32:25 -       |> Array.ofSeq
2018-04-24 20:32:25 -       |> Array.sortBy fst)
2018-04-24 20:32:25 -   |> Array.ofSeq  
2018-04-24 20:32:31 - shutdown request
2018-04-24 20:32:33 - // include directory, this will be replaced by the kernel
2018-04-24 20:32:33 - #I "/home/nbuser/IfSharp/bin"
2018-04-24 20:32:33 - // load base dlls
2018-04-24 20:32:33 - #r "IfSharp.Kernel.dll"
2018-04-24 20:32:33 - #r "NetMQ.dll"
2018-04-24 20:32:33 - // open the global functions and methods
2018-04-24 20:32:33 - open IfSharp.Kernel
2018-04-24 20:32:33 - open IfSharp.Kernel.Globals
2018-04-24 20:32:38 - F# Interactive for F# 4.1
2018-04-24 20:32:38 - Freely distributed under the Apache 2.0 Open Source License
2018-04-24 20:32:38 - For help type #help;;
2018-04-24 20:32:38 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-24 20:32:38 -   seq []
2018-04-24 20:32:38 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-24 20:32:38 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-24 20:32:38 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-24 20:32:39 - #load "Paket.Generated.Refs.fsx"
2018-04-24 20:32:41 - open System
2018-04-24 20:32:41 - open MathNet.Numerics
2018-04-24 20:32:41 - open FSharp.Data
2018-04-24 20:32:41 - let binSize = 1000.0
2018-04-24 20:32:41 - let roundToBin x =
2018-04-24 20:32:41 -   let m = x % binSize
2018-04-24 20:32:41 -   if m >= binSize/2.0 then // round up
2018-04-24 20:32:41 -     x + binSize - m
2018-04-24 20:32:41 -   else // round down
2018-04-24 20:32:41 -     x - m
2018-04-24 20:32:41 - type DistributionValue = float
2018-04-24 20:32:41 - type Distribution = 
2018-04-24 20:32:41 -   | Gaussian of mean:float * variance:float
2018-04-24 20:32:41 -   | Bernoulli of probability:float
2018-04-24 20:32:42 - type ProbabilisticComputation<'T> = 
2018-04-24 20:32:42 -   | Sample of Distribution * (DistributionValue -> ProbabilisticComputation<'T>)
2018-04-24 20:32:42 -   | Return of 'T   
2018-04-24 20:32:42 - type ProbabilisticComputationBuilder() = 
2018-04-24 20:32:42 -   member x.Return(v) = Return v
2018-04-24 20:32:42 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-24 20:32:43 - let prob = ProbabilisticComputationBuilder()
2018-04-24 20:32:43 - let salaries = Gaussian(1000.0, 200.0)
2018-04-24 20:32:43 - let mistake = Bernoulli(0.1)
2018-04-24 20:32:43 - let model = 
2018-04-24 20:32:43 -   prob {
2018-04-24 20:32:43 -     let! yearlySalary = Gaussian(20000.0, 10000.0)
2018-04-24 20:32:43 -     let! mistake = Bernoulli(0.5)
2018-04-24 20:32:43 -     if mistake = 1.0 then 
2018-04-24 20:32:43 -       return yearlySalary / 12.0
2018-04-24 20:32:43 -     else 
2018-04-24 20:32:43 -       return yearlySalary
2018-04-24 20:32:43 -   }  
2018-04-24 20:32:43 - let varyParameters dist =
2018-04-24 20:32:43 -   match dist with
2018-04-24 20:32:43 -   | Gaussian(m, v) ->
2018-04-24 20:32:43 -      [ for mean in 0.0 .. 2000.0 .. 30000.0 do
2018-04-24 20:32:43 -         for var in 10000000.0 .. 1000000.0 .. 100000000.0 do 
2018-04-24 20:32:43 -           yield Gaussian(mean, var) ]
2018-04-24 20:32:43 -   | Bernoulli(_) ->
2018-04-24 20:32:43 -       [ for pt in 0.0 .. 0.05 .. 1.0 do
2018-04-24 20:32:43 -           yield Bernoulli(pt) ]
2018-04-24 20:32:43 - let discretize dist =
2018-04-24 20:32:43 -   match dist with 
2018-04-24 20:32:43 -   | Bernoulli(prob) -> 
2018-04-24 20:32:43 -       [1.0, prob; 0.0, (1.0 - prob) ]
2018-04-24 20:32:43 -   | Gaussian(mean, var) -> 
2018-04-24 20:32:43 -       [ for x in 0.0 .. binSize .. 110000.0 -> 
2018-04-24 20:32:43 -         // CDF (cummulative density function):   p(x <= N(mean,var)) 
2018-04-24 20:32:43 -         x, Distributions.Normal.CDF(mean, sqrt(var), x)]
2018-04-24 20:32:43 -       |> List.windowed 2
2018-04-24 20:32:43 -       |> List.map (fun w -> 
2018-04-24 20:32:43 -           fst w.[1], snd w.[1] - snd w.[0])
2018-04-24 20:32:43 - let rec enumerate dists choices model = seq {
2018-04-24 20:32:43 -   match model with
2018-04-24 20:32:43 -   | Sample(dist, f) ->
2018-04-24 20:32:43 -      for dist in varyParameters dist do
2018-04-24 20:32:43 -        for v, p in discretize dist do 
2018-04-24 20:32:43 -          yield! enumerate (dist::dists) ((v,p)::choices) (f v)
2018-04-24 20:32:43 -   | Return v -> 
2018-04-24 20:32:43 -       yield List.rev dists, (v, List.rev choices) }
2018-04-24 20:32:44 - let histograms = 
2018-04-24 20:32:44 -   enumerate [] [] model
2018-04-24 20:32:44 -   |> Seq.map (fun (dist, (value, trace)) ->
2018-04-24 20:32:44 -       dist, (roundToBin value, trace))
2018-04-24 20:32:44 -   |> Seq.distinct
2018-04-24 20:32:44 -   |> Seq.map (fun (dist, (value, trace)) -> 
2018-04-24 20:32:44 -     let logp = 
2018-04-24 20:32:44 -       trace 
2018-04-24 20:32:44 -       |> List.map (fun (_, p) -> if p = 0.0 then 1e-10 else p)
2018-04-24 20:32:44 -       |> List.map log
2018-04-24 20:32:44 -       |> List.fold (+) 0.0
2018-04-24 20:32:44 -     dist, value, logp)
2018-04-24 20:32:44 -   |> Seq.groupBy (fun (dist, _, _) -> dist)
2018-04-24 20:32:44 -   |> Seq.map (fun (dist, values) ->
2018-04-24 20:32:44 -       dist, 
2018-04-24 20:32:44 -       values |> Seq.map (fun (_, v, p) -> v, p)
2018-04-24 20:32:44 -       |> Array.ofSeq
2018-04-24 20:32:44 -       |> Array.sortBy fst)
2018-04-24 20:32:44 -   |> Array.ofSeq  
2018-04-24 20:33:57 - Expression evaluation failed: Object reference not set to an instance of an object
2018-04-24 20:33:57 - NullReferenceExceptionObject reference not set to an instance of an object
2018-04-24 20:33:57 -   at Microsoft.FSharp.Core.Operators.FailurePattern (System.Exception error) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x0002d] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d2] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.StopProcessingRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000b5] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00033] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.ExecInteraction (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate, Microsoft.FSharp.Compiler.Ast+ParsedFsiInteraction action, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger) [0x00010] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.execParsedInteractions (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate, Microsoft.FSharp.Core.FSharpOption`1[T] action, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpOption`1[T] lastResult) [0x002a4] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.Interactive.Shell+clo@2089-298.Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x00003] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0000d] in <5939249c904cf4daa74503839c243959>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.mainThreadProcessAction[a,b] (a ctok, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action, b istate) [0x0004a] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x00040] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d2] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.StopProcessingRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000b5] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.mainThreadProcessAction[a,b] (a ctok, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action, b istate) [0x00104] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.mainThreadProcessParsedInteractions (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpOption`1[T] action, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x0000b] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.Interactive.Shell+EvalInteraction@2232.Invoke (Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x00013] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00018] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x00040] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d2] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.StopProcessingRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000b5] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00033] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.EvalInteraction (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, System.String sourceText, System.String scriptFileName, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger) [0x00058] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiEvaluationSession.EvalInteractionNonThrowing (System.String code) [0x0001c] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 20:33:57 -   at IfSharp.Kernel.IfSharpKernel.executeRequest (IfSharp.Kernel.KernelMessage msg, IfSharp.Kernel.ExecuteRequest content) [0x00096] in <5ad0f80e1b085d3da74503830ef8d05a>:0 
2018-04-24 20:33:58 - let compareDataHistogram (dist, values) data =
2018-04-24 20:33:58 -   let histLogProbability = 
2018-04-24 20:33:58 -     values
2018-04-24 20:33:58 -     |> Array.append [| (0.0, 0.0) |]
2018-04-24 20:33:58 -     |> Array.windowed 2
2018-04-24 20:33:58 -     |> Array.map (fun bin ->
2018-04-24 20:33:58 -         let p = bin.[1] |> snd
2018-04-24 20:33:58 -         p, 
2018-04-24 20:33:58 -         data 
2018-04-24 20:33:58 -         |> Array.filter (fun x -> 
2018-04-24 20:33:58 -             x > fst bin.[0] && x <= fst bin.[1])
2018-04-24 20:33:58 -         |> Array.length
2018-04-24 20:33:58 -         |> float)
2018-04-24 20:33:58 -     |> Array.fold (fun pAcc (logp, x) -> x * logp + pAcc) 0.0
2018-04-24 20:33:58 -   dist, histLogProbability
2018-04-24 20:33:58 - let mostLikelyDistribution hists data =
2018-04-24 20:33:58 -   hists
2018-04-24 20:33:58 -   |> Array.map (fun distributionHist -> compareDataHistogram distributionHist data)
2018-04-24 20:33:58 -   |> Array.sortByDescending snd
2018-04-24 20:33:58 -   |> Array.take 10
2018-04-24 20:34:02 - #load "Paket.Generated.Refs.fsx"
2018-04-24 20:34:02 - open System
2018-04-24 20:34:02 - open MathNet.Numerics
2018-04-24 20:34:02 - open FSharp.Data
2018-04-24 20:34:02 - let binSize = 1000.0
2018-04-24 20:34:02 - let roundToBin x =
2018-04-24 20:34:02 -   let m = x % binSize
2018-04-24 20:34:02 -   if m >= binSize/2.0 then // round up
2018-04-24 20:34:02 -     x + binSize - m
2018-04-24 20:34:02 -   else // round down
2018-04-24 20:34:02 -     x - m
2018-04-24 20:34:02 - type DistributionValue = float
2018-04-24 20:34:03 - type Distribution = 
2018-04-24 20:34:03 -   | Gaussian of mean:float * variance:float
2018-04-24 20:34:03 -   | Bernoulli of probability:float
2018-04-24 20:34:03 - type ProbabilisticComputation<'T> = 
2018-04-24 20:34:03 -   | Sample of Distribution * (DistributionValue -> ProbabilisticComputation<'T>)
2018-04-24 20:34:03 -   | Return of 'T   
2018-04-24 20:34:03 - type ProbabilisticComputationBuilder() = 
2018-04-24 20:34:03 -   member x.Return(v) = Return v
2018-04-24 20:34:03 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-24 20:34:03 - let prob = ProbabilisticComputationBuilder()
2018-04-24 20:34:03 - let salaries = Gaussian(1000.0, 200.0)
2018-04-24 20:34:03 - let mistake = Bernoulli(0.1)
2018-04-24 20:34:03 - let model = 
2018-04-24 20:34:03 -   prob {
2018-04-24 20:34:03 -     let! yearlySalary = Gaussian(20000.0, 10000.0)
2018-04-24 20:34:03 -     let! mistake = Bernoulli(0.5)
2018-04-24 20:34:03 -     if mistake = 1.0 then 
2018-04-24 20:34:03 -       return yearlySalary / 12.0
2018-04-24 20:34:03 -     else 
2018-04-24 20:34:03 -       return yearlySalary
2018-04-24 20:34:03 -   }  
2018-04-24 20:34:04 - let varyParameters dist =
2018-04-24 20:34:04 -   match dist with
2018-04-24 20:34:04 -   | Gaussian(m, v) ->
2018-04-24 20:34:04 -      [ for mean in 0.0 .. 2000.0 .. 30000.0 do
2018-04-24 20:34:04 -         for var in 10000000.0 .. 1000000.0 .. 100000000.0 do 
2018-04-24 20:34:04 -           yield Gaussian(mean, var) ]
2018-04-24 20:34:04 -   | Bernoulli(_) ->
2018-04-24 20:34:04 -       [ for pt in 0.0 .. 0.05 .. 1.0 do
2018-04-24 20:34:04 -           yield Bernoulli(pt) ]
2018-04-24 20:34:04 - let discretize dist =
2018-04-24 20:34:04 -   match dist with 
2018-04-24 20:34:04 -   | Bernoulli(prob) -> 
2018-04-24 20:34:04 -       [1.0, prob; 0.0, (1.0 - prob) ]
2018-04-24 20:34:04 -   | Gaussian(mean, var) -> 
2018-04-24 20:34:04 -       [ for x in 0.0 .. binSize .. 110000.0 -> 
2018-04-24 20:34:04 -         // CDF (cummulative density function):   p(x <= N(mean,var)) 
2018-04-24 20:34:04 -         x, Distributions.Normal.CDF(mean, sqrt(var), x)]
2018-04-24 20:34:04 -       |> List.windowed 2
2018-04-24 20:34:04 -       |> List.map (fun w -> 
2018-04-24 20:34:04 -           fst w.[1], snd w.[1] - snd w.[0])
2018-04-24 20:34:04 - let rec enumerate dists choices model = seq {
2018-04-24 20:34:04 -   match model with
2018-04-24 20:34:04 -   | Sample(dist, f) ->
2018-04-24 20:34:04 -      for dist in varyParameters dist do
2018-04-24 20:34:04 -        for v, p in discretize dist do 
2018-04-24 20:34:04 -          yield! enumerate (dist::dists) ((v,p)::choices) (f v)
2018-04-24 20:34:04 -   | Return v -> 
2018-04-24 20:34:04 -       yield List.rev dists, (v, List.rev choices) }
2018-04-24 20:34:04 - let histograms = 
2018-04-24 20:34:04 -   enumerate [] [] model
2018-04-24 20:34:04 -   |> Seq.map (fun (dist, (value, trace)) ->
2018-04-24 20:34:04 -       dist, (roundToBin value, trace))
2018-04-24 20:34:04 -   |> Seq.distinct
2018-04-24 20:34:04 -   |> Seq.map (fun (dist, (value, trace)) -> 
2018-04-24 20:34:04 -     let logp = 
2018-04-24 20:34:04 -       trace 
2018-04-24 20:34:04 -       |> List.map (fun (_, p) -> if p = 0.0 then 1e-10 else p)
2018-04-24 20:34:04 -       |> List.map log
2018-04-24 20:34:04 -       |> List.fold (+) 0.0
2018-04-24 20:34:04 -     dist, value, logp)
2018-04-24 20:34:04 -   |> Seq.groupBy (fun (dist, _, _) -> dist)
2018-04-24 20:34:04 -   |> Seq.map (fun (dist, values) ->
2018-04-24 20:34:04 -       dist, 
2018-04-24 20:34:04 -       values |> Seq.map (fun (_, v, p) -> v, p)
2018-04-24 20:34:04 -       |> Array.ofSeq
2018-04-24 20:34:04 -       |> Array.sortBy fst)
2018-04-24 20:34:04 -   |> Array.ofSeq  
2018-04-24 20:34:18 - // include directory, this will be replaced by the kernel
2018-04-24 20:34:18 - #I "/home/nbuser/IfSharp/bin"
2018-04-24 20:34:18 - // load base dlls
2018-04-24 20:34:18 - #r "IfSharp.Kernel.dll"
2018-04-24 20:34:18 - #r "NetMQ.dll"
2018-04-24 20:34:18 - // open the global functions and methods
2018-04-24 20:34:18 - open IfSharp.Kernel
2018-04-24 20:34:18 - open IfSharp.Kernel.Globals
2018-04-24 20:34:23 - F# Interactive for F# 4.1
2018-04-24 20:34:23 - Freely distributed under the Apache 2.0 Open Source License
2018-04-24 20:34:23 - For help type #help;;
2018-04-24 20:34:23 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-24 20:34:23 -   seq []
2018-04-24 20:34:23 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-24 20:34:23 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-24 20:34:23 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-24 21:02:32 - #load "Paket.Generated.Refs.fsx"
2018-04-24 21:02:34 - open System
2018-04-24 21:02:34 - open MathNet.Numerics
2018-04-24 21:02:34 - open FSharp.Data
2018-04-24 21:02:34 - let binSize = 1000.0
2018-04-24 21:02:34 - let roundToBin x =
2018-04-24 21:02:34 -   let m = x % binSize
2018-04-24 21:02:34 -   if m >= binSize/2.0 then // round up
2018-04-24 21:02:34 -     x + binSize - m
2018-04-24 21:02:34 -   else // round down
2018-04-24 21:02:34 -     x - m
2018-04-24 21:02:34 - type DistributionValue = float
2018-04-24 21:02:34 - type Distribution = 
2018-04-24 21:02:34 -   | Gaussian of mean:float * variance:float
2018-04-24 21:02:34 -   | Bernoulli of probability:float
2018-04-24 21:02:34 - let salaries = Gaussian(1000.0, 200.0)
2018-04-24 21:02:34 - let mistake = Bernoulli(0.1)
2018-04-24 21:02:35 - type ProbabilisticComputation<'T> = 
2018-04-24 21:02:35 -   | Sample of Distribution * (DistributionValue -> ProbabilisticComputation<'T>)
2018-04-24 21:02:35 -   | Return of 'T   
2018-04-24 21:02:35 - type ProbabilisticComputationBuilder() = 
2018-04-24 21:02:35 -   member x.Return(v) = Return v
2018-04-24 21:02:35 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-24 21:02:35 - let prob = ProbabilisticComputationBuilder()
2018-04-24 21:02:35 - let model = 
2018-04-24 21:02:35 -   prob {
2018-04-24 21:02:35 -     let! yearlySalary = Gaussian(20000.0, 10000.0)
2018-04-24 21:02:35 -     let! mistake = Bernoulli(0.5)
2018-04-24 21:02:35 -     if mistake = 1.0 then 
2018-04-24 21:02:35 -       return yearlySalary / 12.0
2018-04-24 21:02:35 -     else 
2018-04-24 21:02:35 -       return yearlySalary
2018-04-24 21:02:35 -   }  
2018-04-24 21:02:35 - let varyParameters dist =
2018-04-24 21:02:35 -   match dist with
2018-04-24 21:02:35 -   | Gaussian(m, v) ->
2018-04-24 21:02:35 -      [ for mean in 0.0 .. 2000.0 .. 30000.0 do
2018-04-24 21:02:35 -         for var in 10000000.0 .. 1000000.0 .. 100000000.0 do 
2018-04-24 21:02:35 -           yield Gaussian(mean, var) ]
2018-04-24 21:02:35 -   | Bernoulli(_) ->
2018-04-24 21:02:35 -       [ for pt in 0.0 .. 0.05 .. 1.0 do
2018-04-24 21:02:35 -           yield Bernoulli(pt) ]
2018-04-24 21:02:35 - let discretize dist =
2018-04-24 21:02:35 -   match dist with 
2018-04-24 21:02:35 -   | Bernoulli(prob) -> 
2018-04-24 21:02:35 -       [1.0, prob; 0.0, (1.0 - prob) ]
2018-04-24 21:02:35 -   | Gaussian(mean, var) -> 
2018-04-24 21:02:35 -       [ for x in 0.0 .. binSize .. 110000.0 -> 
2018-04-24 21:02:35 -         // CDF (cummulative density function):   p(x <= N(mean,var)) 
2018-04-24 21:02:35 -         x, Distributions.Normal.CDF(mean, sqrt(var), x)]
2018-04-24 21:02:35 -       |> List.windowed 2
2018-04-24 21:02:35 -       |> List.map (fun w -> 
2018-04-24 21:02:35 -           fst w.[1], snd w.[1] - snd w.[0])
2018-04-24 21:02:35 - let rec enumerate dists choices model = seq {
2018-04-24 21:02:35 -   match model with
2018-04-24 21:02:35 -   | Sample(dist, f) ->
2018-04-24 21:02:35 -      for dist in varyParameters dist do
2018-04-24 21:02:35 -        for v, p in discretize dist do 
2018-04-24 21:02:35 -          yield! enumerate (dist::dists) ((v,p)::choices) (f v)
2018-04-24 21:02:35 -   | Return v -> 
2018-04-24 21:02:35 -       yield List.rev dists, (v, List.rev choices) }
2018-04-24 21:02:35 - let histograms = 
2018-04-24 21:02:35 -   enumerate [] [] model
2018-04-24 21:02:35 -   |> Seq.map (fun (dist, (value, trace)) ->
2018-04-24 21:02:35 -       dist, (roundToBin value, trace))
2018-04-24 21:02:35 -   |> Seq.distinct
2018-04-24 21:02:35 -   |> Seq.map (fun (dist, (value, trace)) -> 
2018-04-24 21:02:35 -     let logp = 
2018-04-24 21:02:35 -       trace 
2018-04-24 21:02:35 -       |> List.map (fun (_, p) -> if p = 0.0 then 1e-10 else p)
2018-04-24 21:02:35 -       |> List.map log
2018-04-24 21:02:35 -       |> List.fold (+) 0.0
2018-04-24 21:02:35 -     dist, value, logp)
2018-04-24 21:02:35 -   |> Seq.groupBy (fun (dist, _, _) -> dist)
2018-04-24 21:02:35 -   |> Seq.map (fun (dist, values) ->
2018-04-24 21:02:35 -       dist, 
2018-04-24 21:02:35 -       values |> Seq.map (fun (_, v, p) -> v, p)
2018-04-24 21:02:35 -       |> Array.ofSeq
2018-04-24 21:02:35 -       |> Array.sortBy fst)
2018-04-24 21:02:35 -   |> Array.ofSeq  
2018-04-24 21:14:43 - Expression evaluation failed: Object reference not set to an instance of an object
2018-04-24 21:14:43 - NullReferenceExceptionObject reference not set to an instance of an object
2018-04-24 21:14:43 -   at Microsoft.FSharp.Core.Operators.FailurePattern (System.Exception error) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x0002d] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d2] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.StopProcessingRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000b5] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00033] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.ExecInteraction (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate, Microsoft.FSharp.Compiler.Ast+ParsedFsiInteraction action, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger) [0x00010] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.execParsedInteractions (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate, Microsoft.FSharp.Core.FSharpOption`1[T] action, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpOption`1[T] lastResult) [0x002a4] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.Interactive.Shell+clo@2089-298.Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x00003] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0000d] in <5939249c904cf4daa74503839c243959>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.mainThreadProcessAction[a,b] (a ctok, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action, b istate) [0x0004a] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x00040] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d2] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.StopProcessingRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000b5] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.mainThreadProcessAction[a,b] (a ctok, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action, b istate) [0x00104] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.mainThreadProcessParsedInteractions (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpOption`1[T] action, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x0000b] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.Interactive.Shell+EvalInteraction@2232.Invoke (Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x00013] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00018] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x00040] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d2] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.StopProcessingRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000b5] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00033] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.EvalInteraction (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, System.String sourceText, System.String scriptFileName, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger) [0x00058] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiEvaluationSession.EvalInteractionNonThrowing (System.String code) [0x0001c] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-24 21:14:43 -   at IfSharp.Kernel.IfSharpKernel.executeRequest (IfSharp.Kernel.KernelMessage msg, IfSharp.Kernel.ExecuteRequest content) [0x00096] in <5ad0f80e1b085d3da74503830ef8d05a>:0 
2018-04-24 21:14:43 - let compareDataHistogram (dist, values) data =
2018-04-24 21:14:43 -   let histLogProbability = 
2018-04-24 21:14:43 -     values
2018-04-24 21:14:43 -     |> Array.append [| (0.0, 0.0) |]
2018-04-24 21:14:43 -     |> Array.windowed 2
2018-04-24 21:14:43 -     |> Array.map (fun bin ->
2018-04-24 21:14:43 -         let p = bin.[1] |> snd
2018-04-24 21:14:43 -         p, 
2018-04-24 21:14:43 -         data 
2018-04-24 21:14:43 -         |> Array.filter (fun x -> 
2018-04-24 21:14:43 -             x > fst bin.[0] && x <= fst bin.[1])
2018-04-24 21:14:43 -         |> Array.length
2018-04-24 21:14:43 -         |> float)
2018-04-24 21:14:43 -     |> Array.fold (fun pAcc (logp, x) -> x * logp + pAcc) 0.0
2018-04-24 21:14:43 -   dist, histLogProbability
2018-04-24 21:14:44 - let mostLikelyDistribution hists data =
2018-04-24 21:14:44 -   hists
2018-04-24 21:14:44 -   |> Array.map (fun distributionHist -> compareDataHistogram distributionHist data)
2018-04-24 21:14:44 -   |> Array.sortByDescending snd
2018-04-24 21:14:44 -   |> Array.take 10
2018-04-26 17:32:45 - // include directory, this will be replaced by the kernel
2018-04-26 17:32:45 - #I "/home/nbuser/IfSharp/bin"
2018-04-26 17:32:45 - // load base dlls
2018-04-26 17:32:45 - #r "IfSharp.Kernel.dll"
2018-04-26 17:32:45 - #r "NetMQ.dll"
2018-04-26 17:32:45 - // open the global functions and methods
2018-04-26 17:32:45 - open IfSharp.Kernel
2018-04-26 17:32:45 - open IfSharp.Kernel.Globals
2018-04-26 17:33:07 - F# Interactive for F# 4.1
2018-04-26 17:33:07 - Freely distributed under the Apache 2.0 Open Source License
2018-04-26 17:33:07 - For help type #help;;
2018-04-26 17:33:07 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-26 17:33:07 -   seq []
2018-04-26 17:33:07 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-26 17:33:07 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-26 17:33:07 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-26 17:33:07 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-26 17:35:47 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-26 17:43:01 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-26 17:43:05 - #load "Paket.Generated.Refs.fsx"
2018-04-26 17:43:06 - Could not load file '/home/nbuser/IfSharp/bin/.paket/load/main.group.fsx' because it does not exist or is inaccessible
2018-04-26 17:43:06 - open System
2018-04-26 17:43:06 - open MathNet.Numerics
2018-04-26 17:43:06 - open FSharp.Data
2018-04-26 17:43:06 - The namespace or module 'MathNet' is not defined. Maybe you want one of the following:
2018-04-26 17:43:06 -    Math
2018-04-26 17:43:06 - let binSize = 1000.0
2018-04-26 17:43:06 - let roundToBin x =
2018-04-26 17:43:06 -   let m = x % binSize
2018-04-26 17:43:06 -   if m >= binSize/2.0 then // round up
2018-04-26 17:43:06 -     x + binSize - m
2018-04-26 17:43:06 -   else // round down
2018-04-26 17:43:06 -     x - m
2018-04-26 17:43:07 - type DistributionValue = float
2018-04-26 17:43:07 - type Distribution = 
2018-04-26 17:43:07 -   | Gaussian of mean:float * variance:float
2018-04-26 17:43:07 -   | Bernoulli of probability:float
2018-04-26 17:43:08 - let salaries = Gaussian(1000.0, 200.0)
2018-04-26 17:43:08 - let mistake = Bernoulli(0.1)
2018-04-26 17:43:08 - type ProbabilisticComputation<'T> = 
2018-04-26 17:43:08 -   | Sample of Distribution * (DistributionValue -> ProbabilisticComputation<'T>)
2018-04-26 17:43:08 -   | Return of 'T   
2018-04-26 17:43:09 - type ProbabilisticComputationBuilder() = 
2018-04-26 17:43:09 -   member x.Return(v) = Return v
2018-04-26 17:43:09 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-26 17:43:09 - let prob = ProbabilisticComputationBuilder()
2018-04-26 17:43:09 - let model = 
2018-04-26 17:43:09 -   prob {
2018-04-26 17:43:09 -     let! yearlySalary = Gaussian(20000.0, 10000.0)
2018-04-26 17:43:09 -     let! mistake = Bernoulli(0.5)
2018-04-26 17:43:09 -     if mistake = 1.0 then 
2018-04-26 17:43:09 -       return yearlySalary / 12.0
2018-04-26 17:43:09 -     else 
2018-04-26 17:43:09 -       return yearlySalary
2018-04-26 17:43:09 -   }  
2018-04-26 17:43:09 - let varyParameters dist =
2018-04-26 17:43:09 -   match dist with
2018-04-26 17:43:09 -   | Gaussian(m, v) ->
2018-04-26 17:43:09 -      [ for mean in 0.0 .. 2000.0 .. 30000.0 do
2018-04-26 17:43:09 -         for var in 10000000.0 .. 1000000.0 .. 100000000.0 do 
2018-04-26 17:43:09 -           yield Gaussian(mean, var) ]
2018-04-26 17:43:09 -   | Bernoulli(_) ->
2018-04-26 17:43:09 -       [ for pt in 0.0 .. 0.05 .. 1.0 do
2018-04-26 17:43:09 -           yield Bernoulli(pt) ]
2018-04-26 17:43:10 - let discretize dist =
2018-04-26 17:43:10 -   match dist with 
2018-04-26 17:43:10 -   | Bernoulli(prob) -> 
2018-04-26 17:43:10 -       [1.0, prob; 0.0, (1.0 - prob) ]
2018-04-26 17:43:10 -   | Gaussian(mean, var) -> 
2018-04-26 17:43:10 -       [ for x in 0.0 .. binSize .. 110000.0 -> 
2018-04-26 17:43:10 -         // CDF (cummulative density function):   p(x <= N(mean,var)) 
2018-04-26 17:43:10 -         x, Distributions.Normal.CDF(mean, sqrt(var), x)]
2018-04-26 17:43:10 -       |> List.windowed 2
2018-04-26 17:43:10 -       |> List.map (fun w -> 
2018-04-26 17:43:10 -           fst w.[1], snd w.[1] - snd w.[0])
2018-04-26 17:43:10 - The value, namespace, type or module 'Distributions' is not defined. Maybe you want one of the following:
2018-04-26 17:43:10 -    Distribution
2018-04-26 17:43:10 -    DistributionValue
2018-04-26 17:43:10 -    dist
2018-04-26 17:43:10 - let rec enumerate dists choices model = seq {
2018-04-26 17:43:10 -   match model with
2018-04-26 17:43:10 -   | Sample(dist, f) ->
2018-04-26 17:43:10 -      for dist in varyParameters dist do
2018-04-26 17:43:10 -        for v, p in discretize dist do 
2018-04-26 17:43:10 -          yield! enumerate (dist::dists) ((v,p)::choices) (f v)
2018-04-26 17:43:10 -   | Return v -> 
2018-04-26 17:43:10 -       yield List.rev dists, (v, List.rev choices) }
2018-04-26 17:43:10 - The value or constructor 'discretize' is not defined. Maybe you want one of the following:
2018-04-26 17:43:10 -    Directive
2018-04-26 17:43:10 - let histograms = 
2018-04-26 17:43:10 -   enumerate [] [] model
2018-04-26 17:43:10 -   |> Seq.map (fun (dist, (value, trace)) ->
2018-04-26 17:43:10 -       dist, (roundToBin value, trace))
2018-04-26 17:43:10 -   |> Seq.distinct
2018-04-26 17:43:10 -   |> Seq.map (fun (dist, (value, trace)) -> 
2018-04-26 17:43:10 -     let logp = 
2018-04-26 17:43:10 -       trace 
2018-04-26 17:43:10 -       |> List.map (fun (_, p) -> if p = 0.0 then 1e-10 else p)
2018-04-26 17:43:10 -       |> List.map log
2018-04-26 17:43:10 -       |> List.fold (+) 0.0
2018-04-26 17:43:10 -     dist, value, logp)
2018-04-26 17:43:10 -   |> Seq.groupBy (fun (dist, _, _) -> dist)
2018-04-26 17:43:10 -   |> Seq.map (fun (dist, values) ->
2018-04-26 17:43:10 -       dist, 
2018-04-26 17:43:10 -       values |> Seq.map (fun (_, v, p) -> v, p)
2018-04-26 17:43:10 -       |> Array.ofSeq
2018-04-26 17:43:10 -       |> Array.sortBy fst)
2018-04-26 17:43:10 -   |> Array.ofSeq  
2018-04-26 17:43:11 - The value or constructor 'enumerate' is not defined. Maybe you want one of the following:
2018-04-26 17:43:11 -    enum
2018-04-26 17:43:11 - let compareDataHistogram (dist, values) data =
2018-04-26 17:43:11 -   let histLogProbability = 
2018-04-26 17:43:11 -     values
2018-04-26 17:43:11 -     |> Array.append [| (0.0, 0.0) |]
2018-04-26 17:43:11 -     |> Array.windowed 2
2018-04-26 17:43:11 -     |> Array.map (fun bin ->
2018-04-26 17:43:11 -         let p = bin.[1] |> snd
2018-04-26 17:43:11 -         p, 
2018-04-26 17:43:11 -         data 
2018-04-26 17:43:11 -         |> Array.filter (fun x -> 
2018-04-26 17:43:11 -             x > fst bin.[0] && x <= fst bin.[1])
2018-04-26 17:43:11 -         |> Array.length
2018-04-26 17:43:11 -         |> float)
2018-04-26 17:43:11 -     |> Array.fold (fun pAcc (logp, x) -> x * logp + pAcc) 0.0
2018-04-26 17:43:11 -   dist, histLogProbability
2018-04-26 17:43:11 - let mostLikelyDistribution hists data =
2018-04-26 17:43:11 -   hists
2018-04-26 17:43:11 -   |> Array.map (fun distributionHist -> compareDataHistogram distributionHist data)
2018-04-26 17:43:11 -   |> Array.sortByDescending snd
2018-04-26 17:43:11 -   |> Array.take 10
2018-04-26 17:43:32 - #load "Paket.fsx"
2018-04-26 17:43:38 - Paket.Package
2018-04-26 17:43:38 -   [ "MathNet.Numerics"
2018-04-26 17:43:38 -     "MathNet.Numerics.FSharp"
2018-04-26 17:43:38 -     "FSharp.Data"
2018-04-26 17:43:38 -   ]
2018-04-26 17:43:54 - #load "Paket.Generated.Refs.fsx"
2018-04-26 17:44:13 - // On Azure, use the (Unix) terminal window to find these files in ~/IfSharp/bin/
2018-04-26 17:44:13 - #r "packages/MathNet.Numerics/lib/net40/MathNet.Numerics.dll"
2018-04-26 17:44:13 - #r "packages/FSharp.Data/lib/net45/FSharp.Data.dll"
2018-04-26 17:44:13 - open System
2018-04-26 17:44:13 - open MathNet.Numerics
2018-04-26 17:44:13 - open FSharp.Data
2018-04-26 17:44:15 - #load "Paket.fsx"
2018-04-26 17:44:16 - Paket.Package
2018-04-26 17:44:16 -   [ "MathNet.Numerics"
2018-04-26 17:44:16 -     "MathNet.Numerics.FSharp"
2018-04-26 17:44:16 -     "FSharp.Data"
2018-04-26 17:44:16 -   ]
2018-04-26 17:44:18 - #load "Paket.Generated.Refs.fsx"
2018-04-26 17:44:19 - open System
2018-04-26 17:44:19 - open MathNet.Numerics
2018-04-26 17:44:19 - open FSharp.Data
2018-04-26 17:44:19 - let binSize = 1000.0
2018-04-26 17:44:20 - let roundToBin x =
2018-04-26 17:44:20 -   let m = x % binSize
2018-04-26 17:44:20 -   if m >= binSize/2.0 then // round up
2018-04-26 17:44:20 -     x + binSize - m
2018-04-26 17:44:20 -   else // round down
2018-04-26 17:44:20 -     x - m
2018-04-26 17:44:20 - type DistributionValue = float
2018-04-26 17:44:20 - type Distribution = 
2018-04-26 17:44:20 -   | Gaussian of mean:float * variance:float
2018-04-26 17:44:20 -   | Bernoulli of probability:float
2018-04-26 17:44:20 - let salaries = Gaussian(1000.0, 200.0)
2018-04-26 17:44:20 - let mistake = Bernoulli(0.1)
2018-04-26 17:44:21 - type ProbabilisticComputation<'T> = 
2018-04-26 17:44:21 -   | Sample of Distribution * (DistributionValue -> ProbabilisticComputation<'T>)
2018-04-26 17:44:21 -   | Return of 'T   
2018-04-26 17:44:21 - type ProbabilisticComputationBuilder() = 
2018-04-26 17:44:21 -   member x.Return(v) = Return v
2018-04-26 17:44:21 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-26 17:44:21 - let prob = ProbabilisticComputationBuilder()
2018-04-26 17:44:21 - let model = 
2018-04-26 17:44:21 -   prob {
2018-04-26 17:44:21 -     let! yearlySalary = Gaussian(20000.0, 10000.0)
2018-04-26 17:44:21 -     let! mistake = Bernoulli(0.5)
2018-04-26 17:44:21 -     if mistake = 1.0 then 
2018-04-26 17:44:21 -       return yearlySalary / 12.0
2018-04-26 17:44:21 -     else 
2018-04-26 17:44:21 -       return yearlySalary
2018-04-26 17:44:21 -   }  
2018-04-26 17:44:21 - let varyParameters dist =
2018-04-26 17:44:21 -   match dist with
2018-04-26 17:44:21 -   | Gaussian(m, v) ->
2018-04-26 17:44:21 -      [ for mean in 0.0 .. 2000.0 .. 30000.0 do
2018-04-26 17:44:21 -         for var in 10000000.0 .. 1000000.0 .. 100000000.0 do 
2018-04-26 17:44:21 -           yield Gaussian(mean, var) ]
2018-04-26 17:44:21 -   | Bernoulli(_) ->
2018-04-26 17:44:21 -       [ for pt in 0.0 .. 0.05 .. 1.0 do
2018-04-26 17:44:21 -           yield Bernoulli(pt) ]
2018-04-26 17:44:22 - let discretize dist =
2018-04-26 17:44:22 -   match dist with 
2018-04-26 17:44:22 -   | Bernoulli(prob) -> 
2018-04-26 17:44:22 -       [1.0, prob; 0.0, (1.0 - prob) ]
2018-04-26 17:44:22 -   | Gaussian(mean, var) -> 
2018-04-26 17:44:22 -       [ for x in 0.0 .. binSize .. 110000.0 -> 
2018-04-26 17:44:22 -         // CDF (cummulative density function):   p(x <= N(mean,var)) 
2018-04-26 17:44:22 -         x, Distributions.Normal.CDF(mean, sqrt(var), x)]
2018-04-26 17:44:22 -       |> List.windowed 2
2018-04-26 17:44:22 -       |> List.map (fun w -> 
2018-04-26 17:44:22 -           fst w.[1], snd w.[1] - snd w.[0])
2018-04-26 17:44:22 - let rec enumerate dists choices model = seq {
2018-04-26 17:44:22 -   match model with
2018-04-26 17:44:22 -   | Sample(dist, f) ->
2018-04-26 17:44:22 -      for dist in varyParameters dist do
2018-04-26 17:44:22 -        for v, p in discretize dist do 
2018-04-26 17:44:22 -          yield! enumerate (dist::dists) ((v,p)::choices) (f v)
2018-04-26 17:44:22 -   | Return v -> 
2018-04-26 17:44:22 -       yield List.rev dists, (v, List.rev choices) }
2018-04-26 17:44:22 - let histograms = 
2018-04-26 17:44:22 -   enumerate [] [] model
2018-04-26 17:44:22 -   |> Seq.map (fun (dist, (value, trace)) ->
2018-04-26 17:44:22 -       dist, (roundToBin value, trace))
2018-04-26 17:44:22 -   |> Seq.distinct
2018-04-26 17:44:22 -   |> Seq.map (fun (dist, (value, trace)) -> 
2018-04-26 17:44:22 -     let logp = 
2018-04-26 17:44:22 -       trace 
2018-04-26 17:44:22 -       |> List.map (fun (_, p) -> if p = 0.0 then 1e-10 else p)
2018-04-26 17:44:22 -       |> List.map log
2018-04-26 17:44:22 -       |> List.fold (+) 0.0
2018-04-26 17:44:22 -     dist, value, logp)
2018-04-26 17:44:22 -   |> Seq.groupBy (fun (dist, _, _) -> dist)
2018-04-26 17:44:22 -   |> Seq.map (fun (dist, values) ->
2018-04-26 17:44:22 -       dist, 
2018-04-26 17:44:22 -       values |> Seq.map (fun (_, v, p) -> v, p)
2018-04-26 17:44:22 -       |> Array.ofSeq
2018-04-26 17:44:22 -       |> Array.sortBy fst)
2018-04-26 17:44:22 -   |> Array.ofSeq  
2018-04-26 17:57:26 - // include directory, this will be replaced by the kernel
2018-04-26 17:57:26 - #I "/home/nbuser/IfSharp/bin"
2018-04-26 17:57:26 - // load base dlls
2018-04-26 17:57:26 - #r "IfSharp.Kernel.dll"
2018-04-26 17:57:26 - #r "NetMQ.dll"
2018-04-26 17:57:26 - // open the global functions and methods
2018-04-26 17:57:26 - open IfSharp.Kernel
2018-04-26 17:57:26 - open IfSharp.Kernel.Globals
2018-04-26 17:57:45 - F# Interactive for F# 4.1
2018-04-26 17:57:45 - Freely distributed under the Apache 2.0 Open Source License
2018-04-26 17:57:45 - For help type #help;;
2018-04-26 17:57:45 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-26 17:57:45 -   seq []
2018-04-26 17:57:45 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-26 17:57:45 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-26 17:57:45 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-26 17:58:02 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-26 18:03:24 - shutdown request
2018-04-26 18:03:29 - // include directory, this will be replaced by the kernel
2018-04-26 18:03:29 - #I "/home/nbuser/IfSharp/bin"
2018-04-26 18:03:29 - // load base dlls
2018-04-26 18:03:29 - #r "IfSharp.Kernel.dll"
2018-04-26 18:03:29 - #r "NetMQ.dll"
2018-04-26 18:03:29 - // open the global functions and methods
2018-04-26 18:03:29 - open IfSharp.Kernel
2018-04-26 18:03:29 - open IfSharp.Kernel.Globals
2018-04-26 18:03:42 - F# Interactive for F# 4.1
2018-04-26 18:03:42 - Freely distributed under the Apache 2.0 Open Source License
2018-04-26 18:03:42 - For help type #help;;
2018-04-26 18:03:42 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-26 18:03:42 -   seq []
2018-04-26 18:03:42 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-26 18:03:42 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-26 18:03:42 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-26 18:03:43 - (1,2).GetType()
2018-04-26 18:04:18 - [1;2].GetType()
2018-04-26 18:24:50 - #load "Paket.fsx"
2018-04-26 18:24:53 - Paket.Package
2018-04-26 18:24:53 -   [ "MathNet.Numerics"
2018-04-26 18:24:53 -     "MathNet.Numerics.FSharp"
2018-04-26 18:24:53 -     "FSharp.Data"
2018-04-26 18:24:53 -   ]
2018-04-26 18:24:56 - #load "Paket.Generated.Refs.fsx"
2018-04-26 18:24:58 - open System
2018-04-26 18:24:58 - open MathNet.Numerics
2018-04-26 18:24:58 - open FSharp.Data
2018-04-26 18:24:59 - let binSize = 1000.0
2018-04-26 18:24:59 - let roundToBin x =
2018-04-26 18:24:59 -   let m = x % binSize
2018-04-26 18:24:59 -   if m >= binSize/2.0 then // round up
2018-04-26 18:24:59 -     x + binSize - m
2018-04-26 18:24:59 -   else // round down
2018-04-26 18:24:59 -     x - m
2018-04-26 18:24:59 - type DistributionValue = float
2018-04-26 18:25:00 - type Distribution = 
2018-04-26 18:25:00 -   | Gaussian of mean:float * variance:float
2018-04-26 18:25:00 -   | Bernoulli of probability:float
2018-04-26 18:25:00 - let salaries = Gaussian(1000.0, 200.0)
2018-04-26 18:25:00 - let mistake = Bernoulli(0.1)
2018-04-26 18:25:00 - type ProbabilisticComputation<'T> = 
2018-04-26 18:25:00 -   | Sample of Distribution * (DistributionValue -> ProbabilisticComputation<'T>)
2018-04-26 18:25:00 -   | Return of 'T   
2018-04-26 18:25:01 - type ProbabilisticComputationBuilder() = 
2018-04-26 18:25:01 -   member x.Return(v) = Return v
2018-04-26 18:25:01 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-26 18:25:01 - let prob = ProbabilisticComputationBuilder()
2018-04-26 18:25:01 - let model = 
2018-04-26 18:25:01 -   prob {
2018-04-26 18:25:01 -     let! yearlySalary = Gaussian(20000.0, 10000.0)
2018-04-26 18:25:01 -     let! mistake = Bernoulli(0.5)
2018-04-26 18:25:01 -     if mistake = 1.0 then 
2018-04-26 18:25:01 -       return yearlySalary / 12.0
2018-04-26 18:25:01 -     else 
2018-04-26 18:25:01 -       return yearlySalary
2018-04-26 18:25:01 -   }  
2018-04-26 18:25:01 - let varyParameters dist =
2018-04-26 18:25:01 -   match dist with
2018-04-26 18:25:01 -   | Gaussian(m, v) ->
2018-04-26 18:25:01 -      [ for mean in 0.0 .. 2000.0 .. 30000.0 do
2018-04-26 18:25:01 -         for var in 10000000.0 .. 1000000.0 .. 100000000.0 do 
2018-04-26 18:25:01 -           yield Gaussian(mean, var) ]
2018-04-26 18:25:01 -   | Bernoulli(_) ->
2018-04-26 18:25:01 -       [ for pt in 0.0 .. 0.05 .. 1.0 do
2018-04-26 18:25:01 -           yield Bernoulli(pt) ]
2018-04-26 18:25:01 - let discretize dist =
2018-04-26 18:25:01 -   match dist with 
2018-04-26 18:25:01 -   | Bernoulli(prob) -> 
2018-04-26 18:25:01 -       [1.0, prob; 0.0, (1.0 - prob) ]
2018-04-26 18:25:01 -   | Gaussian(mean, var) -> 
2018-04-26 18:25:01 -       [ for x in 0.0 .. binSize .. 110000.0 -> 
2018-04-26 18:25:01 -         // CDF (cummulative density function):   p(x <= N(mean,var)) 
2018-04-26 18:25:01 -         x, Distributions.Normal.CDF(mean, sqrt(var), x)]
2018-04-26 18:25:01 -       |> List.windowed 2
2018-04-26 18:25:01 -       |> List.map (fun w -> 
2018-04-26 18:25:01 -           fst w.[1], snd w.[1] - snd w.[0])
2018-04-26 18:25:02 - let rec enumerate dists choices model = seq {
2018-04-26 18:25:02 -   match model with
2018-04-26 18:25:02 -   | Sample(dist, f) ->
2018-04-26 18:25:02 -      for dist in varyParameters dist do
2018-04-26 18:25:02 -        for v, p in discretize dist do 
2018-04-26 18:25:02 -          yield! enumerate (dist::dists) ((v,p)::choices) (f v)
2018-04-26 18:25:02 -   | Return v -> 
2018-04-26 18:25:02 -       yield List.rev dists, (v, List.rev choices) }
2018-04-26 18:25:02 - let histograms = 
2018-04-26 18:25:02 -   enumerate [] [] model
2018-04-26 18:25:02 -   |> Seq.map (fun (dist, (value, trace)) ->
2018-04-26 18:25:02 -       dist, (roundToBin value, trace))
2018-04-26 18:25:02 -   |> Seq.distinct
2018-04-26 18:25:02 -   |> Seq.map (fun (dist, (value, trace)) -> 
2018-04-26 18:25:02 -     let logp = 
2018-04-26 18:25:02 -       trace 
2018-04-26 18:25:02 -       |> List.map (fun (_, p) -> if p = 0.0 then 1e-10 else p)
2018-04-26 18:25:02 -       |> List.map log
2018-04-26 18:25:02 -       |> List.fold (+) 0.0
2018-04-26 18:25:02 -     dist, value, logp)
2018-04-26 18:25:02 -   |> Seq.groupBy (fun (dist, _, _) -> dist)
2018-04-26 18:25:02 -   |> Seq.map (fun (dist, values) ->
2018-04-26 18:25:02 -       dist, 
2018-04-26 18:25:02 -       values |> Seq.map (fun (_, v, p) -> v, p)
2018-04-26 18:25:02 -       |> Array.ofSeq
2018-04-26 18:25:02 -       |> Array.sortBy fst)
2018-04-26 18:25:02 -   |> Array.ofSeq  
2018-04-26 18:25:41 - shutdown request
2018-04-26 18:25:47 - // include directory, this will be replaced by the kernel
2018-04-26 18:25:47 - #I "/home/nbuser/IfSharp/bin"
2018-04-26 18:25:47 - // load base dlls
2018-04-26 18:25:47 - #r "IfSharp.Kernel.dll"
2018-04-26 18:25:47 - #r "NetMQ.dll"
2018-04-26 18:25:47 - // open the global functions and methods
2018-04-26 18:25:47 - open IfSharp.Kernel
2018-04-26 18:25:47 - open IfSharp.Kernel.Globals
2018-04-26 18:25:59 - F# Interactive for F# 4.1
2018-04-26 18:25:59 - Freely distributed under the Apache 2.0 Open Source License
2018-04-26 18:25:59 - For help type #help;;
2018-04-26 18:25:59 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-26 18:25:59 -   seq []
2018-04-26 18:25:59 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-26 18:25:59 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-26 18:25:59 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-26 18:26:21 - shutdown request
2018-04-26 18:26:23 - // include directory, this will be replaced by the kernel
2018-04-26 18:26:23 - #I "/home/nbuser/IfSharp/bin"
2018-04-26 18:26:23 - // load base dlls
2018-04-26 18:26:23 - #r "IfSharp.Kernel.dll"
2018-04-26 18:26:23 - #r "NetMQ.dll"
2018-04-26 18:26:23 - // open the global functions and methods
2018-04-26 18:26:23 - open IfSharp.Kernel
2018-04-26 18:26:23 - open IfSharp.Kernel.Globals
2018-04-26 18:26:35 - F# Interactive for F# 4.1
2018-04-26 18:26:35 - Freely distributed under the Apache 2.0 Open Source License
2018-04-26 18:26:35 - For help type #help;;
2018-04-26 18:26:35 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-26 18:26:35 -   seq []
2018-04-26 18:26:35 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-26 18:26:35 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-26 18:26:35 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-26 18:26:37 - #load "Paket.fsx"
2018-04-26 18:26:42 - #load "Paket.Generated.Refs.fsx"
2018-04-26 18:26:57 - #load "Paket.fsx"
2018-04-26 18:26:58 - Paket.Package
2018-04-26 18:26:58 -   [ "MathNet.Numerics"
2018-04-26 18:26:58 -     "MathNet.Numerics.FSharp"
2018-04-26 18:26:58 -     "FSharp.Data"
2018-04-26 18:26:58 -   ]
2018-04-26 18:27:01 - #load "Paket.Generated.Refs.fsx"
2018-04-26 18:27:02 - open System
2018-04-26 18:27:02 - open MathNet.Numerics
2018-04-26 18:27:02 - open FSharp.Data
2018-04-26 18:27:02 - let binSize = 1000.0
2018-04-26 18:27:02 - let roundToBin x =
2018-04-26 18:27:02 -   let m = x % binSize
2018-04-26 18:27:02 -   if m >= binSize/2.0 then // round up
2018-04-26 18:27:02 -     x + binSize - m
2018-04-26 18:27:02 -   else // round down
2018-04-26 18:27:02 -     x - m
2018-04-26 18:27:02 - type DistributionValue = float
2018-04-26 18:27:03 - type Distribution = 
2018-04-26 18:27:03 -   | Gaussian of mean:float * variance:float
2018-04-26 18:27:03 -   | Bernoulli of probability:float
2018-04-26 18:27:03 - let salaries = Gaussian(1000.0, 200.0)
2018-04-26 18:27:03 - let mistake = Bernoulli(0.1)
2018-04-26 18:27:04 - type ProbabilisticComputation<'T> = 
2018-04-26 18:27:04 -   | Sample of Distribution * (DistributionValue -> ProbabilisticComputation<'T>)
2018-04-26 18:27:04 -   | Return of 'T   
2018-04-26 18:27:04 - type ProbabilisticComputationBuilder() = 
2018-04-26 18:27:04 -   member x.Return(v) = Return v
2018-04-26 18:27:04 -   member x.Bind(dist, f) = Sample(dist, f) 
2018-04-26 18:27:04 - let prob = ProbabilisticComputationBuilder()
2018-04-26 18:27:04 - let model = 
2018-04-26 18:27:04 -   prob {
2018-04-26 18:27:04 -     let! yearlySalary = Gaussian(20000.0, 10000.0)
2018-04-26 18:27:04 -     let! mistake = Bernoulli(0.5)
2018-04-26 18:27:04 -     if mistake = 1.0 then 
2018-04-26 18:27:04 -       return yearlySalary / 12.0
2018-04-26 18:27:04 -     else 
2018-04-26 18:27:04 -       return yearlySalary
2018-04-26 18:27:04 -   }  
2018-04-26 18:27:04 - let varyParameters dist =
2018-04-26 18:27:04 -   match dist with
2018-04-26 18:27:04 -   | Gaussian(m, v) ->
2018-04-26 18:27:04 -      [ for mean in 0.0 .. 2000.0 .. 30000.0 do
2018-04-26 18:27:04 -         for var in 10000000.0 .. 1000000.0 .. 100000000.0 do 
2018-04-26 18:27:04 -           yield Gaussian(mean, var) ]
2018-04-26 18:27:04 -   | Bernoulli(_) ->
2018-04-26 18:27:04 -       [ for pt in 0.0 .. 0.05 .. 1.0 do
2018-04-26 18:27:04 -           yield Bernoulli(pt) ]
2018-04-26 18:27:05 - let discretize dist =
2018-04-26 18:27:05 -   match dist with 
2018-04-26 18:27:05 -   | Bernoulli(prob) -> 
2018-04-26 18:27:05 -       [1.0, prob; 0.0, (1.0 - prob) ]
2018-04-26 18:27:05 -   | Gaussian(mean, var) -> 
2018-04-26 18:27:05 -       [ for x in 0.0 .. binSize .. 110000.0 -> 
2018-04-26 18:27:05 -         // CDF (cummulative density function):   p(x <= N(mean,var)) 
2018-04-26 18:27:05 -         x, Distributions.Normal.CDF(mean, sqrt(var), x)]
2018-04-26 18:27:05 -       |> List.windowed 2
2018-04-26 18:27:05 -       |> List.map (fun w -> 
2018-04-26 18:27:05 -           fst w.[1], snd w.[1] - snd w.[0])
2018-04-26 18:27:05 - let rec enumerate dists choices model = seq {
2018-04-26 18:27:05 -   match model with
2018-04-26 18:27:05 -   | Sample(dist, f) ->
2018-04-26 18:27:05 -      for dist in varyParameters dist do
2018-04-26 18:27:05 -        for v, p in discretize dist do 
2018-04-26 18:27:05 -          yield! enumerate (dist::dists) ((v,p)::choices) (f v)
2018-04-26 18:27:05 -   | Return v -> 
2018-04-26 18:27:05 -       yield List.rev dists, (v, List.rev choices) }
2018-04-26 18:27:05 - let histograms = 
2018-04-26 18:27:05 -   enumerate [] [] model
2018-04-26 18:27:05 -   |> Seq.map (fun (dist, (value, trace)) ->
2018-04-26 18:27:05 -       dist, (roundToBin value, trace))
2018-04-26 18:27:05 -   |> Seq.distinct
2018-04-26 18:27:05 -   |> Seq.map (fun (dist, (value, trace)) -> 
2018-04-26 18:27:05 -     let logp = 
2018-04-26 18:27:05 -       trace 
2018-04-26 18:27:05 -       |> List.map (fun (_, p) -> if p = 0.0 then 1e-10 else p)
2018-04-26 18:27:05 -       |> List.map log
2018-04-26 18:27:05 -       |> List.fold (+) 0.0
2018-04-26 18:27:05 -     dist, value, logp)
2018-04-26 18:27:05 -   |> Seq.groupBy (fun (dist, _, _) -> dist)
2018-04-26 18:27:05 -   |> Seq.map (fun (dist, values) ->
2018-04-26 18:27:05 -       dist, 
2018-04-26 18:27:05 -       values |> Seq.map (fun (_, v, p) -> v, p)
2018-04-26 18:27:05 -       |> Array.ofSeq
2018-04-26 18:27:05 -       |> Array.sortBy fst)
2018-04-26 18:27:05 -   |> Array.ofSeq  
2018-04-26 18:30:25 - Expression evaluation failed: Object reference not set to an instance of an object
2018-04-26 18:30:25 - NullReferenceExceptionObject reference not set to an instance of an object
2018-04-26 18:30:25 -   at Microsoft.FSharp.Core.Operators.FailurePattern (System.Exception error) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x0002d] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d2] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.StopProcessingRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000b5] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00033] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.ExecInteraction (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate, Microsoft.FSharp.Compiler.Ast+ParsedFsiInteraction action, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger) [0x00010] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.execParsedInteractions (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate, Microsoft.FSharp.Core.FSharpOption`1[T] action, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpOption`1[T] lastResult) [0x002a4] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.Interactive.Shell+clo@2089-298.Invoke (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.CompileOps+TcConfig tcConfig, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x00003] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0000d] in <5939249c904cf4daa74503839c243959>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.mainThreadProcessAction[a,b] (a ctok, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action, b istate) [0x0004a] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x00040] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d2] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.StopProcessingRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000b5] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.mainThreadProcessAction[a,b] (a ctok, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action, b istate) [0x00104] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.mainThreadProcessParsedInteractions (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpOption`1[T] action, Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x0000b] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.Interactive.Shell+EvalInteraction@2232.Invoke (Microsoft.FSharp.Compiler.Interactive.Shell+FsiDynamicCompilerState istate) [0x00013] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00018] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ReraiseIfWatsonable (System.Exception exn) [0x00040] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.ErrorRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000d2] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.ErrorLogger+ErrorLoggerExtensions.ErrorLogger.StopProcessingRecovery (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger x, System.Exception exn, Microsoft.FSharp.Compiler.Range+range m) [0x000b5] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.InteractiveCatch[b] (Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, b istate) [0x00033] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiInteractionProcessor.EvalInteraction (Microsoft.FSharp.Compiler.AbstractIL.Internal.Library+CompilationThreadToken ctok, System.String sourceText, System.String scriptFileName, Microsoft.FSharp.Compiler.ErrorLogger+ErrorLogger errorLogger) [0x00058] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at Microsoft.FSharp.Compiler.Interactive.Shell+FsiEvaluationSession.EvalInteractionNonThrowing (System.String code) [0x0001c] in <590496d0ddab8ea7a7450383d0960459>:0 
2018-04-26 18:30:25 -   at IfSharp.Kernel.IfSharpKernel.executeRequest (IfSharp.Kernel.KernelMessage msg, IfSharp.Kernel.ExecuteRequest content) [0x00096] in <5ad0f80e1b085d3da74503830ef8d05a>:0 
2018-04-26 18:30:26 - let compareDataHistogram (dist, values) data =
2018-04-26 18:30:26 -   let histLogProbability = 
2018-04-26 18:30:26 -     values
2018-04-26 18:30:26 -     |> Array.append [| (0.0, 0.0) |]
2018-04-26 18:30:26 -     |> Array.windowed 2
2018-04-26 18:30:26 -     |> Array.map (fun bin ->
2018-04-26 18:30:26 -         let p = bin.[1] |> snd
2018-04-26 18:30:26 -         p, 
2018-04-26 18:30:26 -         data 
2018-04-26 18:30:26 -         |> Array.filter (fun x -> 
2018-04-26 18:30:26 -             x > fst bin.[0] && x <= fst bin.[1])
2018-04-26 18:30:26 -         |> Array.length
2018-04-26 18:30:26 -         |> float)
2018-04-26 18:30:26 -     |> Array.fold (fun pAcc (logp, x) -> x * logp + pAcc) 0.0
2018-04-26 18:30:26 -   dist, histLogProbability
2018-04-26 18:30:26 - let mostLikelyDistribution hists data =
2018-04-26 18:30:26 -   hists
2018-04-26 18:30:26 -   |> Array.map (fun distributionHist -> compareDataHistogram distributionHist data)
2018-04-26 18:30:26 -   |> Array.sortByDescending snd
2018-04-26 18:30:26 -   |> Array.take 10
2018-04-30 17:18:28 - // include directory, this will be replaced by the kernel
2018-04-30 17:18:28 - #I "/home/nbuser/IfSharp/bin"
2018-04-30 17:18:28 - // load base dlls
2018-04-30 17:18:28 - #r "IfSharp.Kernel.dll"
2018-04-30 17:18:28 - #r "NetMQ.dll"
2018-04-30 17:18:28 - // open the global functions and methods
2018-04-30 17:18:28 - open IfSharp.Kernel
2018-04-30 17:18:28 - open IfSharp.Kernel.Globals
2018-04-30 17:18:46 - F# Interactive for F# 4.1
2018-04-30 17:18:46 - Freely distributed under the Apache 2.0 Open Source License
2018-04-30 17:18:46 - For help type #help;;
2018-04-30 17:18:46 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-30 17:18:46 -   seq []
2018-04-30 17:18:46 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-30 17:18:46 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-30 17:18:46 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-30 17:18:46 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-30 17:19:06 - // include directory, this will be replaced by the kernel
2018-04-30 17:19:06 - #I "/home/nbuser/IfSharp/bin"
2018-04-30 17:19:06 - // load base dlls
2018-04-30 17:19:06 - #r "IfSharp.Kernel.dll"
2018-04-30 17:19:06 - #r "NetMQ.dll"
2018-04-30 17:19:06 - // open the global functions and methods
2018-04-30 17:19:06 - open IfSharp.Kernel
2018-04-30 17:19:06 - open IfSharp.Kernel.Globals
2018-04-30 17:19:22 - F# Interactive for F# 4.1
2018-04-30 17:19:22 - Freely distributed under the Apache 2.0 Open Source License
2018-04-30 17:19:22 - For help type #help;;
2018-04-30 17:19:22 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-04-30 17:19:22 -   seq []
2018-04-30 17:19:22 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-04-30 17:19:22 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-04-30 17:19:22 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-04-30 17:19:31 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-30 17:21:12 - Unknown content type on shell. msg_type is `comm_info_request`
2018-04-30 17:24:35 - Because this is a long notebook, & a mixture of valuable code & less valuable experiments, it is a really good idea to turn on a couple of notebook extensions **Edit > nbextensions config** to open a new browser tab, & then select the following extensions:
2018-04-30 17:24:35 - * Collapsible headings
2018-04-30 17:24:35 - * Intitialization cells (allows you to conveniently run only specific cells   
2018-04-30 17:24:35 - Having selected those check boxes, reload the tab containing this notebook for the changes to take effect.
2018-04-30 17:24:36 - Unexpected keyword 'of' in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2018-04-30 17:24:36 - parse error
2018-06-12 15:57:26 - // include directory, this will be replaced by the kernel
2018-06-12 15:57:26 - #I "/home/nbuser/IfSharp/bin"
2018-06-12 15:57:26 - // load base dlls
2018-06-12 15:57:26 - #r "IfSharp.Kernel.dll"
2018-06-12 15:57:26 - #r "NetMQ.dll"
2018-06-12 15:57:26 - // open the global functions and methods
2018-06-12 15:57:26 - open IfSharp.Kernel
2018-06-12 15:57:26 - open IfSharp.Kernel.Globals
2018-06-12 15:58:03 - F# Interactive for F# 4.1
2018-06-12 15:58:03 - Freely distributed under the Apache 2.0 Open Source License
2018-06-12 15:58:03 - For help type #help;;
2018-06-12 15:58:03 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-06-12 15:58:03 -   seq []
2018-06-12 15:58:03 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-06-12 15:58:03 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-06-12 15:58:03 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-06-12 15:58:03 - Unknown content type on shell. msg_type is `comm_info_request`
2018-06-12 16:03:17 - let wc = new System.Net.WebClient()
2018-06-12 16:03:17 - wc.DownloadFile(
2018-06-12 16:03:17 -     "https://download.microsoft.com/download/D/C/4/DC44E915-26FE-48AB-BD7C-AC1D92B23230/Infer.NET%202.7.1803.1901.zip", 
2018-06-12 16:03:17 -     "/home/nbuser/IfSharp/bin/packages/infer.zip")
2018-06-12 16:03:43 - open System.Diagnostics
2018-06-12 16:03:43 - let ps = 
2018-06-12 16:03:43 -     ProcessStartInfo(
2018-06-12 16:03:43 -         FileName="unzip", 
2018-06-12 16:03:43 -         Arguments="/home/nbuser/IfSharp/bin/packages/infer.zip -d /home/nbuser/IfSharp/bin/packages/infer",
2018-06-12 16:03:43 -         RedirectStandardOutput=true,UseShellExecute=false)
2018-06-12 16:03:43 - let p = Process.Start(ps)
2018-06-12 16:03:43 - p.StandardOutput.ReadToEnd()
2018-06-12 16:04:14 - open System.Diagnostics
2018-06-12 16:04:14 - let ps = 
2018-06-12 16:04:14 -     ProcessStartInfo(
2018-06-12 16:04:14 -         FileName="unzip", 
2018-06-12 16:04:14 -         Arguments="/home/nbuser/IfSharp/bin/packages/infer.zip -d /home/nbuser/IfSharp/bin/packages/infer",
2018-06-12 16:04:14 -         RedirectStandardOutput=true,UseShellExecute=false)
2018-06-12 16:04:14 - let p = Process.Start(ps)
2018-06-12 16:04:14 - p.StandardOutput.ReadToEnd()
2018-06-12 16:04:27 - #r "/home/nbuser/IfSharp/bin/packages/infer/Bin/Infer.FSharp.dll"
2018-06-12 16:05:28 - #load "Paket.fsx"
2018-06-12 16:05:28 - Paket.Package ["Infer.NET"]
2018-06-12 16:05:46 - Expression evaluation failed: Could not find versions for package Infer.NET on https://www.nuget.org/api/v2.
2018-06-12 16:05:46 - ExceptionCould not find versions for package Infer.NET on https://www.nuget.org/api/v2.
2018-06-12 16:05:46 -   at Paket.NuGetV2+versions@892-5.Invoke (System.String message) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Core.PrintfImpl+StringPrintfEnv`1[TResult].Finalize () [0x00012] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Core.PrintfImpl+Final2@235[TState,TResidue,TResult,A,B].Invoke (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] env, A a, B b) [0x0005a] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Core.OptimizedClosures+Invoke@3266-1[T2,T3,TResult,T1].Invoke (T2 u, T3 v) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Core.OptimizedClosures+Invoke@3253[T2,TResult,T1].Invoke (T2 u) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Paket.NuGetV2+versions@892-7.Invoke (System.String arg20) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2) [0x0001f] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Paket.NuGetV2.GetVersions (System.Boolean force, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot, System.String root, System.Collections.Generic.IEnumerable`1[T] sources, Paket.Domain+PackageName packageName) [0x000a5] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Paket.UpdateProcess+SelectiveUpdate@210.Invoke (Paket.ResolverStrategy resolverStrategy, Paket.Domain+GroupName groupName, Paket.Domain+PackageName packageName) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Core.OptimizedClosures+Invoke@3266-1[T2,T3,TResult,T1].Invoke (T2 u, T3 v) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Core.OptimizedClosures+Invoke@3253[T2,TResult,T1].Invoke (T2 u) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Paket.UpdateProcess+SelectiveUpdate@210-5.Invoke (Paket.Domain+PackageName arg30) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2) [0x0001f] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0003d] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W,X] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3, W arg4) [0x00065] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Paket.UpdateProcess.getSortedAndCachedVersionsF@15 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSortedVersionsF, System.Collections.Generic.Dictionary`2[TKey,TValue] allVersions, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.ResolverStrategy resolverStrategy, Paket.Domain+GroupName groupName, Paket.Domain+PackageName packageName) [0x0003b] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Paket.UpdateProcess+getVersionsF@126-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x0013a] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].MoveNextImpl () [0x00017] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].System-Collections-IEnumerator-MoveNext () [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Collections.SeqModule.oneStepTo@986[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i) [0x00045] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Collections.SeqModule.f@4734-2[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i, Microsoft.FSharp.Core.Unit unitVar0) [0x0001f] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Collections.SeqModule+result@1002[T].Invoke (System.Int32 i) [0x00010] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+unfold@199[b,a].DoMoveNext (b& ) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000c] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Collections.Internal+IEnumerator.next@187[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, System.Collections.Generic.IEnumerator`1[T] e, Microsoft.FSharp.Core.FSharpRef`1[T] started, Microsoft.FSharp.Core.Unit unitVar0) [0x00014] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+filter@182[T].System-Collections-IEnumerator-MoveNext () [0x00016] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Collections.SeqModule.IsEmpty[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00063] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Paket.PackageResolver.getCompatibleVersions$cont@432 (Paket.PackageResolver+ResolverStep currentStep, Paket.Domain+GroupName groupName, Paket.Requirements+PackageRequirement currentRequirement, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, System.Boolean globalOverride, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Microsoft.FSharp.Core.Unit unitVar) [0x000d3] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Paket.PackageResolver.getCompatibleVersions (Paket.PackageResolver+ResolverStep currentStep, Paket.Domain+GroupName groupName, Paket.Requirements+PackageRequirement currentRequirement, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, System.Boolean globalOverride, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives) [0x000dc] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Paket.PackageResolver.step@652 (Paket.PackageResolver+UpdateMode updateMode, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Microsoft.FSharp.Core.FSharpOption`1[T] packageFilter, System.Collections.Generic.IDictionary`2[TKey,TValue] rootSettings, Paket.PackageResolver+Stage stage, Paket.PackageResolver+StackPack stackpack, System.Collections.Generic.IEnumerable`1[T] compatibleVersions, Paket.PackageResolver+StepFlags flags) [0x00374] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Paket.PackageResolver.Resolve (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Collections.FSharpSet`1[T] rootDependencies, Paket.PackageResolver+UpdateMode updateMode) [0x00156] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at <StartupCode$Paket-Core>.$DependenciesFile+resolveGroup@173-1[b].Invoke (Paket.Domain+GroupName groupName, b _arg1) [0x000f3] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x0002a] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00014] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:05:46 -   at Paket.DependenciesFile.Resolve[a] (System.Boolean force, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSha1, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] groupsToResolve, Paket.PackageResolver+UpdateMode updateMode) [0x0000f] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Paket.UpdateProcess.selectiveUpdate (System.Boolean force, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSha1, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSortedVersionsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Paket.LockFile lockFile, Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode) [0x00227] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Paket.UpdateProcess.SelectiveUpdate (Paket.DependenciesFile dependenciesFile, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean force) [0x000e0] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Paket.AddProcess.add (System.Boolean installToProjects, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter) [0x00062] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Paket.AddProcess.Add (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean interactive, System.Boolean installAfter) [0x00023] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at <StartupCode$Paket-Core>.$PublicAPI+Add@146-17.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0006f] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String rootFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00084] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs) [0x00025] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:05:46 -   at FSI_0010.Paket.add (System.String package, System.String version) [0x00051] in <a80d297646f44e3ab318c23ad165ffc3>:0 
2018-06-12 16:05:46 -   at FSI_0010.Paket.Package (System.Collections.Generic.IEnumerable`1[T] list) [0x00025] in <a80d297646f44e3ab318c23ad165ffc3>:0 
2018-06-12 16:05:46 -   at <StartupCode$FSI_0011>.$FSI_0011.main@ () [0x00010] in <a80d297646f44e3ab318c23ad165ffc3>:0 
2018-06-12 16:05:46 -   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-06-12 16:05:46 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-06-12 16:07:36 - // include directory, this will be replaced by the kernel
2018-06-12 16:07:36 - #I "/home/nbuser/IfSharp/bin"
2018-06-12 16:07:36 - // load base dlls
2018-06-12 16:07:36 - #r "IfSharp.Kernel.dll"
2018-06-12 16:07:36 - #r "NetMQ.dll"
2018-06-12 16:07:36 - // open the global functions and methods
2018-06-12 16:07:36 - open IfSharp.Kernel
2018-06-12 16:07:36 - open IfSharp.Kernel.Globals
2018-06-12 16:08:15 - F# Interactive for F# 4.1
2018-06-12 16:08:15 - Freely distributed under the Apache 2.0 Open Source License
2018-06-12 16:08:15 - For help type #help;;
2018-06-12 16:08:15 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-06-12 16:08:15 -   seq []
2018-06-12 16:08:15 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-06-12 16:08:15 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-06-12 16:08:15 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-06-12 16:08:35 - Unknown content type on shell. msg_type is `comm_info_request`
2018-06-12 16:08:35 - #load "Paket.fsx"
2018-06-12 16:08:35 - Paket.Dependencies.Install """
2018-06-12 16:08:35 - frameworks: net45
2018-06-12 16:08:35 - source https://nuget.org/api/v2
2018-06-12 16:08:35 - nuget MathNet.Numerics
2018-06-12 16:08:35 - nuget MathNet.Numerics.FSharp
2018-06-12 16:08:35 - nuget FSharp.Data
2018-06-12 16:08:35 - nuget XPlot.Plotly
2018-06-12 16:08:35 - nuget Angara.Base
2018-06-12 16:08:35 - nuget Microsoft.Research.InferNET
2018-06-12 16:08:35 - github roguetrainer/Infer.NET-2.6 Infer.FSharp.dll
2018-06-12 16:08:35 - """
2018-06-12 16:08:35 - Paket.LoadingScripts.ScriptGeneration.generateScriptsForRootFolder 
2018-06-12 16:08:35 -    Paket.LoadingScripts.ScriptGeneration.FSharp
2018-06-12 16:08:35 -    (Paket.FrameworkIdentifier.DotNetFramework Paket.FrameworkVersion.V4_5)
2018-06-12 16:08:35 -    (System.IO.DirectoryInfo __SOURCE_DIRECTORY__)
2018-06-12 16:08:47 - This expression was expected to have type
2018-06-12 16:08:47 -     'Paket.Domain.GroupName list'    
2018-06-12 16:08:47 - but here has type
2018-06-12 16:08:47 -     'Paket.LoadingScripts.ScriptGeneration.ScriptType'    
2018-06-12 16:08:47 - This expression was expected to have type
2018-06-12 16:08:47 -     'Paket.LoadingScripts.ScriptGeneration.ScriptType'    
2018-06-12 16:08:47 - but here has type
2018-06-12 16:08:47 -     'Paket.FrameworkIdentifier'    
2018-06-12 16:08:47 - This expression was expected to have type
2018-06-12 16:08:47 -     'Paket.FrameworkIdentifier'    
2018-06-12 16:08:47 - but here has type
2018-06-12 16:08:47 -     'System.IO.DirectoryInfo'    
2018-06-12 16:11:34 - #load "Paket.fsx"
2018-06-12 16:11:34 - Paket.Package
2018-06-12 16:11:34 -   [ "MathNet.Numerics"
2018-06-12 16:11:34 -     "MathNet.Numerics.FSharp"
2018-06-12 16:11:34 -     "FSharp.Data"
2018-06-12 16:11:34 -     "Microsoft.Research.InferNET"
2018-06-12 16:11:34 -   ]
2018-06-12 16:12:01 - Expression evaluation failed: Non-negative number required.
2018-06-12 16:12:01 - Parameter name: count
2018-06-12 16:12:01 - ArgumentOutOfRangeExceptionNon-negative number required.
2018-06-12 16:12:01 - Parameter name: count
2018-06-12 16:12:01 -   at System.IO.BinaryReader.ReadBytes (System.Int32 count) [0x00013] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-06-12 16:12:01 -   at Mono.Cecil.PE.ImageReader.ReadDebugHeader () [0x000f7] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:12:01 -   at Mono.Cecil.PE.ImageReader.ReadImage () [0x000a8] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:12:01 -   at Mono.Cecil.PE.ImageReader.ReadImage (Mono.Disposable`1[T] stream, System.String file_name) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:12:01 -   at Mono.Cecil.ModuleDefinition.ReadModule (Mono.Disposable`1[T] stream, System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x00006] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:12:01 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x0006c] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:12:01 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:12:01 -   at Mono.Cecil.AssemblyDefinition.ReadAssembly (System.String fileName) [0x00000] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:12:01 -   at Paket.LoadingScripts.PackageAndAssemblyResolution+dllFiles@61.Invoke (System.String path) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:01 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& ) [0x00020] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:01 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000c] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:01 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x0001b] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:01 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00019] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:01 -   at Paket.LoadingScripts.PackageAndAssemblyResolution.getDllsWithinPackage (Paket.FrameworkIdentifier framework, Paket.InstallModel installModel) [0x00017] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:01 -   at Paket.LoadingScripts.ScriptGeneration+generateScripts@315.Invoke (Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] knownIncludeScripts, Paket.PackageResolver+ResolvedPackage package) [0x00072] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:01 -   at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] folder, TState state, System.Collections.Generic.IEnumerable`1[T] source) [0x00037] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:01 -   at Paket.LoadingScripts.ScriptGeneration.generateScripts (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] writeScript, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getScriptFile, System.IO.DirectoryInfo includeScriptsRootFolder, Paket.FrameworkIdentifier framework, Paket.LockFile lockFile, System.IO.DirectoryInfo packagesOrGroupFolder, Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] orderedPackages) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:01 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolderGeneric@370.Invoke (Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] packages) [0x00088] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:01 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x0002a] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:01 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00014] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:01 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:01 -   at Paket.LoadingScripts.ScriptGeneration.generateScriptsForRootFolderGeneric (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.String extension, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptWriter, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterFrameworkLibs, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterNuget, Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x0009d] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:01 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolder@408-8.Invoke (Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:01 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0000d] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:01 -   at Paket.LoadingScripts.ScriptGeneration.executeCommand (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.IO.DirectoryInfo directory, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes) [0x0022c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:01 -   at Paket.UpdateProcess.SmartInstall (Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.UpdaterOptions options) [0x00178] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:01 -   at <StartupCode$Paket-Core>.$PublicAPI+Install@179.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0002e] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:01 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String rootFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00084] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:01 -   at Paket.Dependencies.Install (Paket.InstallerOptions options) [0x00013] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:01 -   at Paket.Dependencies.Install (System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean onlyReferenced, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean generateLoadScripts, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot) [0x0005c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:01 -   at Paket.Dependencies.Install (System.Boolean force) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:01 -   at FSI_0006.Paket.Package (System.Collections.Generic.IEnumerable`1[T] list) [0x00075] in <54c7369267b94124b01e0735bc3d7f32>:0 
2018-06-12 16:12:01 -   at <StartupCode$FSI_0007>.$FSI_0007.main@ () [0x0002e] in <54c7369267b94124b01e0735bc3d7f32>:0 
2018-06-12 16:12:01 -   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-06-12 16:12:01 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-06-12 16:12:31 - #load "Paket.fsx"
2018-06-12 16:12:32 - Expression evaluation failed: Non-negative number required.
2018-06-12 16:12:32 - Parameter name: count
2018-06-12 16:12:32 - ArgumentOutOfRangeExceptionNon-negative number required.
2018-06-12 16:12:32 - Parameter name: count
2018-06-12 16:12:32 -   at System.IO.BinaryReader.ReadBytes (System.Int32 count) [0x00013] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-06-12 16:12:32 -   at Mono.Cecil.PE.ImageReader.ReadDebugHeader () [0x000f7] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:12:32 -   at Mono.Cecil.PE.ImageReader.ReadImage () [0x000a8] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:12:32 -   at Mono.Cecil.PE.ImageReader.ReadImage (Mono.Disposable`1[T] stream, System.String file_name) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:12:32 -   at Mono.Cecil.ModuleDefinition.ReadModule (Mono.Disposable`1[T] stream, System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x00006] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:12:32 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x0006c] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:12:32 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:12:32 -   at Mono.Cecil.AssemblyDefinition.ReadAssembly (System.String fileName) [0x00000] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:12:32 -   at Paket.LoadingScripts.PackageAndAssemblyResolution+dllFiles@61.Invoke (System.String path) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:32 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& ) [0x00020] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:32 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000c] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:32 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x0001b] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:32 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00019] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:32 -   at Paket.LoadingScripts.PackageAndAssemblyResolution.getDllsWithinPackage (Paket.FrameworkIdentifier framework, Paket.InstallModel installModel) [0x00017] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:32 -   at Paket.LoadingScripts.ScriptGeneration+generateScripts@315.Invoke (Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] knownIncludeScripts, Paket.PackageResolver+ResolvedPackage package) [0x00072] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:32 -   at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] folder, TState state, System.Collections.Generic.IEnumerable`1[T] source) [0x00037] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:32 -   at Paket.LoadingScripts.ScriptGeneration.generateScripts (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] writeScript, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getScriptFile, System.IO.DirectoryInfo includeScriptsRootFolder, Paket.FrameworkIdentifier framework, Paket.LockFile lockFile, System.IO.DirectoryInfo packagesOrGroupFolder, Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] orderedPackages) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:32 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolderGeneric@370.Invoke (Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] packages) [0x00088] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:32 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x0002a] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:32 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00014] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:32 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:32 -   at Paket.LoadingScripts.ScriptGeneration.generateScriptsForRootFolderGeneric (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.String extension, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptWriter, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterFrameworkLibs, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterNuget, Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x0009d] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:32 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolder@408-8.Invoke (Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:32 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0000d] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:12:32 -   at Paket.LoadingScripts.ScriptGeneration.executeCommand (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.IO.DirectoryInfo directory, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes) [0x0022c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:32 -   at Paket.RestoreProcess.Restore (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] projectFile, System.Boolean force, Microsoft.FSharp.Core.FSharpOption`1[T] group, Microsoft.FSharp.Collections.FSharpList`1[T] referencesFileNames, System.Boolean ignoreChecks, System.Boolean failOnChecks) [0x00481] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:32 -   at <StartupCode$Paket-Core>.$PublicAPI+Restore@282-10.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x00052] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:32 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String rootFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00084] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:32 -   at Paket.Dependencies.Restore (System.Boolean force, Microsoft.FSharp.Core.FSharpOption`1[T] group, Microsoft.FSharp.Collections.FSharpList`1[T] files, System.Boolean touchAffectedRefs, System.Boolean ignoreChecks, System.Boolean failOnChecks) [0x0001b] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:32 -   at Paket.Dependencies.Restore (System.Boolean ignoreChecks) [0x00009] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:12:32 -   at <StartupCode$FSI_0008>.$FSI_0008_Paket$fsx.main@ () [0x0006d] in <54c7369267b94124b01e0735bc3d7f32>:0 
2018-06-12 16:12:32 -   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-06-12 16:12:32 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-06-12 16:13:01 - #load "Paket.fsx"
2018-06-12 16:13:02 - Expression evaluation failed: Non-negative number required.
2018-06-12 16:13:02 - Parameter name: count
2018-06-12 16:13:02 - ArgumentOutOfRangeExceptionNon-negative number required.
2018-06-12 16:13:02 - Parameter name: count
2018-06-12 16:13:02 -   at System.IO.BinaryReader.ReadBytes (System.Int32 count) [0x00013] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-06-12 16:13:02 -   at Mono.Cecil.PE.ImageReader.ReadDebugHeader () [0x000f7] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:13:02 -   at Mono.Cecil.PE.ImageReader.ReadImage () [0x000a8] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:13:02 -   at Mono.Cecil.PE.ImageReader.ReadImage (Mono.Disposable`1[T] stream, System.String file_name) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:13:02 -   at Mono.Cecil.ModuleDefinition.ReadModule (Mono.Disposable`1[T] stream, System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x00006] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:13:02 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x0006c] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:13:02 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:13:02 -   at Mono.Cecil.AssemblyDefinition.ReadAssembly (System.String fileName) [0x00000] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 16:13:02 -   at Paket.LoadingScripts.PackageAndAssemblyResolution+dllFiles@61.Invoke (System.String path) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:13:02 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& ) [0x00020] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:13:02 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000c] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:13:02 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x0001b] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:13:02 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00019] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:13:02 -   at Paket.LoadingScripts.PackageAndAssemblyResolution.getDllsWithinPackage (Paket.FrameworkIdentifier framework, Paket.InstallModel installModel) [0x00017] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:13:02 -   at Paket.LoadingScripts.ScriptGeneration+generateScripts@315.Invoke (Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] knownIncludeScripts, Paket.PackageResolver+ResolvedPackage package) [0x00072] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:13:02 -   at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] folder, TState state, System.Collections.Generic.IEnumerable`1[T] source) [0x00037] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:13:02 -   at Paket.LoadingScripts.ScriptGeneration.generateScripts (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] writeScript, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getScriptFile, System.IO.DirectoryInfo includeScriptsRootFolder, Paket.FrameworkIdentifier framework, Paket.LockFile lockFile, System.IO.DirectoryInfo packagesOrGroupFolder, Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] orderedPackages) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:13:02 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolderGeneric@370.Invoke (Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] packages) [0x00088] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:13:02 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x0002a] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:13:02 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00014] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:13:02 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:13:02 -   at Paket.LoadingScripts.ScriptGeneration.generateScriptsForRootFolderGeneric (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.String extension, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptWriter, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterFrameworkLibs, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterNuget, Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x0009d] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:13:02 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolder@408-8.Invoke (Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:13:02 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0000d] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 16:13:02 -   at Paket.LoadingScripts.ScriptGeneration.executeCommand (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.IO.DirectoryInfo directory, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes) [0x0022c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:13:02 -   at Paket.RestoreProcess.Restore (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] projectFile, System.Boolean force, Microsoft.FSharp.Core.FSharpOption`1[T] group, Microsoft.FSharp.Collections.FSharpList`1[T] referencesFileNames, System.Boolean ignoreChecks, System.Boolean failOnChecks) [0x00481] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:13:02 -   at <StartupCode$Paket-Core>.$PublicAPI+Restore@282-10.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x00052] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:13:02 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String rootFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00084] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:13:02 -   at Paket.Dependencies.Restore (System.Boolean force, Microsoft.FSharp.Core.FSharpOption`1[T] group, Microsoft.FSharp.Collections.FSharpList`1[T] files, System.Boolean touchAffectedRefs, System.Boolean ignoreChecks, System.Boolean failOnChecks) [0x0001b] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:13:02 -   at Paket.Dependencies.Restore (System.Boolean ignoreChecks) [0x00009] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 16:13:02 -   at <StartupCode$FSI_0009>.$FSI_0009_Paket$fsx.main@ () [0x0006d] in <54c7369267b94124b01e0735bc3d7f32>:0 
2018-06-12 16:13:02 -   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-06-12 16:13:02 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-06-12 20:19:52 - let wc = new System.Net.WebClient()
2018-06-12 20:19:52 - wc.DownloadFile(
2018-06-12 20:19:52 -     "https://download.microsoft.com/download/D/C/4/DC44E915-26FE-48AB-BD7C-AC1D92B23230/Infer.NET%202.7.1803.1901.zip", 
2018-06-12 20:19:52 -     "/home/nbuser/IfSharp/bin/packages/infer.zip")
2018-06-12 20:46:59 - #load "Paket.fsx"
2018-06-12 20:47:02 - Expression evaluation failed: Non-negative number required.
2018-06-12 20:47:02 - Parameter name: count
2018-06-12 20:47:02 - ArgumentOutOfRangeExceptionNon-negative number required.
2018-06-12 20:47:02 - Parameter name: count
2018-06-12 20:47:02 -   at System.IO.BinaryReader.ReadBytes (System.Int32 count) [0x00013] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-06-12 20:47:02 -   at Mono.Cecil.PE.ImageReader.ReadDebugHeader () [0x000f7] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 20:47:02 -   at Mono.Cecil.PE.ImageReader.ReadImage () [0x000a8] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 20:47:02 -   at Mono.Cecil.PE.ImageReader.ReadImage (Mono.Disposable`1[T] stream, System.String file_name) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 20:47:02 -   at Mono.Cecil.ModuleDefinition.ReadModule (Mono.Disposable`1[T] stream, System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x00006] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 20:47:02 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x0006c] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 20:47:02 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 20:47:02 -   at Mono.Cecil.AssemblyDefinition.ReadAssembly (System.String fileName) [0x00000] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 20:47:02 -   at Paket.LoadingScripts.PackageAndAssemblyResolution+dllFiles@61.Invoke (System.String path) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:02 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& ) [0x00020] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:02 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000c] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:02 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x0001b] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:02 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00019] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:02 -   at Paket.LoadingScripts.PackageAndAssemblyResolution.getDllsWithinPackage (Paket.FrameworkIdentifier framework, Paket.InstallModel installModel) [0x00017] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:02 -   at Paket.LoadingScripts.ScriptGeneration+generateScripts@315.Invoke (Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] knownIncludeScripts, Paket.PackageResolver+ResolvedPackage package) [0x00072] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:02 -   at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] folder, TState state, System.Collections.Generic.IEnumerable`1[T] source) [0x00037] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:02 -   at Paket.LoadingScripts.ScriptGeneration.generateScripts (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] writeScript, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getScriptFile, System.IO.DirectoryInfo includeScriptsRootFolder, Paket.FrameworkIdentifier framework, Paket.LockFile lockFile, System.IO.DirectoryInfo packagesOrGroupFolder, Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] orderedPackages) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:02 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolderGeneric@370.Invoke (Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] packages) [0x00088] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:02 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x0002a] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:02 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00014] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:02 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:02 -   at Paket.LoadingScripts.ScriptGeneration.generateScriptsForRootFolderGeneric (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.String extension, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptWriter, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterFrameworkLibs, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterNuget, Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x0009d] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:02 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolder@408-8.Invoke (Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:02 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0000d] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:02 -   at Paket.LoadingScripts.ScriptGeneration.executeCommand (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.IO.DirectoryInfo directory, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes) [0x0022c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:02 -   at Paket.RestoreProcess.Restore (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] projectFile, System.Boolean force, Microsoft.FSharp.Core.FSharpOption`1[T] group, Microsoft.FSharp.Collections.FSharpList`1[T] referencesFileNames, System.Boolean ignoreChecks, System.Boolean failOnChecks) [0x00481] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:02 -   at <StartupCode$Paket-Core>.$PublicAPI+Restore@282-10.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x00052] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:02 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String rootFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00084] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:02 -   at Paket.Dependencies.Restore (System.Boolean force, Microsoft.FSharp.Core.FSharpOption`1[T] group, Microsoft.FSharp.Collections.FSharpList`1[T] files, System.Boolean touchAffectedRefs, System.Boolean ignoreChecks, System.Boolean failOnChecks) [0x0001b] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:02 -   at Paket.Dependencies.Restore (System.Boolean ignoreChecks) [0x00009] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:02 -   at <StartupCode$FSI_0010>.$FSI_0010_Paket$fsx.main@ () [0x0006d] in <54c7369267b94124b01e0735bc3d7f32>:0 
2018-06-12 20:47:02 -   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-06-12 20:47:02 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-06-12 20:47:22 - shutdown request
2018-06-12 20:47:29 - // include directory, this will be replaced by the kernel
2018-06-12 20:47:29 - #I "/home/nbuser/IfSharp/bin"
2018-06-12 20:47:29 - // load base dlls
2018-06-12 20:47:29 - #r "IfSharp.Kernel.dll"
2018-06-12 20:47:29 - #r "NetMQ.dll"
2018-06-12 20:47:29 - // open the global functions and methods
2018-06-12 20:47:29 - open IfSharp.Kernel
2018-06-12 20:47:29 - open IfSharp.Kernel.Globals
2018-06-12 20:47:35 - F# Interactive for F# 4.1
2018-06-12 20:47:35 - Freely distributed under the Apache 2.0 Open Source License
2018-06-12 20:47:35 - For help type #help;;
2018-06-12 20:47:35 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-06-12 20:47:35 -   seq []
2018-06-12 20:47:35 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-06-12 20:47:35 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-06-12 20:47:35 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-06-12 20:47:35 - #load "Paket.fsx"
2018-06-12 20:47:37 - Expression evaluation failed: Non-negative number required.
2018-06-12 20:47:37 - Parameter name: count
2018-06-12 20:47:37 - ArgumentOutOfRangeExceptionNon-negative number required.
2018-06-12 20:47:37 - Parameter name: count
2018-06-12 20:47:37 -   at System.IO.BinaryReader.ReadBytes (System.Int32 count) [0x00013] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-06-12 20:47:37 -   at Mono.Cecil.PE.ImageReader.ReadDebugHeader () [0x000f7] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 20:47:37 -   at Mono.Cecil.PE.ImageReader.ReadImage () [0x000a8] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 20:47:37 -   at Mono.Cecil.PE.ImageReader.ReadImage (Mono.Disposable`1[T] stream, System.String file_name) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 20:47:37 -   at Mono.Cecil.ModuleDefinition.ReadModule (Mono.Disposable`1[T] stream, System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x00006] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 20:47:37 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x0006c] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 20:47:37 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 20:47:37 -   at Mono.Cecil.AssemblyDefinition.ReadAssembly (System.String fileName) [0x00000] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-06-12 20:47:37 -   at Paket.LoadingScripts.PackageAndAssemblyResolution+dllFiles@61.Invoke (System.String path) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:37 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& ) [0x00020] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:37 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000c] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:37 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x0001b] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:37 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00019] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:37 -   at Paket.LoadingScripts.PackageAndAssemblyResolution.getDllsWithinPackage (Paket.FrameworkIdentifier framework, Paket.InstallModel installModel) [0x00017] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:37 -   at Paket.LoadingScripts.ScriptGeneration+generateScripts@315.Invoke (Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] knownIncludeScripts, Paket.PackageResolver+ResolvedPackage package) [0x00072] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:37 -   at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] folder, TState state, System.Collections.Generic.IEnumerable`1[T] source) [0x00037] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:37 -   at Paket.LoadingScripts.ScriptGeneration.generateScripts (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] writeScript, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getScriptFile, System.IO.DirectoryInfo includeScriptsRootFolder, Paket.FrameworkIdentifier framework, Paket.LockFile lockFile, System.IO.DirectoryInfo packagesOrGroupFolder, Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] orderedPackages) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:37 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolderGeneric@370.Invoke (Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] packages) [0x00088] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:37 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x0002a] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:37 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00014] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:37 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:37 -   at Paket.LoadingScripts.ScriptGeneration.generateScriptsForRootFolderGeneric (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.String extension, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptWriter, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterFrameworkLibs, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterNuget, Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x0009d] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:37 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolder@408-8.Invoke (Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:37 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0000d] in <5939249c904cf4daa74503839c243959>:0 
2018-06-12 20:47:37 -   at Paket.LoadingScripts.ScriptGeneration.executeCommand (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.IO.DirectoryInfo directory, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes) [0x0022c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:37 -   at Paket.RestoreProcess.Restore (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] projectFile, System.Boolean force, Microsoft.FSharp.Core.FSharpOption`1[T] group, Microsoft.FSharp.Collections.FSharpList`1[T] referencesFileNames, System.Boolean ignoreChecks, System.Boolean failOnChecks) [0x00481] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:37 -   at <StartupCode$Paket-Core>.$PublicAPI+Restore@282-10.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x00052] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:37 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String rootFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00084] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:37 -   at Paket.Dependencies.Restore (System.Boolean force, Microsoft.FSharp.Core.FSharpOption`1[T] group, Microsoft.FSharp.Collections.FSharpList`1[T] files, System.Boolean touchAffectedRefs, System.Boolean ignoreChecks, System.Boolean failOnChecks) [0x0001b] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:37 -   at Paket.Dependencies.Restore (System.Boolean ignoreChecks) [0x00009] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-06-12 20:47:37 -   at <StartupCode$FSI_0004>.$FSI_0004_Paket$fsx.main@ () [0x0006d] in <9cf091439ea549cca8b62cadc7768656>:0 
2018-06-12 20:47:37 -   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-06-12 20:47:37 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-06-13 14:37:37 - // include directory, this will be replaced by the kernel
2018-06-13 14:37:37 - #I "/home/nbuser/IfSharp/bin"
2018-06-13 14:37:37 - // load base dlls
2018-06-13 14:37:37 - #r "IfSharp.Kernel.dll"
2018-06-13 14:37:37 - #r "NetMQ.dll"
2018-06-13 14:37:37 - // open the global functions and methods
2018-06-13 14:37:37 - open IfSharp.Kernel
2018-06-13 14:37:37 - open IfSharp.Kernel.Globals
2018-06-13 14:38:07 - F# Interactive for F# 4.1
2018-06-13 14:38:07 - Freely distributed under the Apache 2.0 Open Source License
2018-06-13 14:38:07 - For help type #help;;
2018-06-13 14:38:07 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-06-13 14:38:07 -   seq []
2018-06-13 14:38:07 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-06-13 14:38:07 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-06-13 14:38:07 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-06-13 14:38:08 - Unknown content type on shell. msg_type is `comm_info_request`
2018-06-13 14:38:22 - #load "Paket.fsx"
2018-06-13 14:38:30 - Paket.Package
2018-06-13 14:38:30 -   [ "MathNet.Numerics"
2018-06-13 14:38:30 -     "MathNet.Numerics.FSharp"
2018-06-13 14:38:30 -     "FSharp.Data"
2018-06-13 14:38:30 -   ]
2018-06-13 14:38:51 - #load "Paket.Generated.Refs.fsx"
2018-06-13 17:00:26 - (*
2018-06-13 17:00:26 - #load "Paket.fsx"
2018-06-13 17:00:26 - Paket.Dependencies.Install """
2018-06-13 17:00:26 - frameworks: net45
2018-06-13 17:00:26 - source https://nuget.org/api/v2
2018-06-13 17:00:26 - nuget MathNet.Numerics
2018-06-13 17:00:26 - nuget MathNet.Numerics.FSharp
2018-06-13 17:00:26 - nuget FSharp.Data
2018-06-13 17:00:26 - nuget XPlot.Plotly
2018-06-13 17:00:26 - nuget Angara.Base
2018-06-13 17:00:26 - nuget Microsoft.Research.InferNET
2018-06-13 17:00:26 - github roguetrainer/Infer.NET-2.6 Infer.FSharp.dll
2018-06-13 17:00:26 - """
2018-06-13 17:00:26 - Paket.LoadingScripts.ScriptGeneration.generateScriptsForRootFolder 
2018-06-13 17:00:26 -    Paket.LoadingScripts.ScriptGeneration.FSharp
2018-06-13 17:00:26 -    (Paket.FrameworkIdentifier.DotNetFramework Paket.FrameworkVersion.V4_5)
2018-06-13 17:00:26 -    (System.IO.DirectoryInfo __SOURCE_DIRECTORY__)
2018-06-13 17:00:26 -    *)
2018-06-15 19:59:58 - // include directory, this will be replaced by the kernel
2018-06-15 19:59:58 - #I "/home/nbuser/IfSharp/bin"
2018-06-15 19:59:58 - // load base dlls
2018-06-15 19:59:58 - #r "IfSharp.Kernel.dll"
2018-06-15 19:59:58 - #r "NetMQ.dll"
2018-06-15 19:59:58 - // open the global functions and methods
2018-06-15 19:59:58 - open IfSharp.Kernel
2018-06-15 19:59:58 - open IfSharp.Kernel.Globals
2018-06-15 20:00:40 - F# Interactive for F# 4.1
2018-06-15 20:00:40 - Freely distributed under the Apache 2.0 Open Source License
2018-06-15 20:00:40 - For help type #help;;
2018-06-15 20:00:40 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-06-15 20:00:40 -   seq []
2018-06-15 20:00:40 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-06-15 20:00:40 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-06-15 20:00:40 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-06-15 20:00:41 - Unknown content type on shell. msg_type is `comm_info_request`
2018-06-18 16:05:59 - // include directory, this will be replaced by the kernel
2018-06-18 16:06:00 - #I "/home/nbuser/IfSharp/bin"
2018-06-18 16:06:00 - // load base dlls
2018-06-18 16:06:00 - #r "IfSharp.Kernel.dll"
2018-06-18 16:06:00 - #r "NetMQ.dll"
2018-06-18 16:06:00 - // open the global functions and methods
2018-06-18 16:06:00 - open IfSharp.Kernel
2018-06-18 16:06:00 - open IfSharp.Kernel.Globals
2018-06-18 16:06:39 - F# Interactive for F# 4.1
2018-06-18 16:06:39 - Freely distributed under the Apache 2.0 Open Source License
2018-06-18 16:06:39 - For help type #help;;
2018-06-18 16:06:39 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-06-18 16:06:39 -   seq []
2018-06-18 16:06:39 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-06-18 16:06:39 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-06-18 16:06:39 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-06-18 16:06:41 - Unknown content type on shell. msg_type is `comm_info_request`
2018-06-18 16:36:17 - Unknown content type on shell. msg_type is `comm_info_request`
2018-07-11 18:16:02 - // include directory, this will be replaced by the kernel
2018-07-11 18:16:02 - #I "/home/nbuser/IfSharp/bin"
2018-07-11 18:16:02 - // load base dlls
2018-07-11 18:16:02 - #r "IfSharp.Kernel.dll"
2018-07-11 18:16:02 - #r "NetMQ.dll"
2018-07-11 18:16:02 - // open the global functions and methods
2018-07-11 18:16:02 - open IfSharp.Kernel
2018-07-11 18:16:02 - open IfSharp.Kernel.Globals
2018-07-11 18:16:43 - F# Interactive for F# 4.1
2018-07-11 18:16:43 - Freely distributed under the Apache 2.0 Open Source License
2018-07-11 18:16:43 - For help type #help;;
2018-07-11 18:16:43 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-07-11 18:16:43 -   seq []
2018-07-11 18:16:43 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-07-11 18:16:43 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-07-11 18:16:43 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-07-11 18:16:44 - Unknown content type on shell. msg_type is `comm_info_request`
2018-07-11 18:23:04 - // include directory, this will be replaced by the kernel
2018-07-11 18:23:04 - #I "/home/nbuser/IfSharp/bin"
2018-07-11 18:23:04 - // load base dlls
2018-07-11 18:23:04 - #r "IfSharp.Kernel.dll"
2018-07-11 18:23:04 - #r "NetMQ.dll"
2018-07-11 18:23:04 - // open the global functions and methods
2018-07-11 18:23:04 - open IfSharp.Kernel
2018-07-11 18:23:04 - open IfSharp.Kernel.Globals
2018-07-11 18:23:17 - F# Interactive for F# 4.1
2018-07-11 18:23:17 - Freely distributed under the Apache 2.0 Open Source License
2018-07-11 18:23:17 - For help type #help;;
2018-07-11 18:23:17 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-07-11 18:23:17 -   seq []
2018-07-11 18:23:17 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-07-11 18:23:17 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-07-11 18:23:17 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-07-11 18:23:18 - Unknown content type on shell. msg_type is `comm_info_request`
2018-07-11 18:26:17 - #load "Paket.fsx"
2018-07-11 18:26:22 - Paket.Package
2018-07-11 18:26:22 -   [ "MathNet.Numerics"
2018-07-11 18:26:22 -     "MathNet.Numerics.FSharp"
2018-07-11 18:26:22 -     "FSharp.Data"
2018-07-11 18:26:22 -     "Microsoft.Research.InferNET"
2018-07-11 18:26:22 -   ]
2018-07-11 18:26:38 - Expression evaluation failed: Non-negative number required.
2018-07-11 18:26:38 - Parameter name: count
2018-07-11 18:26:38 - ArgumentOutOfRangeExceptionNon-negative number required.
2018-07-11 18:26:38 - Parameter name: count
2018-07-11 18:26:38 -   at System.IO.BinaryReader.ReadBytes (System.Int32 count) [0x00013] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-07-11 18:26:38 -   at Mono.Cecil.PE.ImageReader.ReadDebugHeader () [0x000f7] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:26:38 -   at Mono.Cecil.PE.ImageReader.ReadImage () [0x000a8] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:26:38 -   at Mono.Cecil.PE.ImageReader.ReadImage (Mono.Disposable`1[T] stream, System.String file_name) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:26:38 -   at Mono.Cecil.ModuleDefinition.ReadModule (Mono.Disposable`1[T] stream, System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x00006] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:26:38 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x0006c] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:26:38 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:26:38 -   at Mono.Cecil.AssemblyDefinition.ReadAssembly (System.String fileName) [0x00000] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:26:38 -   at Paket.LoadingScripts.PackageAndAssemblyResolution+dllFiles@61.Invoke (System.String path) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:26:38 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& ) [0x00020] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:26:38 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000c] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:26:38 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x0001b] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:26:38 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00019] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:26:38 -   at Paket.LoadingScripts.PackageAndAssemblyResolution.getDllsWithinPackage (Paket.FrameworkIdentifier framework, Paket.InstallModel installModel) [0x00017] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:26:38 -   at Paket.LoadingScripts.ScriptGeneration+generateScripts@315.Invoke (Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] knownIncludeScripts, Paket.PackageResolver+ResolvedPackage package) [0x00072] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:26:38 -   at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] folder, TState state, System.Collections.Generic.IEnumerable`1[T] source) [0x00037] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:26:38 -   at Paket.LoadingScripts.ScriptGeneration.generateScripts (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] writeScript, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getScriptFile, System.IO.DirectoryInfo includeScriptsRootFolder, Paket.FrameworkIdentifier framework, Paket.LockFile lockFile, System.IO.DirectoryInfo packagesOrGroupFolder, Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] orderedPackages) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:26:38 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolderGeneric@370.Invoke (Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] packages) [0x00088] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:26:38 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x0002a] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:26:38 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00014] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:26:38 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:26:38 -   at Paket.LoadingScripts.ScriptGeneration.generateScriptsForRootFolderGeneric (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.String extension, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptWriter, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterFrameworkLibs, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterNuget, Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x0009d] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:26:38 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolder@408-8.Invoke (Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:26:38 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0000d] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:26:38 -   at Paket.LoadingScripts.ScriptGeneration.executeCommand (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.IO.DirectoryInfo directory, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes) [0x0022c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:26:38 -   at Paket.UpdateProcess.SmartInstall (Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.UpdaterOptions options) [0x00178] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:26:38 -   at <StartupCode$Paket-Core>.$PublicAPI+Install@179.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0002e] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:26:38 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String rootFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00084] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:26:38 -   at Paket.Dependencies.Install (Paket.InstallerOptions options) [0x00013] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:26:38 -   at Paket.Dependencies.Install (System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean onlyReferenced, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean generateLoadScripts, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot) [0x0005c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:26:38 -   at Paket.Dependencies.Install (System.Boolean force) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:26:38 -   at FSI_0004.Paket.Package (System.Collections.Generic.IEnumerable`1[T] list) [0x00075] in <a8226ed46930477caea8d6210b77f50c>:0 
2018-07-11 18:26:38 -   at <StartupCode$FSI_0005>.$FSI_0005.main@ () [0x0002e] in <a8226ed46930477caea8d6210b77f50c>:0 
2018-07-11 18:26:38 -   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-07-11 18:26:38 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-07-11 18:26:38 - #load "Paket.Generated.Refs.fsx"
2018-07-11 18:26:39 - Could not load file '/home/nbuser/IfSharp/bin/.paket/load/main.group.fsx' because it does not exist or is inaccessible
2018-07-11 18:27:00 - Paket.Package
2018-07-11 18:27:00 -   [ "MathNet.Numerics"
2018-07-11 18:27:00 -     "MathNet.Numerics.FSharp"
2018-07-11 18:27:00 -     "FSharp.Data"
2018-07-11 18:27:00 -     "Microsoft.Research.InferNET"
2018-07-11 18:27:00 -   ]
2018-07-11 18:27:02 - Expression evaluation failed: Non-negative number required.
2018-07-11 18:27:02 - Parameter name: count
2018-07-11 18:27:02 - ArgumentOutOfRangeExceptionNon-negative number required.
2018-07-11 18:27:02 - Parameter name: count
2018-07-11 18:27:02 -   at System.IO.BinaryReader.ReadBytes (System.Int32 count) [0x00013] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-07-11 18:27:02 -   at Mono.Cecil.PE.ImageReader.ReadDebugHeader () [0x000f7] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:27:02 -   at Mono.Cecil.PE.ImageReader.ReadImage () [0x000a8] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:27:02 -   at Mono.Cecil.PE.ImageReader.ReadImage (Mono.Disposable`1[T] stream, System.String file_name) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:27:02 -   at Mono.Cecil.ModuleDefinition.ReadModule (Mono.Disposable`1[T] stream, System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x00006] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:27:02 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x0006c] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:27:02 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:27:02 -   at Mono.Cecil.AssemblyDefinition.ReadAssembly (System.String fileName) [0x00000] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:27:02 -   at Paket.LoadingScripts.PackageAndAssemblyResolution+dllFiles@61.Invoke (System.String path) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:02 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& ) [0x00020] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:02 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000c] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:02 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x0001b] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:02 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00019] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:02 -   at Paket.LoadingScripts.PackageAndAssemblyResolution.getDllsWithinPackage (Paket.FrameworkIdentifier framework, Paket.InstallModel installModel) [0x00017] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:02 -   at Paket.LoadingScripts.ScriptGeneration+generateScripts@315.Invoke (Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] knownIncludeScripts, Paket.PackageResolver+ResolvedPackage package) [0x00072] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:02 -   at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] folder, TState state, System.Collections.Generic.IEnumerable`1[T] source) [0x00037] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:02 -   at Paket.LoadingScripts.ScriptGeneration.generateScripts (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] writeScript, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getScriptFile, System.IO.DirectoryInfo includeScriptsRootFolder, Paket.FrameworkIdentifier framework, Paket.LockFile lockFile, System.IO.DirectoryInfo packagesOrGroupFolder, Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] orderedPackages) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:02 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolderGeneric@370.Invoke (Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] packages) [0x00088] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:02 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x0002a] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:02 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00014] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:02 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:02 -   at Paket.LoadingScripts.ScriptGeneration.generateScriptsForRootFolderGeneric (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.String extension, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptWriter, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterFrameworkLibs, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterNuget, Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x0009d] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:02 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolder@408-8.Invoke (Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:02 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0000d] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:02 -   at Paket.LoadingScripts.ScriptGeneration.executeCommand (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.IO.DirectoryInfo directory, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes) [0x0022c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:02 -   at Paket.UpdateProcess.SmartInstall (Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.UpdaterOptions options) [0x00178] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:02 -   at <StartupCode$Paket-Core>.$PublicAPI+Install@179.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0002e] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:02 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String rootFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00084] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:02 -   at Paket.Dependencies.Install (Paket.InstallerOptions options) [0x00013] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:02 -   at Paket.Dependencies.Install (System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean onlyReferenced, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean generateLoadScripts, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot) [0x0005c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:02 -   at Paket.Dependencies.Install (System.Boolean force) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:02 -   at FSI_0004.Paket.Package (System.Collections.Generic.IEnumerable`1[T] list) [0x00075] in <a8226ed46930477caea8d6210b77f50c>:0 
2018-07-11 18:27:02 -   at <StartupCode$FSI_0006>.$FSI_0006.main@ () [0x0002e] in <a8226ed46930477caea8d6210b77f50c>:0 
2018-07-11 18:27:02 -   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-07-11 18:27:02 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-07-11 18:27:43 - Paket.Package
2018-07-11 18:27:43 -   [  "Microsoft.Research.InferNET"
2018-07-11 18:27:43 -   ]
2018-07-11 18:27:43 - Expression evaluation failed: Non-negative number required.
2018-07-11 18:27:43 - Parameter name: count
2018-07-11 18:27:43 - ArgumentOutOfRangeExceptionNon-negative number required.
2018-07-11 18:27:43 - Parameter name: count
2018-07-11 18:27:43 -   at System.IO.BinaryReader.ReadBytes (System.Int32 count) [0x00013] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-07-11 18:27:43 -   at Mono.Cecil.PE.ImageReader.ReadDebugHeader () [0x000f7] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:27:43 -   at Mono.Cecil.PE.ImageReader.ReadImage () [0x000a8] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:27:43 -   at Mono.Cecil.PE.ImageReader.ReadImage (Mono.Disposable`1[T] stream, System.String file_name) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:27:43 -   at Mono.Cecil.ModuleDefinition.ReadModule (Mono.Disposable`1[T] stream, System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x00006] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:27:43 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x0006c] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:27:43 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:27:43 -   at Mono.Cecil.AssemblyDefinition.ReadAssembly (System.String fileName) [0x00000] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:27:43 -   at Paket.LoadingScripts.PackageAndAssemblyResolution+dllFiles@61.Invoke (System.String path) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:43 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& ) [0x00020] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:43 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000c] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:43 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x0001b] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:43 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00019] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:43 -   at Paket.LoadingScripts.PackageAndAssemblyResolution.getDllsWithinPackage (Paket.FrameworkIdentifier framework, Paket.InstallModel installModel) [0x00017] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:43 -   at Paket.LoadingScripts.ScriptGeneration+generateScripts@315.Invoke (Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] knownIncludeScripts, Paket.PackageResolver+ResolvedPackage package) [0x00072] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:43 -   at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] folder, TState state, System.Collections.Generic.IEnumerable`1[T] source) [0x00037] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:43 -   at Paket.LoadingScripts.ScriptGeneration.generateScripts (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] writeScript, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getScriptFile, System.IO.DirectoryInfo includeScriptsRootFolder, Paket.FrameworkIdentifier framework, Paket.LockFile lockFile, System.IO.DirectoryInfo packagesOrGroupFolder, Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] orderedPackages) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:43 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolderGeneric@370.Invoke (Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] packages) [0x00088] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:43 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x0002a] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:43 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00014] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:43 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:43 -   at Paket.LoadingScripts.ScriptGeneration.generateScriptsForRootFolderGeneric (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.String extension, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptWriter, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterFrameworkLibs, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterNuget, Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x0009d] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:43 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolder@408-8.Invoke (Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:43 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0000d] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:27:43 -   at Paket.LoadingScripts.ScriptGeneration.executeCommand (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.IO.DirectoryInfo directory, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes) [0x0022c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:43 -   at Paket.UpdateProcess.SmartInstall (Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.UpdaterOptions options) [0x00178] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:43 -   at <StartupCode$Paket-Core>.$PublicAPI+Install@179.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0002e] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:43 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String rootFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00084] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:43 -   at Paket.Dependencies.Install (Paket.InstallerOptions options) [0x00013] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:43 -   at Paket.Dependencies.Install (System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean onlyReferenced, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean generateLoadScripts, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot) [0x0005c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:43 -   at Paket.Dependencies.Install (System.Boolean force) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:27:43 -   at FSI_0004.Paket.Package (System.Collections.Generic.IEnumerable`1[T] list) [0x00075] in <a8226ed46930477caea8d6210b77f50c>:0 
2018-07-11 18:27:43 -   at <StartupCode$FSI_0007>.$FSI_0007.main@ () [0x00010] in <a8226ed46930477caea8d6210b77f50c>:0 
2018-07-11 18:27:43 -   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-07-11 18:27:43 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-07-11 18:28:38 - Paket.Package
2018-07-11 18:28:38 -   [ "MathNet.Numerics"
2018-07-11 18:28:38 -     "MathNet.Numerics.FSharp"
2018-07-11 18:28:38 -     "FSharp.Data"
2018-07-11 18:28:38 -     //"Microsoft.Research.InferNET"
2018-07-11 18:28:38 -   ]
2018-07-11 18:28:40 - Expression evaluation failed: Non-negative number required.
2018-07-11 18:28:40 - Parameter name: count
2018-07-11 18:28:40 - ArgumentOutOfRangeExceptionNon-negative number required.
2018-07-11 18:28:40 - Parameter name: count
2018-07-11 18:28:40 -   at System.IO.BinaryReader.ReadBytes (System.Int32 count) [0x00013] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-07-11 18:28:40 -   at Mono.Cecil.PE.ImageReader.ReadDebugHeader () [0x000f7] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:28:40 -   at Mono.Cecil.PE.ImageReader.ReadImage () [0x000a8] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:28:40 -   at Mono.Cecil.PE.ImageReader.ReadImage (Mono.Disposable`1[T] stream, System.String file_name) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:28:40 -   at Mono.Cecil.ModuleDefinition.ReadModule (Mono.Disposable`1[T] stream, System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x00006] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:28:40 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x0006c] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:28:40 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:28:40 -   at Mono.Cecil.AssemblyDefinition.ReadAssembly (System.String fileName) [0x00000] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:28:40 -   at Paket.LoadingScripts.PackageAndAssemblyResolution+dllFiles@61.Invoke (System.String path) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:40 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& ) [0x00020] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:40 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000c] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:40 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x0001b] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:40 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00019] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:40 -   at Paket.LoadingScripts.PackageAndAssemblyResolution.getDllsWithinPackage (Paket.FrameworkIdentifier framework, Paket.InstallModel installModel) [0x00017] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:40 -   at Paket.LoadingScripts.ScriptGeneration+generateScripts@315.Invoke (Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] knownIncludeScripts, Paket.PackageResolver+ResolvedPackage package) [0x00072] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:40 -   at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] folder, TState state, System.Collections.Generic.IEnumerable`1[T] source) [0x00037] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:40 -   at Paket.LoadingScripts.ScriptGeneration.generateScripts (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] writeScript, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getScriptFile, System.IO.DirectoryInfo includeScriptsRootFolder, Paket.FrameworkIdentifier framework, Paket.LockFile lockFile, System.IO.DirectoryInfo packagesOrGroupFolder, Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] orderedPackages) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:40 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolderGeneric@370.Invoke (Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] packages) [0x00088] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:40 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x0002a] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:40 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00014] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:40 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:40 -   at Paket.LoadingScripts.ScriptGeneration.generateScriptsForRootFolderGeneric (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.String extension, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptWriter, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterFrameworkLibs, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterNuget, Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x0009d] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:40 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolder@408-8.Invoke (Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:40 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0000d] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:40 -   at Paket.LoadingScripts.ScriptGeneration.executeCommand (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.IO.DirectoryInfo directory, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes) [0x0022c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:40 -   at Paket.UpdateProcess.SmartInstall (Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.UpdaterOptions options) [0x00178] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:40 -   at <StartupCode$Paket-Core>.$PublicAPI+Install@179.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0002e] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:40 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String rootFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00084] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:40 -   at Paket.Dependencies.Install (Paket.InstallerOptions options) [0x00013] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:40 -   at Paket.Dependencies.Install (System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean onlyReferenced, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean generateLoadScripts, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot) [0x0005c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:40 -   at Paket.Dependencies.Install (System.Boolean force) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:40 -   at FSI_0004.Paket.Package (System.Collections.Generic.IEnumerable`1[T] list) [0x00075] in <a8226ed46930477caea8d6210b77f50c>:0 
2018-07-11 18:28:40 -   at <StartupCode$FSI_0008>.$FSI_0008.main@ () [0x00024] in <a8226ed46930477caea8d6210b77f50c>:0 
2018-07-11 18:28:40 -   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-07-11 18:28:40 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-07-11 18:28:57 - Paket.Package
2018-07-11 18:28:57 -   [ //"MathNet.Numerics"
2018-07-11 18:28:57 -     //"MathNet.Numerics.FSharp"
2018-07-11 18:28:57 -     "FSharp.Data"
2018-07-11 18:28:57 -     //"Microsoft.Research.InferNET"
2018-07-11 18:28:57 -   ]
2018-07-11 18:28:58 - Expression evaluation failed: Non-negative number required.
2018-07-11 18:28:58 - Parameter name: count
2018-07-11 18:28:58 - ArgumentOutOfRangeExceptionNon-negative number required.
2018-07-11 18:28:58 - Parameter name: count
2018-07-11 18:28:58 -   at System.IO.BinaryReader.ReadBytes (System.Int32 count) [0x00013] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-07-11 18:28:58 -   at Mono.Cecil.PE.ImageReader.ReadDebugHeader () [0x000f7] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:28:58 -   at Mono.Cecil.PE.ImageReader.ReadImage () [0x000a8] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:28:58 -   at Mono.Cecil.PE.ImageReader.ReadImage (Mono.Disposable`1[T] stream, System.String file_name) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:28:58 -   at Mono.Cecil.ModuleDefinition.ReadModule (Mono.Disposable`1[T] stream, System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x00006] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:28:58 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x0006c] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:28:58 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:28:58 -   at Mono.Cecil.AssemblyDefinition.ReadAssembly (System.String fileName) [0x00000] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 18:28:58 -   at Paket.LoadingScripts.PackageAndAssemblyResolution+dllFiles@61.Invoke (System.String path) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:58 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& ) [0x00020] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:58 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000c] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:58 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x0001b] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:58 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00019] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:58 -   at Paket.LoadingScripts.PackageAndAssemblyResolution.getDllsWithinPackage (Paket.FrameworkIdentifier framework, Paket.InstallModel installModel) [0x00017] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:58 -   at Paket.LoadingScripts.ScriptGeneration+generateScripts@315.Invoke (Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] knownIncludeScripts, Paket.PackageResolver+ResolvedPackage package) [0x00072] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:58 -   at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] folder, TState state, System.Collections.Generic.IEnumerable`1[T] source) [0x00037] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:58 -   at Paket.LoadingScripts.ScriptGeneration.generateScripts (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] writeScript, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getScriptFile, System.IO.DirectoryInfo includeScriptsRootFolder, Paket.FrameworkIdentifier framework, Paket.LockFile lockFile, System.IO.DirectoryInfo packagesOrGroupFolder, Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] orderedPackages) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:58 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolderGeneric@370.Invoke (Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] packages) [0x00088] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:58 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x0002a] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:58 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00014] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:58 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:58 -   at Paket.LoadingScripts.ScriptGeneration.generateScriptsForRootFolderGeneric (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.String extension, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptWriter, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterFrameworkLibs, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterNuget, Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x0009d] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:58 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolder@408-8.Invoke (Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:58 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0000d] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 18:28:58 -   at Paket.LoadingScripts.ScriptGeneration.executeCommand (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.IO.DirectoryInfo directory, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes) [0x0022c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:58 -   at Paket.UpdateProcess.SmartInstall (Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.UpdaterOptions options) [0x00178] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:58 -   at <StartupCode$Paket-Core>.$PublicAPI+Install@179.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0002e] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:58 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String rootFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00084] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:58 -   at Paket.Dependencies.Install (Paket.InstallerOptions options) [0x00013] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:58 -   at Paket.Dependencies.Install (System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean onlyReferenced, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean generateLoadScripts, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot) [0x0005c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:58 -   at Paket.Dependencies.Install (System.Boolean force) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 18:28:58 -   at FSI_0004.Paket.Package (System.Collections.Generic.IEnumerable`1[T] list) [0x00075] in <a8226ed46930477caea8d6210b77f50c>:0 
2018-07-11 18:28:58 -   at <StartupCode$FSI_0009>.$FSI_0009.main@ () [0x00010] in <a8226ed46930477caea8d6210b77f50c>:0 
2018-07-11 18:28:58 -   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-07-11 18:28:58 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-07-11 19:25:43 - #load "Paket.fsx"
2018-07-11 19:25:59 - Expression evaluation failed: Non-negative number required.
2018-07-11 19:25:59 - Parameter name: count
2018-07-11 19:25:59 - ArgumentOutOfRangeExceptionNon-negative number required.
2018-07-11 19:25:59 - Parameter name: count
2018-07-11 19:25:59 -   at System.IO.BinaryReader.ReadBytes (System.Int32 count) [0x00013] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-07-11 19:25:59 -   at Mono.Cecil.PE.ImageReader.ReadDebugHeader () [0x000f7] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 19:25:59 -   at Mono.Cecil.PE.ImageReader.ReadImage () [0x000a8] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 19:25:59 -   at Mono.Cecil.PE.ImageReader.ReadImage (Mono.Disposable`1[T] stream, System.String file_name) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 19:25:59 -   at Mono.Cecil.ModuleDefinition.ReadModule (Mono.Disposable`1[T] stream, System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x00006] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 19:25:59 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName, Mono.Cecil.ReaderParameters parameters) [0x0006c] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 19:25:59 -   at Mono.Cecil.ModuleDefinition.ReadModule (System.String fileName) [0x00007] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 19:25:59 -   at Mono.Cecil.AssemblyDefinition.ReadAssembly (System.String fileName) [0x00000] in <2e24b151dd8041d8b7d36a855bb53c66>:0 
2018-07-11 19:25:59 -   at Paket.LoadingScripts.PackageAndAssemblyResolution+dllFiles@61.Invoke (System.String path) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 19:25:59 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& ) [0x00020] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 19:25:59 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000c] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 19:25:59 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x0001b] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 19:25:59 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00019] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 19:25:59 -   at Paket.LoadingScripts.PackageAndAssemblyResolution.getDllsWithinPackage (Paket.FrameworkIdentifier framework, Paket.InstallModel installModel) [0x00017] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 19:25:59 -   at Paket.LoadingScripts.ScriptGeneration+generateScripts@315.Invoke (Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] knownIncludeScripts, Paket.PackageResolver+ResolvedPackage package) [0x00072] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 19:25:59 -   at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] folder, TState state, System.Collections.Generic.IEnumerable`1[T] source) [0x00037] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 19:25:59 -   at Paket.LoadingScripts.ScriptGeneration.generateScripts (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] writeScript, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getScriptFile, System.IO.DirectoryInfo includeScriptsRootFolder, Paket.FrameworkIdentifier framework, Paket.LockFile lockFile, System.IO.DirectoryInfo packagesOrGroupFolder, Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] orderedPackages) [0x00018] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 19:25:59 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolderGeneric@370.Invoke (Paket.Domain+GroupName groupName, Microsoft.FSharp.Collections.FSharpList`1[T] packages) [0x00088] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 19:25:59 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x0002a] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 19:25:59 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00014] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 19:25:59 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00001] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 19:25:59 -   at Paket.LoadingScripts.ScriptGeneration.generateScriptsForRootFolderGeneric (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.String extension, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptGenerator, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] scriptWriter, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterFrameworkLibs, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] filterNuget, Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x0009d] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 19:25:59 -   at Paket.LoadingScripts.ScriptGeneration+generateScriptsForRootFolder@408-8.Invoke (Paket.FrameworkIdentifier framework, System.Boolean isDefaultFramework, System.IO.DirectoryInfo rootFolder) [0x00001] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 19:25:59 -   at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V,W] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2, V arg3) [0x0000d] in <5939249c904cf4daa74503839c243959>:0 
2018-07-11 19:25:59 -   at Paket.LoadingScripts.ScriptGeneration.executeCommand (Microsoft.FSharp.Collections.FSharpList`1[T] groups, System.IO.DirectoryInfo directory, Microsoft.FSharp.Collections.FSharpList`1[T] providedFrameworks, Microsoft.FSharp.Collections.FSharpList`1[T] providedScriptTypes) [0x0022c] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 19:25:59 -   at Paket.RestoreProcess.Restore (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] projectFile, System.Boolean force, Microsoft.FSharp.Core.FSharpOption`1[T] group, Microsoft.FSharp.Collections.FSharpList`1[T] referencesFileNames, System.Boolean ignoreChecks, System.Boolean failOnChecks) [0x00481] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 19:25:59 -   at <StartupCode$Paket-Core>.$PublicAPI+Restore@282-10.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x00052] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 19:25:59 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String rootFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00084] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 19:25:59 -   at Paket.Dependencies.Restore (System.Boolean force, Microsoft.FSharp.Core.FSharpOption`1[T] group, Microsoft.FSharp.Collections.FSharpList`1[T] files, System.Boolean touchAffectedRefs, System.Boolean ignoreChecks, System.Boolean failOnChecks) [0x0001b] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 19:25:59 -   at Paket.Dependencies.Restore (System.Boolean ignoreChecks) [0x00009] in <593d0e63a970bee8a7450383630e3d59>:0 
2018-07-11 19:25:59 -   at <StartupCode$FSI_0004>.$FSI_0004_Paket$fsx.main@ () [0x0006d] in <f235ad17919f47618a757a719caf2874>:0 
2018-07-11 19:25:59 -   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-07-11 19:25:59 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <77c9551943624fd18301ba6f78a841e5>:0 
2018-07-11 19:27:54 - Paket.Package
2018-07-11 19:27:54 -   [ "MathNet.Numerics"
2018-07-11 19:27:54 -     "MathNet.Numerics.FSharp"
2018-07-11 19:27:54 -     "NETStandard.Library"
2018-07-11 19:27:54 -     "Infer.NET"
2018-07-11 19:27:54 -   ]
2018-07-11 19:27:54 - The value, namespace, type or module 'Paket' is not defined.
2018-07-11 19:28:13 - Paket.Package
2018-07-11 19:28:13 -   [ "Infer.NET"
2018-07-11 19:28:13 -   ]
2018-07-11 19:28:14 - The value, namespace, type or module 'Paket' is not defined.
2018-07-11 19:44:30 - let wc = new System.Net.WebClient()
2018-07-11 19:44:30 - wc.DownloadFile(
2018-07-11 19:44:30 -     "https://download.microsoft.com/download/D/C/4/DC44E915-26FE-48AB-BD7C-AC1D92B23230/Infer.NET%202.7.1803.1901.zip", 
2018-07-11 19:44:30 -     "/home/nbuser/IfSharp/bin/packages/infer.zip")
2018-07-11 19:46:08 - open System.Diagnostics
2018-07-11 19:46:08 - let ps = 
2018-07-11 19:46:08 -     ProcessStartInfo(
2018-07-11 19:46:08 -         FileName="unzip", 
2018-07-11 19:46:08 -         Arguments="/home/nbuser/IfSharp/bin/packages/infer.zip -d /home/nbuser/IfSharp/bin/packages/infer",
2018-07-11 19:46:08 -         RedirectStandardOutput=true,UseShellExecute=false)
2018-07-11 19:46:08 - let p = Process.Start(ps)
2018-07-11 19:46:08 - p.StandardOutput.ReadToEnd()
2018-07-11 19:46:42 - #r "/home/nbuser/IfSharp/bin/packages/infer/Bin/Infer.FSharp.dll"
2018-07-11 19:52:23 - #I "/home/nbuser/IfSharp/bin/packages/infer/Bin/"
2018-07-11 19:52:23 - #r "Infer.FSharp.dll"
2018-07-11 19:53:08 - #I "/home/nbuser/IfSharp/bin/packages/infer/Bin/"
2018-07-11 19:53:08 - #r "Infer.FSharp"
2018-07-11 19:53:08 - #r "Infer.Runtime"
2018-07-11 19:53:25 - #I "/home/nbuser/IfSharp/bin/packages/infer/Bin/"
2018-07-11 19:53:25 - #r "Infer.FSharp"
2018-07-11 19:53:25 - #r "Infer.Runtime"
2018-07-11 19:53:25 - #r "Infer.Compiler"
2018-07-11 19:53:29 - open System
2018-07-11 19:53:29 - open MicrosoftResearch.Infer
2018-07-11 19:53:29 - open MicrosoftResearch.Infer.Models
2018-07-11 19:53:29 - open MicrosoftResearch.Infer.Distributions
2018-07-11 19:53:29 - open MicrosoftResearch.Infer.Factors
2018-07-11 19:53:29 - open MicrosoftResearch.Infer.FSharp
2018-07-11 19:53:29 - open MicrosoftResearch.Infer.FSharp.Variable
2018-07-11 19:54:08 - let firstCoin = Variable.Bernoulli(0.5)
2018-07-11 19:54:08 - let secondCoin = Variable.Bernoulli(0.5)
2018-07-11 19:54:08 - let bothHeads = firstCoin &&& secondCoin
2018-07-11 19:54:11 - let ie = InferenceEngine()
2018-07-11 19:54:12 - ie.Infer<Bernoulli>(bothHeads)
2018-07-11 19:54:31 - bothHeads.ObservedValue <- false
2018-07-11 19:54:31 - ie.Infer<Bernoulli>(firstCoin)
2018-07-11 19:56:40 - //Paket.Package
2018-07-11 19:56:40 - //  [ "Infer.NET"
2018-07-11 19:56:40 - //  ]
2018-07-11 19:57:50 - This solution due to Tomas Petricek.
2018-07-11 19:57:50 - First, download the ZIP file release:
2018-07-11 19:57:50 - (From https://www.microsoft.com/en-us/download/confirmation.aspx?id=52476)
2018-07-11 19:57:51 - Unexpected keyword 'to' in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2018-07-11 19:57:51 - parse error
2018-07-17 14:33:18 - // include directory, this will be replaced by the kernel
2018-07-17 14:33:18 - #I "/home/nbuser/IfSharp/bin"
2018-07-17 14:33:18 - // load base dlls
2018-07-17 14:33:18 - #r "IfSharp.Kernel.dll"
2018-07-17 14:33:18 - #r "NetMQ.dll"
2018-07-17 14:33:18 - // open the global functions and methods
2018-07-17 14:33:18 - open IfSharp.Kernel
2018-07-17 14:33:18 - open IfSharp.Kernel.Globals
2018-07-17 14:33:39 - F# Interactive for F# 4.1
2018-07-17 14:33:39 - Freely distributed under the Apache 2.0 Open Source License
2018-07-17 14:33:39 - For help type #help;;
2018-07-17 14:33:39 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-07-17 14:33:39 -   seq []
2018-07-17 14:33:39 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-07-17 14:33:39 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-07-17 14:33:39 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-07-17 16:10:19 - // include directory, this will be replaced by the kernel
2018-07-17 16:10:19 - #I "/home/nbuser/IfSharp/bin"
2018-07-17 16:10:19 - // load base dlls
2018-07-17 16:10:19 - #r "IfSharp.Kernel.dll"
2018-07-17 16:10:19 - #r "NetMQ.dll"
2018-07-17 16:10:19 - // open the global functions and methods
2018-07-17 16:10:19 - open IfSharp.Kernel
2018-07-17 16:10:19 - open IfSharp.Kernel.Globals
2018-07-17 16:10:30 - F# Interactive for F# 4.1
2018-07-17 16:10:30 - Freely distributed under the Apache 2.0 Open Source License
2018-07-17 16:10:30 - For help type #help;;
2018-07-17 16:10:30 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-07-17 16:10:30 -   seq []
2018-07-17 16:10:30 - --> Added '/home/nbuser/IfSharp/bin' to library include path
2018-07-17 16:10:30 - --> Referenced '/home/nbuser/IfSharp/bin/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-07-17 16:10:30 - --> Referenced '/home/nbuser/IfSharp/bin/NetMQ.dll' (file may be locked by F# Interactive process)
2018-07-17 16:10:36 - Unknown content type on shell. msg_type is `comm_info_request`
